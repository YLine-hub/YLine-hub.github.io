<!DOCTYPE html>
<html lang="en-us" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="如何利用系统缓存优化程序的运行效率？ 从上一篇我们可以知道，即然 Buffer 和 Cache 对系统性能有很大影响，那我们在软件开发的过程中，能不能利用这一点，来优化 I/O 性能，提升应用程序的运行效率呢？\n">
<title>[Linux]性能调优-内存篇（案例篇）- 1</title>

<link rel='canonical' href='https://YLine-hub.github.io/p/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%86%85%E5%AD%98%E7%AF%87%E6%A1%88%E4%BE%8B%E7%AF%87-1/'>

<link rel="stylesheet" href="/scss/style.min.6a692fd055deae459f2a9767f57f3855ba80cafd5041317f24f7360f6ca47cdf.css"><meta property='og:title' content="[Linux]性能调优-内存篇（案例篇）- 1">
<meta property='og:description' content="如何利用系统缓存优化程序的运行效率？ 从上一篇我们可以知道，即然 Buffer 和 Cache 对系统性能有很大影响，那我们在软件开发的过程中，能不能利用这一点，来优化 I/O 性能，提升应用程序的运行效率呢？\n">
<meta property='og:url' content='https://YLine-hub.github.io/p/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%86%85%E5%AD%98%E7%AF%87%E6%A1%88%E4%BE%8B%E7%AF%87-1/'>
<meta property='og:site_name' content='リンボの個人ブログ'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2026-01-28T11:41:06&#43;08:00'/><meta property='article:modified_time' content='2026-01-28T11:41:06&#43;08:00'/>
<meta name="twitter:title" content="[Linux]性能调优-内存篇（案例篇）- 1">
<meta name="twitter:description" content="如何利用系统缓存优化程序的运行效率？ 从上一篇我们可以知道，即然 Buffer 和 Cache 对系统性能有很大影响，那我们在软件开发的过程中，能不能利用这一点，来优化 I/O 性能，提升应用程序的运行效率呢？\n">
    <link rel="shortcut icon" href="/favicon.ico" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu_de528bff5d5e9598.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🏖️</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">リンボの個人ブログ</a></h1>
            <h2 class="site-description">努力不一定能获得回报，但不努力一定不会有回报。</h2>
        </div>
    </header><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#缓存命中率">缓存命中率</a>
      <ol>
        <li><a href="#bcc-安装问题和源码编译安装">bcc 安装问题和源码编译安装</a></li>
      </ol>
    </li>
    <li><a href="#指定文件的缓存大小">指定文件的缓存大小</a>
      <ol>
        <li><a href="#安装-go-语言二进制包">安装 go 语言（二进制包）</a></li>
        <li><a href="#安装-pcstat">安装 pcstat</a></li>
        <li><a href="#案例">案例</a>
          <ol>
            <li><a href="#准备">准备</a></li>
            <li><a href="#案例一">案例一</a></li>
            <li><a href="#案例二">案例二</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#小结">小结</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/linux/" >
                Linux
            </a>
        
            <a href="/categories/memory/" >
                Memory
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%86%85%E5%AD%98%E7%AF%87%E6%A1%88%E4%BE%8B%E7%AF%87-1/">[Linux]性能调优-内存篇（案例篇）- 1</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2026-01-28</time>
            </div>
        

        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h2>如何利用系统缓存优化程序的运行效率？</h2>
<p>从上一篇我们可以知道，即然 Buffer 和 Cache 对系统性能有很大影响，那我们在软件开发的过程中，能不能利用这一点，来优化 I/O 性能，提升应用程序的运行效率呢？</p>
<p>答案自然是肯定的。这篇，老师就用几个案例来帮我们更好地理解缓存的作用，并学习如何充分利用这些缓存来提高程序效率。</p>
<p>为了方便理解，Buffer 和 Cache 仍然用英文表示，避免跟“缓存”一词混淆。而文中的“缓存”，通指数据在内存中的临时存储。</p>
<h2 id="缓存命中率">缓存命中率
</h2><p>在案例开始前，你应该习惯性地先问自己一个问题，你想要做成某件事情，结果应该怎么评估？比如说，我们想利用缓存来提升程序的运行效率，应该怎么评估这个效果呢？换句话说，有没有哪个指标可以衡量缓存使用的好坏呢？</p>
<p><strong>缓存命中率</strong>，是指直接通过缓存获取数据的请求次数，占所有数据请求次数的百分比。</p>
<p><strong>命中率越高，表示使用缓存带来的收益越高，应用程序的性能越好</strong>。</p>
<p>实际上，缓存是现在所有高并发系统必需的核心模块，主要作用就是把经常访问的数据（也就是热点数据），提前读入到内存中。这样下次访问时就可以直接从内存中读取读取数据，而不需要经过硬盘，从而加快应用程序的响应速度。</p>
<p>这些独立的缓存模块通常会提供查询接口，方便我们随时查看缓存的命中情况。不过 Linux 系统中并没有直接提供这些接口，所以这里介绍一下，cachestat 和 cachetop，它们正是查看系统缓存命中情况的工具。</p>
<ul>
<li>
<p>cachestat 提供了整个操作系统缓存的读写命中情况。</p>
</li>
<li>
<p>cachetop 提供了每个进程的缓存命中情况。</p>
</li>
</ul>
<p>这两个工具都是<a class="link" href="https://github.com/iovisor/bcc"  target="_blank" rel="noopener"
    >bcc</a>软件包的一部分，它们基于 Linux 内核的 eBPF（extended Berkeley Packet Filters）机制，来跟踪内核中管理的缓存，并输出缓存的使用和命中情况。</p>
<p>这里的重点是，掌握这两个工具的使用方法。</p>
<p>使用 cachestat 和 cachetop 前，我们首先要安装 bcc 包。根据官方的<a class="link" href="https://github.com/iovisor/bcc/blob/master/INSTALL.md#ubuntu---binary"  target="_blank" rel="noopener"
    >INSTALL.md#ubuntu&mdash;binary</a>给的命令进行安装。</p>
<p><img src="/p/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%86%85%E5%AD%98%E7%AF%87%E6%A1%88%E4%BE%8B%E7%AF%87-1/image.png"
	width="2316"
	height="582"
	srcset="/p/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%86%85%E5%AD%98%E7%AF%87%E6%A1%88%E4%BE%8B%E7%AF%87-1/image_hu_e7b6f90af6f5a1d0.png 480w, /p/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%86%85%E5%AD%98%E7%AF%87%E6%A1%88%E4%BE%8B%E7%AF%87-1/image_hu_bb50b6520a96f235.png 1024w"
	loading="lazy"
	
		alt="alt text"
	
	
		class="gallery-image" 
		data-flex-grow="397"
		data-flex-basis="955px"
	
></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 4052245BD4284CDD
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;deb https://repo.iovisor.org/apt/</span><span class="k">$(</span>lsb_release -cs<span class="k">)</span><span class="s2"> </span><span class="k">$(</span>lsb_release -cs<span class="k">)</span><span class="s2"> main&#34;</span> <span class="p">|</span> sudo tee /etc/apt/sources.list.d/iovisor.list
</span></span><span class="line"><span class="cl">sudo apt-get update
</span></span><span class="line"><span class="cl">sudo apt-get install bcc-tools libbcc-examples linux-headers-<span class="k">$(</span>uname -r<span class="k">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>操作完这些步骤后，bcc 提供的所有工具就都安装到 /usr/share/bcc/tools 这个目录中了。不过，bcc 软件包不会默认把这些工具配置到系统的 PATH 路径中，需要自己手动配置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:/usr/share/bcc/tools
</span></span></code></pre></td></tr></table>
</div>
</div><p>配置完，就可以运行 cachestat 和 cachetop 命令了。比如，下面就是一个 cacehstat 的运行界面，它以 1 秒的时间间隔，输出了 3 组缓存统计数据：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ cachestat <span class="m">1</span> <span class="m">3</span>
</span></span><span class="line"><span class="cl">   TOTAL   MISSES     HITS  DIRTIES   BUFFERS_MB  CACHED_MB
</span></span><span class="line"><span class="cl">       <span class="m">2</span>        <span class="m">0</span>        <span class="m">2</span>        <span class="m">1</span>           <span class="m">17</span>        <span class="m">279</span>
</span></span><span class="line"><span class="cl">       <span class="m">2</span>        <span class="m">0</span>        <span class="m">2</span>        <span class="m">1</span>           <span class="m">17</span>        <span class="m">279</span>
</span></span><span class="line"><span class="cl">       <span class="m">2</span>        <span class="m">0</span>        <span class="m">2</span>        <span class="m">1</span>           <span class="m">17</span>        <span class="m">279</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，cachestat 的输出其实是一个表格。每行代表一组数据，而每一列代表不同的缓存统计指标。这些指标从左到右依次表示：</p>
<ul>
<li>TOTAL ，表示总的 I/O 次数；</li>
<li>MISSES ，表示缓存未命中的次数；</li>
<li>HITS ，表示缓存命中的次数；</li>
<li>DIRTIES， 表示新增到缓存中的脏页数；</li>
<li>BUFFERS_MB 表示 Buffers 的大小，以 MB 为单位；</li>
<li>CACHED_MB 表示 Cache 的大小，以 MB 为单位。</li>
</ul>
<p>接下来我们再来看一个 cachetop 的运行界面：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ cachetop
</span></span><span class="line"><span class="cl">11:58:50 Buffers MB: <span class="m">258</span> / Cached MB: <span class="m">347</span> / Sort: HITS / Order: ascending
</span></span><span class="line"><span class="cl">PID      UID      CMD              HITS     MISSES   DIRTIES  READ_HIT%  WRITE_HIT%
</span></span><span class="line"><span class="cl">   <span class="m">13029</span> root     python                  <span class="m">1</span>        <span class="m">0</span>        <span class="m">0</span>     100.0%       0.0%
</span></span></code></pre></td></tr></table>
</div>
</div><p>它的输出跟 top 类似，默认按照缓存的命中次数（HITS）排序，展示了每个进程的缓存命中情况。具体到每一个指标，这里的 HITS、MISSES 和 DIRTIES，跟 cachestat 里的含义一样，分别代表间隔时间内的缓存次数、未命中次数以及新增缓存中的脏页数。</p>
<p>而 <code>REAR_HIT</code> 和 <code>WRITE_HIT</code>，分别表示读和写的缓存命中率</p>
<h3 id="bcc-安装问题和源码编译安装">bcc 安装问题和源码编译安装
</h3><p>由于我安装的时候显示找不到 Release file ，所以我用源码构建进行安装。</p>
<p><img src="/p/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%86%85%E5%AD%98%E7%AF%87%E6%A1%88%E4%BE%8B%E7%AF%87-1/image-1.png"
	width="1370"
	height="402"
	srcset="/p/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%86%85%E5%AD%98%E7%AF%87%E6%A1%88%E4%BE%8B%E7%AF%87-1/image-1_hu_78fe8bbe63fb1d6d.png 480w, /p/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%86%85%E5%AD%98%E7%AF%87%E6%A1%88%E4%BE%8B%E7%AF%87-1/image-1_hu_9a7c0662c9104938.png 1024w"
	loading="lazy"
	
		alt="alt text"
	
	
		class="gallery-image" 
		data-flex-grow="340"
		data-flex-basis="817px"
	
></p>
<ol>
<li>构建依赖</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo apt install -y zip bison build-essential cmake flex git libedit-dev <span class="se">\
</span></span></span><span class="line"><span class="cl">  libllvm12 llvm-12-dev libclang-12-dev python zlib1g-dev libelf-dev libfl-dev python3-setuptools <span class="se">\
</span></span></span><span class="line"><span class="cl">  liblzma-dev arping netperf iperf
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>安装并编译 bcc</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git clone https://github.com/iovisor/bcc.git
</span></span><span class="line"><span class="cl">mkdir bcc/build<span class="p">;</span> <span class="nb">cd</span> bcc/build
</span></span><span class="line"><span class="cl">cmake ..
</span></span><span class="line"><span class="cl">make
</span></span><span class="line"><span class="cl">sudo make install
</span></span><span class="line"><span class="cl">cmake -DPYTHON_CMD<span class="o">=</span>python3 .. <span class="c1"># build python3 binding</span>
</span></span><span class="line"><span class="cl"><span class="nb">pushd</span> src/python/
</span></span><span class="line"><span class="cl">make
</span></span><span class="line"><span class="cl">sudo make install
</span></span><span class="line"><span class="cl"><span class="nb">popd</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>配置环境变量</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:/usr/share/bcc/tools
</span></span></code></pre></td></tr></table>
</div>
</div><p>运行时发生报错：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">cachestat <span class="m">1</span> <span class="m">3</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%86%85%E5%AD%98%E7%AF%87%E6%A1%88%E4%BE%8B%E7%AF%87-1/image-2.png"
	width="878"
	height="166"
	srcset="/p/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%86%85%E5%AD%98%E7%AF%87%E6%A1%88%E4%BE%8B%E7%AF%87-1/image-2_hu_186316949de996bc.png 480w, /p/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%86%85%E5%AD%98%E7%AF%87%E6%A1%88%E4%BE%8B%E7%AF%87-1/image-2_hu_70f662c9216a084e.png 1024w"
	loading="lazy"
	
		alt="alt text"
	
	
		class="gallery-image" 
		data-flex-grow="528"
		data-flex-basis="1269px"
	
></p>
<h2 id="指定文件的缓存大小">指定文件的缓存大小
</h2><p>除了缓存的命中率外，还有一个指标你可能也会很感兴趣，那就是指定文件在内存中的缓存大小。你可以使用 <a class="link" href="https://github.com/tobert/pcstat"  target="_blank" rel="noopener"
    >pcstat</a> 这个工具，来查看文件在内存中的缓存大小以及缓存比例。</p>
<p>pcstat 是一个基于 Go 语言开发的工具，所以安装它之前，你首先应该安装 Go 语言，你可以点击<a class="link" href="https://go.dev/dl/"  target="_blank" rel="noopener"
    >这里</a>下载安装。</p>
<h3 id="安装-go-语言二进制包">安装 go 语言（二进制包）
</h3><ol>
<li>下载 go 语言二进制包</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">wget https://go.dev/dl/go1.24.12.linux-arm64.tar.gz
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">--2026-01-29 02:52:15--  https://go.dev/dl/go1.24.12.linux-arm64.tar.gz
</span></span><span class="line"><span class="cl">Resolving go.dev <span class="o">(</span>go.dev<span class="o">)</span>... 216.239.34.21, 216.239.32.21, 216.239.36.21, ...
</span></span><span class="line"><span class="cl">Connecting to go.dev <span class="o">(</span>go.dev<span class="o">)</span><span class="p">|</span>216.239.34.21<span class="p">|</span>:443... connected.
</span></span><span class="line"><span class="cl">Unable to establish SSL connection.
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>更新 SSL 证书，再重新下载</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 更新系统 CA 证书</span>
</span></span><span class="line"><span class="cl">sudo apt update
</span></span><span class="line"><span class="cl">sudo apt install --reinstall ca-certificates
</span></span><span class="line"><span class="cl">sudo update-ca-certificates
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 然后重试下载</span>
</span></span><span class="line"><span class="cl">wget https://go.dev/dl/go1.24.12.linux-arm64.tar.gz
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>移除以前的 go 环境，解压 go 安装包，安装到 /usr/local 目录下</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">rm -rf /usr/local/go <span class="o">&amp;&amp;</span> tar -C /usr/local -xzf go1.24.12.linux-arm64.tar.gz
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>添加环境变量</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:/usr/local/go/bin
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="5">
<li>验证安装</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">go version
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%86%85%E5%AD%98%E7%AF%87%E6%A1%88%E4%BE%8B%E7%AF%87-1/image-3.png"
	width="468"
	height="60"
	srcset="/p/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%86%85%E5%AD%98%E7%AF%87%E6%A1%88%E4%BE%8B%E7%AF%87-1/image-3_hu_ffb8692edf807d05.png 480w, /p/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%86%85%E5%AD%98%E7%AF%87%E6%A1%88%E4%BE%8B%E7%AF%87-1/image-3_hu_ec31d8c17461932d.png 1024w"
	loading="lazy"
	
		alt="alt text"
	
	
		class="gallery-image" 
		data-flex-grow="780"
		data-flex-basis="1872px"
	
></p>
<ol start="6">
<li>添加 ～/go/bin 环境变量</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">GOPATH</span><span class="o">=</span>~/go
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span>~/go/bin:<span class="nv">$PATH</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><font color=red>注意1：如果不添加这个环境变量，将会出现以下问题</font></p>
<p><img src="/p/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%86%85%E5%AD%98%E7%AF%87%E6%A1%88%E4%BE%8B%E7%AF%87-1/image-4.png"
	width="952"
	height="434"
	srcset="/p/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%86%85%E5%AD%98%E7%AF%87%E6%A1%88%E4%BE%8B%E7%AF%87-1/image-4_hu_2c7a1dd4497210c4.png 480w, /p/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%86%85%E5%AD%98%E7%AF%87%E6%A1%88%E4%BE%8B%E7%AF%87-1/image-4_hu_58112a81a0fa81d.png 1024w"
	loading="lazy"
	
		alt="alt text"
	
	
		class="gallery-image" 
		data-flex-grow="219"
		data-flex-basis="526px"
	
></p>
<p><font color=red>注意2：直接在命令行使用<code>export GOPATH=~/go</code>这种属于临时变量，只在当前终端生效</font></p>
<ul>
<li>用户级永久变量：添加到 <code>~/.bashrc</code>，只对当前用户生效</li>
<li>系统级永久变量：添加到 <code>/etc/profile</code>，对所有用户生效</li>
</ul>
<ol start="7">
<li>查看当前所有环境变量</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">echo</span> <span class="nv">$PATH</span>
</span></span><span class="line"><span class="cl">/root/go/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/usr/share/bcc/tools:/usr/local/go/bin
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="安装-pcstat">安装 pcstat
</h3><ol>
<li>安装完 Go 语言后，再运行下面命令安装 pcstat:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">go install github.com/tobert/pcstat@latest
</span></span></code></pre></td></tr></table>
</div>
</div><p>全部安装完成后，你就可以运行 pcstat 来查看文件的缓存情况了。比如，下面就是一个 pcstat 运行的示例</p>
<ol start="2">
<li>展示 /bin/ls 这个文件的缓存情况：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">pcstat /bin/ls
</span></span><span class="line"><span class="cl">+---------+----------------+------------+-----------+---------+
</span></span><span class="line"><span class="cl"><span class="p">|</span> Name    <span class="p">|</span> Size <span class="o">(</span>bytes<span class="o">)</span>   <span class="p">|</span> Pages      <span class="p">|</span> Cached    <span class="p">|</span> Percent <span class="p">|</span>
</span></span><span class="line"><span class="cl"><span class="p">|</span>---------+----------------+------------+-----------+---------<span class="p">|</span>
</span></span><span class="line"><span class="cl"><span class="p">|</span> /bin/ls <span class="p">|</span> <span class="m">133792</span>         <span class="p">|</span> <span class="m">33</span>         <span class="p">|</span> <span class="m">0</span>         <span class="p">|</span> 000.000 <span class="p">|</span>
</span></span><span class="line"><span class="cl">+---------+----------------+------------+-----------+---------+
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Cached 就是 /bin/ls 在缓存中的大小。</li>
<li>Percent 则是缓存的百分比。</li>
</ul>
<p>看到它们都是 0，这说明 /bin/ls 并不在缓存中。</p>
<ol start="3">
<li>执行一下 ls 命令，再运行相同的命令查看</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ls
</span></span><span class="line"><span class="cl">pcstat /bin/ls
</span></span><span class="line"><span class="cl">+---------+----------------+------------+-----------+---------+
</span></span><span class="line"><span class="cl"><span class="p">|</span> Name    <span class="p">|</span> Size <span class="o">(</span>bytes<span class="o">)</span>   <span class="p">|</span> Pages      <span class="p">|</span> Cached    <span class="p">|</span> Percent <span class="p">|</span>
</span></span><span class="line"><span class="cl"><span class="p">|</span>---------+----------------+------------+-----------+---------<span class="p">|</span>
</span></span><span class="line"><span class="cl"><span class="p">|</span> /bin/ls <span class="p">|</span> <span class="m">133792</span>         <span class="p">|</span> <span class="m">33</span>         <span class="p">|</span> <span class="m">33</span>        <span class="p">|</span> 100.000 <span class="p">|</span>
</span></span><span class="line"><span class="cl">+---------+----------------+------------+-----------+---------+
</span></span></code></pre></td></tr></table>
</div>
</div><p>能够看到， /bin/ls 都在缓存中了。</p>
<p>知道了缓存相应的指标和查看系统缓存的方法后，接下来，我们就进入今天的正式案例。</p>
<h3 id="案例">案例
</h3><h4 id="准备">准备
</h4><ul>
<li>系统配置：ubuntu 18.04</li>
<li>机器配置：2 CPU，8 GB 内存。</li>
<li>预先安装上面步骤的 bcc 和 pcstat 软件包，并把这些工具的安装路径添加到 PATH 环境变量中。</li>
<li>预先安装 Docker 软件包</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">apt-get install docker.io
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="案例一">案例一
</h4><p>第一个案例，先来看一下上一篇提到的 dd 命令。</p>
<p>dd 作为一个磁盘和文件的拷贝工具，经常被拿来测试磁盘或者文件系统的读写性能。不过，即然缓存会影响到性能，如果用 dd 对同一个文件进行多次读取测试，测试结果会怎么样呢？</p>
<ol>
<li>
<p>打开两个终端，连接到 ubuntu 机器上。</p>
</li>
<li>
<p>终端1：使用 dd 命令生成一个临时文件，用于后面的文件读取测试：</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">dd <span class="k">if</span><span class="o">=</span>/dev/sda1 <span class="nv">of</span><span class="o">=</span>file <span class="nv">bs</span><span class="o">=</span>1M <span class="nv">count</span><span class="o">=</span><span class="m">512</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>终端1：清理缓存</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">echo</span> <span class="m">3</span> &gt; /proc/sys/vm/drop_caches
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>终端1：运行 pcstat 命令，确认刚刚生成的文件不在缓存中。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">pcstat file
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">+-------+----------------+------------+-----------+---------+
</span></span><span class="line"><span class="cl"><span class="p">|</span> Name  <span class="p">|</span> Size <span class="o">(</span>bytes<span class="o">)</span>   <span class="p">|</span> Pages      <span class="p">|</span> Cached    <span class="p">|</span> Percent <span class="p">|</span>
</span></span><span class="line"><span class="cl"><span class="p">|</span>-------+----------------+------------+-----------+---------<span class="p">|</span>
</span></span><span class="line"><span class="cl"><span class="p">|</span> file  <span class="p">|</span> <span class="m">536870912</span>      <span class="p">|</span> <span class="m">131072</span>     <span class="p">|</span> <span class="m">0</span>         <span class="p">|</span> 000.000 <span class="p">|</span>
</span></span><span class="line"><span class="cl">+-------+----------------+------------+-----------+---------+
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到 Cached 和 Percent 都是 0。</p>
<ol start="5">
<li>终端1：运行 cachetop 命令</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 每隔 5 秒刷新一次数据</span>
</span></span><span class="line"><span class="cl">cachetop <span class="m">5</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="6">
<li>终端2：运行 dd 命令，测试文件的读取速度</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">dd <span class="k">if</span><span class="o">=</span>file <span class="nv">of</span><span class="o">=</span>/dev/null <span class="nv">bs</span><span class="o">=</span>1M
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">512+0 records in
</span></span><span class="line"><span class="cl">512+0 records out
</span></span><span class="line"><span class="cl"><span class="m">536870912</span> bytes <span class="o">(</span><span class="m">537</span> MB, <span class="m">512</span> MiB<span class="o">)</span> copied, 16.0509 s, 33.4 MB/s
</span></span></code></pre></td></tr></table>
</div>
</div><p>从 dd 的结果可以看出，这个文件的读性能是 33.4 MB/s。由于在 dd 命令运行前我们已经清理了缓存，所以 dd 命令读取数据时，肯定要通过文件系统从磁盘中读取。</p>
<p>不过，这是不是意味着，dd 所有的读请求都能直接发送到磁盘呢？</p>
<ol start="7">
<li>终端1：查看 cachetop 界面的缓存命中情况</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">PID      UID      CMD              HITS     MISSES   DIRTIES  READ_HIT%  WRITE_HIT%
</span></span><span class="line"><span class="cl"><span class="se">\.\.\.</span>
</span></span><span class="line"><span class="cl">    <span class="m">3264</span> root     dd                  <span class="m">37077</span>    <span class="m">37330</span>        <span class="m">0</span>      49.8%      50.2%
</span></span></code></pre></td></tr></table>
</div>
</div><p>从 cachetop 的结果可以发现，并不是所有的读都落到了磁盘上，事实上读请求的缓存命中率只有 50%。</p>
<ol start="8">
<li>终端2：继续尝试相同的测试命令</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">dd <span class="k">if</span><span class="o">=</span>file <span class="nv">of</span><span class="o">=</span>/dev/null <span class="nv">bs</span><span class="o">=</span>1M
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">512+0 records in
</span></span><span class="line"><span class="cl">512+0 records out
</span></span><span class="line"><span class="cl"><span class="m">536870912</span> bytes <span class="o">(</span><span class="m">537</span> MB, <span class="m">512</span> MiB<span class="o">)</span> copied, 0.118415 s, 4.5 GB/s
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到此次磁盘的读性能达到了 4.5 GB/s，比第一次明显高了太多。</p>
<ol start="9">
<li>终端1：查看 cachetop 的情况</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">10:45:22 Buffers MB: <span class="m">4</span> / Cached MB: <span class="m">719</span> / Sort: HITS / Order: ascending
</span></span><span class="line"><span class="cl">PID      UID      CMD              HITS     MISSES   DIRTIES  READ_HIT%  WRITE_HIT%
</span></span><span class="line"><span class="cl"><span class="se">\.\.\.</span>
</span></span><span class="line"><span class="cl">   <span class="m">32642</span> root     dd                 <span class="m">131637</span>        <span class="m">0</span>        <span class="m">0</span>     100.0%       0.0%
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，cachetop 这次的读的缓存命中率时 100.0%，也就是说这次的 dd 命令全部命中了缓存，所以才会有那么高的性能。</p>
<ol start="10">
<li>终端2：运行 pcstat 命令，查看文件 file 的缓存情况。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">pcstat file
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">+-------+----------------+------------+-----------+---------+
</span></span><span class="line"><span class="cl"><span class="p">|</span> Name  <span class="p">|</span> Size <span class="o">(</span>bytes<span class="o">)</span>   <span class="p">|</span> Pages      <span class="p">|</span> Cached    <span class="p">|</span> Percent <span class="p">|</span>
</span></span><span class="line"><span class="cl"><span class="p">|</span>-------+----------------+------------+-----------+---------<span class="p">|</span>
</span></span><span class="line"><span class="cl"><span class="p">|</span> file  <span class="p">|</span> <span class="m">536870912</span>      <span class="p">|</span> <span class="m">131072</span>     <span class="p">|</span> <span class="m">131072</span>    <span class="p">|</span> 100.000 <span class="p">|</span>
</span></span><span class="line"><span class="cl">+-------+----------------+------------+-----------+---------+
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，测试文件 file 已经被全部缓存起来了，这跟刚才观察到的缓存命中率 100% 是一致的。</p>
<p>这两次结果说明，系统缓存对第二次 dd 操作有明显的加速效果，可以大大提高文件读取的性能。</p>
<p>但同时也要注意，如果我们把 dd 当成测试文件系统性能的工具，由于缓存的存在，就会导致测试结果严重失真。</p>
<h4 id="案例二">案例二
</h4><p>接下来，我们再来看一个文件读写的案例。这个案例类似于前面学过的不可中断状态进程的例子。它的基本功能比较简单，也就是每秒从磁盘分区 /dev/sda1 中读取 32MB 的数据，并打印出读取数据花费的时间。</p>
<p>为了方便运行案例，老师把它打包成了一个 <a class="link" href="https://github.com/feiskyer/linux-perf-examples/tree/master/io-cached"  target="_blank" rel="noopener"
    >Docker 镜像</a>。 跟前面案例类似，提供了下面两个选项，可以根据系统配置，自行调整磁盘分区的路径以及 I/O 的大小。</p>
<ul>
<li>
<p>-d 选项，设置要读取的磁盘或分区路径，默认是查找前缀为 /dev/sd 或者 /dev/xvd 的磁盘。</p>
</li>
<li>
<p>-s 选项，设置每次读取的数据量大小，单位为字节，默认为 33554432（也就是 32MB）。</p>
</li>
</ul>
<ol>
<li>
<p>开启两个终端，分别连接上 ubuntu 机器。</p>
</li>
<li>
<p>终端1：运行 cachetop 命令</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 每隔5秒刷新一次数据</span>
</span></span><span class="line"><span class="cl">cachetop <span class="m">5</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>终端2：运行 docker 案例</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker run --privileged --name<span class="o">=</span>app -itd feisky/app:io-direct
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>终端2：验证案例是否已经启动</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker logs app
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">Reading data from disk /dev/sdb1 with buffer size <span class="m">33554432</span>
</span></span><span class="line"><span class="cl">Time used: 0.929935 s to <span class="nb">read</span> <span class="m">33554432</span> bytes
</span></span><span class="line"><span class="cl">Time used: 0.949625 s to <span class="nb">read</span> <span class="m">33554432</span> bytes
</span></span></code></pre></td></tr></table>
</div>
</div><p>从这里可以看到，每读取 32 MB 的数据，就需要花 0.9 秒。这个时间合理吗？这太慢了吧。那这是不是没用系统缓存导致的呢？</p>
<p>再来检查一下。</p>
<ol start="5">
<li>终端1：看看 cachetop 的输出，在这里，我们找到案例进程 app 的缓存使用情况：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">16:39:18 Buffers MB: <span class="m">73</span> / Cached MB: <span class="m">281</span> / Sort: HITS / Order: ascending
</span></span><span class="line"><span class="cl">PID      UID      CMD              HITS     MISSES   DIRTIES  READ_HIT%  WRITE_HIT%
</span></span><span class="line"><span class="cl">   <span class="m">21881</span> root     app                  <span class="m">1024</span>        <span class="m">0</span>        <span class="m">0</span>     100.0%       0.0% 
</span></span></code></pre></td></tr></table>
</div>
</div><p>从输出中可以看到。1024 次缓存全部命中，读的命中率是 100%，看起来全部的读请求都经过了系统缓存。但是问题又来了，如果真的都是缓存 I/O，读取速度不应该这么慢。</p>
<p>不过，话说回来，我们似乎忽略了另一个重要因素，每秒实际读取的数据大小。HITS 代表缓存的命中次数，那么每次命中能读取多少数据呢？自然是一页。</p>
<p>前面讲过，内存以页为单位进行管理，而每个页的大小是 4KB。所以，在 5 秒的时间间隔里，命中的缓存为 1024*4K/1024 = 4MB，再除以 5 秒，可以得到每秒读的缓存是 0.8MB，显然跟案例应用的 32 MB/s 相差太多。</p>
<p>这也进一步验证了我们的猜想，这个案例估计没有充分利用系统缓存。其实前面我们遇到过类似的问题，如果为系统调用设置直接 I/O 的标志，就可以绕过系统缓存。</p>
<p>那么，如何判断应用程序是否用了直接 I/O，最简单的办法是观察它的系统调用，查找应用程序在调用它们时的选项。自然还是使用 <code>strace</code> 工具来观察系统调用。</p>
<ol start="6">
<li>终端2：运行 strace 命令，观察案例应用程序的系统调用情况，并且使用 pgrep 来查找案例进程的 pid</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">strace -p <span class="k">$(</span>pgrep app<span class="k">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">strace: Process <span class="m">4988</span> attached
</span></span><span class="line"><span class="cl">restart_syscall<span class="o">(</span>&lt;<span class="se">\.\.\.</span> resuming interrupted nanosleep <span class="se">\.\.\.</span>&gt;<span class="o">)</span> <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">openat<span class="o">(</span>AT_FDCWD, <span class="s2">&#34;/dev/sdb1&#34;</span>, O_RDONLY<span class="p">|</span>O_DIRECT<span class="o">)</span> <span class="o">=</span> <span class="m">4</span>
</span></span><span class="line"><span class="cl">mmap<span class="o">(</span>NULL, 33558528, PROT_READ<span class="p">|</span>PROT_WRITE, MAP_PRIVATE<span class="p">|</span>MAP_ANONYMOUS, -1, 0<span class="o">)</span> <span class="o">=</span> 0x7f448d240000
</span></span><span class="line"><span class="cl">read<span class="o">(</span>4, <span class="s2">&#34;8vq\213\314\264u\373\4\336K\224\25@\371\1\252\2\262\252q\221\n0\30\225bD\252\266@J&#34;</span><span class="se">\.\.\.</span>, 33554432<span class="o">)</span> <span class="o">=</span> <span class="m">33554432</span>
</span></span><span class="line"><span class="cl">write<span class="o">(</span>1, <span class="s2">&#34;Time used: 0.948897 s to read 33&#34;</span><span class="se">\.\.\.</span>, 45<span class="o">)</span> <span class="o">=</span> <span class="m">45</span>
</span></span><span class="line"><span class="cl">close<span class="o">(</span>4<span class="o">)</span>                                <span class="o">=</span> <span class="m">0</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从 strace 的结果可以看到，案例应用调用了 openat 来打开磁盘分区 /dev/sdb1，并且传入的参数为 O_RDONLY|O_DIRECT（中间的竖线表示或）。</p>
<p>O_RDONLY 表示以只读方式打开，而 O_DIRECT 则表示以直接读取的方式打开，这会绕过系统的缓存。</p>
<p>验证了这一点，就很容易理解为什么读 32 MB 的数据就都要那么久了。直接从磁盘读写的速度，自然远慢于对缓存的读写。这也是缓存存在的最大意义了。</p>
<p>找出问题后，可以再看看案例应用的 <a class="link" href="https://github.com/feiskyer/linux-perf-examples/blob/master/io-cached/app.c"  target="_blank" rel="noopener"
    >源代码</a>，再次验证一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">O_RDONLY</span> <span class="o">|</span> <span class="n">O_LARGEFILE</span> <span class="o">|</span> <span class="n">O_DIRECT</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mo">0755</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，它果然用了直接 I/O。</p>
<p>优化：找出了磁盘读取缓慢的原因，优化磁盘读的性能自然不在话下。修改源代码，删除 O_DIRECT 选项，让应用程序使用缓存 I/O ，而不是直接 I/O，就可以加速磁盘读取速度。</p>
<p><a class="link" href="https://github.com/feiskyer/linux-perf-examples/blob/master/io-cached/app-cached.c"  target="_blank" rel="noopener"
    >app-cached.c</a> 就是修复后的源码，老师也把它打包成了一个容器镜像。</p>
<ol start="7">
<li>终端2：按 Ctrl+C 停止刚才的 strace 命令，运行下面的命令，启动它：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 删除上述案例应用</span>
</span></span><span class="line"><span class="cl">docker rm -f app
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 运行修复后的应用</span>
</span></span><span class="line"><span class="cl">docker run --privileged --name<span class="o">=</span>app -itd feisky/app:io-cached
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="8">
<li>终端2：验证 docker 是否启动</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker logs app
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">Reading data from disk /dev/sdb1 with buffer size <span class="m">33554432</span>
</span></span><span class="line"><span class="cl">Time used: 0.037342 s s to <span class="nb">read</span> <span class="m">33554432</span> bytes
</span></span><span class="line"><span class="cl">Time used: 0.029676 s to <span class="nb">read</span> <span class="m">33554432</span> bytes
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在，每次只需要 0.03 秒，就可以读取 32MB 数据，明显比之前的 0.9 秒快多了。所以，这次应该用了系统缓存。</p>
<ol start="9">
<li>终端，查看 cachetop 的输出来确认一下：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">16:40:08 Buffers MB: <span class="m">73</span> / Cached MB: <span class="m">281</span> / Sort: HITS / Order: ascending
</span></span><span class="line"><span class="cl">PID      UID      CMD              HITS     MISSES   DIRTIES  READ_HIT%  WRITE_HIT%
</span></span><span class="line"><span class="cl">   <span class="m">22106</span> root     app                 <span class="m">40960</span>        <span class="m">0</span>        <span class="m">0</span>     100.0%       0.0%
</span></span></code></pre></td></tr></table>
</div>
</div><p>果然，读的命中率还是 100%，HITS （即命中数）却变成了 40960，同样的方法计算一下，换算成每秒字节数正好是 32 MB（即 40960*4k/5/1024=32M）。</p>
<p>这个案例说明，在进行 I/O 操作时，充分利用系统缓存可以极大地提升性能。 但在观察缓存命中率时，还要注意结合应用程序实际的 I/O 大小，综合分析缓存的使用情况。</p>
<p>案例的最后，再回到开始的问题，为什么优化前，通过 cachetop 只能看到很少一部分数据的全部命中，而没有观察到大量数据的未命中情况呢？这是因为，cachetop 工具并不把直接 I/O 算进来。这也又一次说明了，了解工具原理的重要。</p>
<blockquote>
<p>cachetop 的计算方法涉及到 I/O 的原理以及一些内核的知识，如果你想了解它的原理的话，可以点击<a class="link" href="https://github.com/iovisor/bcc/blob/master/tools/cachetop.py"  target="_blank" rel="noopener"
    >这里</a>查看它的源代码。</p>
</blockquote>
<h2 id="小结">小结
</h2><p>Buffers 和 Cache 可以极大提升系统的 I/O 性能。通常，我们用缓存命中率，来衡量缓存的使用效率。命中率越高，表示缓存被利用得越充分，应用程序的性能也就越好。</p>
<p>可以用 cachestat 和 cachetop 这两个工具，观察系统和进程的缓存命中情况。其中，</p>
<ul>
<li>
<p>cachestat 提供了整个系统缓存的读写命中情况。</p>
</li>
<li>
<p>cachetop 提供了每个进程的缓存命中情况。</p>
</li>
</ul>
<p>不过要注意，Buffers 和 Cache 都是操作系统来管理的，应用程序并不能直接控制这些缓存的内容和生命周期。所以，在应用程序开发中，一般要用专门的缓存组件，来进一步提升性能。</p>
<p>比如，程序内部可以使用堆或者栈明确声明内存空间，来存储需要缓存的数据。再或者，使用 Redis 这类外部缓存服务，优化数据的访问效率。</p>

</section>


    <footer class="article-footer">
    

    </footer>


    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="">
    <a href="/p/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%86%85%E5%AD%98%E7%AF%87%E5%A5%97%E8%B7%AF%E7%AF%87/">
        
        

        <div class="article-details">
            <h2 class="article-title">[Linux]性能调优-内存篇（套路篇）</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/p/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%86%85%E5%AD%98%E7%AF%87%E6%A1%88%E4%BE%8B%E7%AF%87-3/">
        
        

        <div class="article-details">
            <h2 class="article-title">[Linux]性能调优-内存篇（案例篇）- 3</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/p/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%86%85%E5%AD%98%E7%AF%87%E6%A1%88%E4%BE%8B%E7%AF%87-2/">
        
        

        <div class="article-details">
            <h2 class="article-title">[Linux]性能调优-内存篇（案例篇）- 2</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/p/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%86%85%E5%AD%98%E7%AF%87%E5%9F%BA%E7%A1%80%E7%AF%87-2/">
        
        

        <div class="article-details">
            <h2 class="article-title">[Linux]性能调优-内存篇（基础篇）- 2</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/p/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%86%85%E5%AD%98%E7%AF%87%E5%9F%BA%E7%A1%80%E7%AF%87/">
        
        

        <div class="article-details">
            <h2 class="article-title">[Linux]性能调优-内存篇（基础篇）</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2025 - 
        
        2026 リンボの個人ブログ
    </section>
    
    <section class="powerby">
         <br />
        
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
