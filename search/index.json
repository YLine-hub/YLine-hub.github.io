[{"content":"MySQL基础-SQL SQL通用语法 SQL语句可以单行或多行书写，以分号结尾。 SQL语句可以使用空格/缩进来增强语句的可读性。 MySQL数据库的SQL语句不区分大小写，关键词建议使用大写。 注释： 单行注释： \u0026ndash; 注释内容 或 # 注释内容 （MySQL特有） 多行注释：/* 注释内容 */ SQL分类 分类 全称 说明 DDL Data Definition Language 数据定义语言，用来定义数据库对象（数据库，表，字段） DML Data Manipulation Language 数据操作语言，用来对数据库表中的数据进行增删该 DQL Data Query Language 数据查询语言，用来查询数据库中表的记录 DCL Data Control Language 数据控制语言，用来创建数据库用户、控制数据库的访问权限 DDL-数据库操作 查询 1 2 3 4 # 查询所有数据库 SHOW DATABASES; # 查询当前数据库 SELECT DATABASE(); 查询所有数据库 查询当前的数据库 创建 1 2 # [如果不存在则]创建数据库 CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则]; 创建数据库itcast： 1 create database itcast; 再次创建数据库itcast： 报错：ERROR 1007 (HY000): Can\u0026rsquo;t create database \u0026lsquo;itcast\u0026rsquo;; database exists\n表示：数据库已经存在，无法再创建\n使用if not exists再次创建itcast: 1 create database if not exists itcast; 语句执行成功，但是没有新增数据库\n创建数据库itfost并设置字符集utf8mb4 不推荐使用utf8，因为utf8存储的长度为3个字节；推荐使用utf8mb4，它支持4个字节。\n1 create database itfox default charset utf8mb4; 删除 1 2 # [如果存在则]删除数据库 DROP DATABASE [IF EXISTS] 数据库名； 删除数据库itfox 1 drop database itfox; 再次删除数据库itfox 报错：数据库不存在\n如果不想报错，可以在数据库前加上if exists 1 drop database if exists itfox; 使用 1 USE 数据库名; 使用itcast数据库 1 use itcast; DDL-表操作 查询 查询当前数据库所有表 1 SHOW TABLES; 查询itcast数据库所有表 切换成sys数据库 1 use sys; 查询sys数据库的所有表 查询表结构 1 DESC 表名; 查询itcast中tb_user表结构 1 desc tb_user; 查询指定表的建表语句 1 SHOW CREATE TABLE 表名; 查询itcast数据库中tb_user的建表语句 1 show create table tb_user; 创建 创建表 1 2 3 4 5 6 7 CREATE TABLE 表名( 字段1 字段1类型[COMMENT 字段1注释], 字段2 字段2类型[COMMENT 字段2注释], 字段3 字段3类型[COMMENT 字段3注释], ... 字段n 字段n类型[COMMENT 字段n注释] )[COMMENT 表注释] 注意：[\u0026hellip;]为可选参数，最后一个字段后面没有逗号\n根据该表格在itcast数据库中相应表 id name age gender 1 令狐冲 28 男 2 风清扬 68 男 3 东方不败 32 男 1 2 3 4 5 6 create table tb_user( id int comment \u0026#39;编号\u0026#39;, name varchar(50) comment \u0026#39;姓名\u0026#39;, age int comment \u0026#39;年龄\u0026#39;, gender varchar(1) comment \u0026#39;性别\u0026#39; )comment \u0026#39;用户表\u0026#39;; 验证表是否被创建 1 show tables; ","date":"2025-10-13T00:13:16+08:00","permalink":"https://YLine-hub.github.io/p/mysqlmysql%E5%9F%BA%E7%A1%80-sql/","title":"[MySQL]MySQL基础-SQL"},{"content":"问题：解压nginx压缩包后，解压的文件不属于当前用户 查看当前用户 1 id 这里能看到当前用户是root\n解压nginx压缩包 1 tar -zxvf nginx-1.22.1.tar.gz 可以看到nginx文件夹属于1001用户，mysql组\n检查系统中1001和mysql的信息 1 2 grep 1001 /etc/passwd grep mysql /etc/group 原因 其实根源在于你解压的时候没有明确指定 属主和属组的情况下。 解压时使用的是压缩文件中保存的属主和属组信息。\n通过-tvf参数组合来查看压缩包中的文件信息 1 tar -tvf nginx-1.22.1.tar.gz 可以看到这里展示的用户和用户组是mdounin/mdounin，主机中肯定没有这个用户，而且也不是root\n可以在后面添加一个参数--numeric-owner 1 tar -tvf nginx-1.22.1.tar.gz --numeric-owner 看到这里显示的属主和属组是1001/1001，正是对应当前主机上对应的mysql组。\n解压之后的属主和属组不影响实际使用。\n可以解压后修改属主和属组 1 2 # -R 参数是递归所有子目录与文件 chown -R 属主:属组 文件夹 例如这里可以用\n1 chown -R root:root nginx-1.22.1 ","date":"2025-10-12T21:25:31+08:00","permalink":"https://YLine-hub.github.io/p/linux%E5%B0%8F%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0-%E5%8E%8B%E7%BC%A9%E5%8C%85%E8%A7%A3%E5%8E%8B%E5%90%8E%E5%B1%9E%E4%B8%BB%E5%92%8C%E5%B1%9E%E7%BB%84%E4%B8%8D%E6%98%AF%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%E9%97%AE%E9%A2%98/","title":"[Linux]小知识学习-压缩包解压后属主和属组不是当前用户问题"},{"content":"nginx安装配置 卸载nginx 安装前查看系统内是否有nginx 1 ps -ef | grep nginx 上图可以看出没有nginx服务启动\n关闭nginx服务（若有nginx） 1 kill 进程ID 查看是否有nginx相关文件 1 find / -name nginx 删除nginx有关文件（若有nginx相关文件） 1 rm -rf 文件名 安装nginx 安装nginx所需环境 安装nginx需要下载官网源码编译，编译依赖 gcc 环境 (gcc-c++) nginx的http模块使用pcre来解析正则表达式，所以需要pcre库 (pcre pcre-devel) nginx使用zlib对http包进行gzip，所以需要zlib库 (zlib zlib-devel) nginx不仅支持http协议，还支持https协议（即在ssl协议上传输http），所以需要OpenSSL库 (openssl openssl-devel) 1 yum -y install gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel 在/usr/local目录下创建nginx目录 1 mkdir /usr/local/nginx 下载nginx解压包到/opt目录下 nginx下载地址：nginx download\n选择其中自己需要的版本，我这里选择1.22.1版本 1 2 3 4 # 到 /opt目录下 cd /opt # 下载nginx wget https://nginx.org/download/nginx-1.22.1.tar.gz 解压安装包，并配置编译安装nginx 解压安装包 1 tar -zxvf nginx-1.22.1.tar.gz 进入nginx-1.22.1目录中 1 cd nginx-1.22.1 配置 1 ./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module 编译和安装 1 2 3 4 # 编译 make # 安装 make install 注意：nginx配置的目标目录和配置编译安装的目录不能是同一个。比如这里配置的目标目录是/usr/local/nginx，用来配置编译安装的目录是/opt/nginx-1.22.1\n配置环境变量（方便快速启动nginx） 1 2 echo \u0026#34;export PATH=$PATH:/usr/local/nginx/sbin\u0026#34; \u0026gt;\u0026gt; /etc/profile source /etc/profile 启动关闭nginx服务 1 2 3 4 5 6 # 启动nginx服务 ./nginx # 修改配置后，重新加载配置 ./nginx -s reload # 关闭nginx服务 ./nginx -s stop 查询是否正在运行 用netstat查询是否正在运行 1 netstat -ntlp 没有netstat命令\n查询netstat命令在哪个包内 1 yum search netstat 下载net-tools包 1 yum -y install net-tools 再次查询 1 netstat -ntlp 说明启动成功\n打开80端口 nginx默认使用80端口，如果修改了，就需要开放相应的端口 1 2 3 4 5 6 # 查看80端口是否开启 firewall-cmd --query-port=80/tcp # 开启80端口 firewall-cmd --zone=public --add-port=80/tcp --permanent # 重启防火墙 firewall-cmd --reload 用浏览器访问 访问：http://192.168.172.136 ","date":"2025-10-12T20:46:14+08:00","permalink":"https://YLine-hub.github.io/p/centos7.6nginx%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/","title":"[CentOS7.6]nginx安装配置"},{"content":"环境 环境：\nVMware 虚拟机 CentOS7.6 目标：\nMySQL 5.7 准备资源 MySQL下载地址： MySQL Community Server\n查找所需mysql版本，我需要下载的是mysql5.7 这里我准备下载的是第一个tar.gz包，右键上图中的红框部分，复制下载链接，也可以直接下载下来上传到Linux服务器 复制的链接：\n1 https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.44-linux-glibc2.12-x86_64.tar.gz 安装 创建mysql所属组、用户 即使mysql服务被黑掉，得到了mysql用户权限，也不会影响整个系统的安全 1 2 3 4 # 创建新组mysql groupadd mysql # 创建用户mysql，指定属组为mysql，禁止其登陆 useradd -r -g mysql mysql -s /sbin/nologin 下载mysql安装、解压，并放到/usr/local目录下 进入/opt目录下 1 cd /opt 下载mysql的tar.gz包 1 wget https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.44-linux-glibc2.12-x86_64.tar.gz 解压下载好的压缩包 1 tar -zxvf mysql-5.7.44-linux-glibc2.12-x86_64.tar.gz 解压完成后将其移动到/usr/local目录下并改文件夹名为mysql（规范） 1 mv mysql-5.7.44-linux-glibc2.12-x86_64 /usr/local/mysql 配置mysql 创建所需目录 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 创建存储数据目录 mkdir /usr/local/mysql/data # 创建数据日志目录 mkdir /usr/local/mysql/log # 创建临时文件目录 mkdir /usr/local/mysql/tmp # 创建运行文件目录 mkdir /usr/local/mysql/run # 创建启动错误日志 touch /usr/local/mysql/log/mysqld_safe_error.log # 创建默认的错误日志目的地 touch /usr/local/mysql/log/alert.log # 创建慢查询日志文件 touch /usr/local/mysql/log/slow.log # 创建通用查询日志文件 touch /usr/local/mysql/log/general.log 编辑配置文件 1 vim /etc/my.cnf 使用:1,$d清空文件内容 my.cnf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 # mysqld_safe脚本启动时读取的配置 [mysqld_safe] # 存放MySQL后台程序pid的文件位置 pid-file=/usr/local/mysql/run/mysqld.pid # 启动错误日志 log-error=/usr/local/mysql/log/mysqld_safe_error.log # 本地mysql客户端程序的配置 [mysql] # 本地mysql客户端连接的端口 port=3306 # 本地mysql客户端命令提示信息 prompt=\\\\u@\\\\d \\\\r:\\\\m:\\\\s\u0026gt; # 本地mysql客户端字符集 default-character-set=utf8mb4 # 开启命令补全 no-auto-rehash # 所有mysql客户端程序读取的配置块 [client] # 连接端口 port=3306 # mysql的主机和客户机在同一host上的时候，使用unix domain socket作为通讯协议的载体文件 socket=/usr/local/mysql/run/mysql.sock # mysql服务端程序mysqld、mysqld_safe和mysqld_multi的配置文件 [mysqld] # 进程崩溃时生成core file dump文件，便于程序调试和问题排查 core-file # 该参数指定了安装mysql的安装路径（mysql安装目录），填写全路径可以解决相对路径所造成的问题。 basedir=/usr/local/mysql # 启动bin_log log-bin=mysql-bin server-id=1 binlog_format=ROW # 该参数指定了mysql的数据文件的存放目录，数据库文件即我们常说的mysql data文件。 datadir=/usr/local/mysql/data # 临时目录 tmpdir=/usr/local/mysql/tmp # 用于错误消息的区域设置。默认值时en_US。服务器将参数转换为语言名，并将其与lc_messages_dir的值结合，以生成错误消息文件的位置。 lc_messages=en_US # 错误消息所在目录。服务器使用该值和lc_messages的值来生成错误消息文件的位置。 lc_messages_dir=/usr/local/mysql/share # 默认的错误日志目的地。如果目标是控制台，则值为stderr。否则，目标是一个文件，log_error值时文件名。 log-error=/usr/local/mysql/log/alert.log # 慢查询日志文件名。默认值是host_name-slow.log，但可以通过slow_query_log_file选项更改初始值。 slow_query_log_file=/usr/local/mysql/log/slow.log # 通用查询日志文件的名称。默认值是host_name.log，但初始值可以通过general_log_file选项更改。 general_log_file=/usr/local/mysql/log/general.log # mysql的主机和客户机在同一host上的时候，使用unix domain socket作为通讯协议的载体文件 socket=/usr/local/mysql/run/mysql.sock # 服务端字符集 character-set-server=utf8mb4 # 此变量控制写入错误日志的消息中的时间戳的时区，以及写入文件的一般查询日志和慢查询日志消息中的时间戳的时区。 log_timestamps=SYSTEM # 操作系统中可用于mysqld的文件描述符的数量 open_files_limit=61535 # 同时允许的最大客户连接数 max_connections=1000 # mysql_stmt_send_long_data() C API函数发送的一个包或任何生成/中间字符串的最大大小，或任何参数的最大大小。默认是64MB。 max_allowed_packet=1G # 如果设置为0，表名将按指定的方式存储，并且比较区分大小写。如果设置为1，表名将以小写形式存储在磁盘上，比较不区分大小写。如果设置为2，则表名按给定值存储，但以小写进行比较。此选项也适用于数据库名称和表别名。 lower_case_table_names=1 # 慢查询日志是否开启。取值为0（或OFF）表示关闭日志，取值为1（或ON）表示打开日志。默认值取决于是否给出--slow_query_log选项。日志输出的目标由log_output系统变量控制；如果该值为NONE，则即使启用了日志，也不会写入任何日志项。 slow_query_log=1 # validate_password插件的加载方法 plugin-load-add=validate_password.so # validate-password在服务器启动时使用该选项来控制插件的激活 validate-password=FORCE_PLUS_PERMANENT 初始化数据库 设置环境变量 1 2 3 4 5 6 # 将mysql/bin路径添加到配置文件（根据自己的路径修改） # 记住必须要用 \u0026gt;\u0026gt; 而不是 \u0026gt; # 如果当心文件被覆盖可以打开/etc/profile文件，将下面这句写到文件最后面 echo \u0026#34;export PATH=$PATH:/usr/local/mysql/bin\u0026#34; \u0026gt;\u0026gt; /etc/profile # 生效配置文件 source /etc/profile 将安装目录的所有权授予用户、属组 mysql:mysql 1 chown -R mysql:mysql /usr/local/mysql 初始化数据库 1 mysqld --initialize --user=mysql --basedir=/usr/local/mysql/ --datadir=/usr/local/mysql/data/ 查询mysql初始密码 1 grep -e \u0026#39;temporary\u0026#39; /usr/local/mysql/log/alert.log 可以看到初始密码：kv?kghe.C5:x\n再次将安装目录的所有全授予用户、属组 mysql:mysql 1 chown -R mysql:mysql /usr/local/mysql 将安装目录的 rwx 授予其所属用户mysql 1 chmod -R 755 /usr/local/mysql 复制启动文件到/etc/init.d目录下 1 cp -ar /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld 启动mysql服务 \u0026amp;\u0026amp; 设置开机自启动 启动mysql服务 1 /etc/init.d/mysqld start 其他命令:\n1 2 3 /etc/init.d/mysqld stop # 停止mysql /etc/init.d/mysqld restart # 重启mysql /etc/init.d/mysqld status # 查看mysql状态 设置开机自启动 1 2 3 4 // 添加服务 chkconfig --add mysqld // 显示服务列表 chkconfig --list 开机自启设置成功\n登陆mysql \u0026amp;\u0026amp; 修改mysql密码 1 mysql -uroot -p 输入密码（在这里输入密码是看不到的） 降低密码验证等级 1 2 3 4 # 设置密码验证安全级别 set global validate_password_policy=LOW; # 设置密码验证最小长度 set global validate_password_length=6; 修改登陆密码（修改为123456） 1 set password for root@localhost = password(\u0026#39;123456\u0026#39;); 查看密码验证规则 1 SHOW VARIABLES LIKE \u0026#39;validate_password%\u0026#39;; 开放远程登陆 \u0026amp;\u0026amp; 放行3306端口 开放远程登陆 1 2 3 4 5 6 # 登录进来之后，切换到mysql库 use mysql; # 修改用户权限 update user set user.Host=\u0026#39;%\u0026#39; where user.User=\u0026#39;root\u0026#39;; # 刷新权限 flush privileges; 退出mysql 1 2 3 exit; # 或者 ctrl+d 放行3306端口 1 2 3 4 5 6 # 检查3306端口是否放行 firewall-cmd --query-port=3306/tcp # 打开3306端口 firewall-cmd --zone=public --add-port=3306/tcp --permanent # 重新加载防火墙 firewall-cmd --reload 测试连接 Navicat破解：Navicat Cracker ","date":"2025-10-12T17:33:04+08:00","permalink":"https://YLine-hub.github.io/p/centos7.6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmysql5.7%E4%BC%98%E5%8C%96/","title":"【CentOS7.6】安装配置mysql5.7(优化)"},{"content":"二进制包/源码安装方式的mysql卸载 检查mysql服务并关闭进程 查看mysql进程 1 ps -ef | grep mysql 查看mysql状态 1 /etc/init.d/mysqld status 关闭mysql 1 /etc/init.d/mysqld stop 再次查看mysql的状态和有关mysql的进程 1 2 /etc/init.d/mysqld status ps -ef | grep mysql 关闭mysql用户的进程 其实上图是，我用roo su mysql后进入mysql用户的命令行，之后又su root用mysql打开root账号，所以只需要exit两边即可\n1 2 3 4 $ exit exit $ exit exit 再次查看进程 1 ps -ef | grep mysql 查找mysql的安装目录并彻底删除 查找mysql有关的目录 1 2 whereis mysql find / -name mysql 全部删除 1 2 3 4 rm -rf /usr/lib64/mysql/ rm -rf /usr/local/mysql/ rm -rf /run/sudo/ts/mysql rm -rf /etc/selinux/targeted/active/modules/100/mysql 删除一些配置文件 /etc/my.cnf /etc/init.d/mysqld 1 2 rm -rf /etc/my.cnf rm -rf /etc/init.d/mysqld 删除mysql用户以及用户组 1 2 userdel -r mysql groupdel mysql 查询mysql是否还存在 1 id mysql ","date":"2025-10-12T15:43:16+08:00","permalink":"https://YLine-hub.github.io/p/centos7.6%E5%BD%BB%E5%BA%95%E5%8D%B8%E8%BD%BDmysqltar.gz/","title":"【CentOS7.6】彻底卸载mysql(tar.gz)"},{"content":"MySQL安装配置 环境 环境：\nVMware 虚拟机 CentOS7.6 目标：\nMySQL 5.7 准备资源 MySQL下载地址： MySQL Community Server\n查找所需mysql版本，我需要下载的是mysql5.7 这里我准备下载的是第一个tar.gz包，右键上图中的红框部分，复制下载链接，也可以直接下载下来上传到Linux服务器 复制的链接：\n1 https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.44-linux-glibc2.12-x86_64.tar.gz 安装 安装前检测 检查服务器是否安装过mysql，以及是否有自带的mariadb 1 2 rpm -qa | grep mysql rpm -qa | grep mariadb mariadb 其实就是 mysql，只不过是 mysql 的另一种拉出来的开源分支，也可以正常使用，如果不想卸载也是可以的。\n卸载相应的服务（若没有则跳过该阶段） 卸载mysql 1 2 3 4 5 6 7 8 9 10 11 # 卸载mysql yum -y remove MySQL* # 查找mysql目录并统一删除 find / -name mysql # 删除mysql配置文件 rm -rf /etc/my.cnf # 删除mysql默认密码（若不删除，以后安装mysql后这个sercret中的默认密码不会变，使用其中的默认密码就可能会报类似Access denied for user \u0026#39;root@localhost\u0026#39; (using password:yes)的错误。） rm -rf /root/.mysql_sercret 卸载mariadb 1 rpm -e --nodeps mariadb-libs-5.5.68-1.el7.x86_64 查看my.cnf和.mysql_sercret是否存在，有的话需要删除 1 2 cat /etc/my.cnf cat /root/.mysql_sercret 将mysql5.7的tar.gz包下载到/opt目录下 1 2 cd /opt wget https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.44-linux-glibc2.12-x86_64.tar.gz 等待下载完成 解压下载好的压缩包 1 tar -zxvf mysql-5.7.44-linux-glibc2.12-x86_64.tar.gz 解压完成后将其移动到/usr/local下并改文件名为mysql（规范） 1 mv mysql-5.7.44-linux-glibc2.12-x86_64 /usr/local/mysql 检查是否创建了mysql组和用户，没有的话需要创建 1 2 3 4 # mysql组 cat /ect/group | grep mysql # mysql用户 cat /etc/passwd | grep mysql 创建一个mysql组和用户 1 2 groupadd mysql useradd -r -g mysql mysql # -r 指的是创建一个系统账户 创建完检查 1 2 cat /etc/group | grep mysql cat /etc/passwd | grep mysql 更改mysql目录下所有文件夹所属的用户组、用户以及文件权限 切换到/usr/local目录下 1 cd /usr/local 更改mysql目录及其所有子目录和文件的用户组和用户为mysql 1 chown -R mysql:mysql mysql 给mysql目录下所有文件加执行权限 1 chmod -R 775 mysql 修改完可以使用ll查看一下 设置环境变量 1 2 3 4 5 6 # 将mysql/bin路径添加到配置文件（根据自己的路径修改） # 记住必须要用 \u0026gt;\u0026gt; 而不是 \u0026gt; # 如果当心文件被覆盖可以打开/etc/profile文件，将下面这句写到文件最后面 echo \u0026#34;export PATH=$PATH:/usr/local/mysql/bin\u0026#34; \u0026gt;\u0026gt; /etc/profile # 生效配置文件 source /etc/profile 检查是否生效 1 mysql --version 生成mysql临时密码 1 2 # 执行命令。生成临时数据库密码（还是注意路径看看是不是和你的一样） mysqld --user=mysql --initialize --datadir=/usr/local/mysql/data 生成的临时密码是： u\u0026lt;kW;59g?Ut% 千万要把临时密码记住，到后面修改完密码之后，就可以不用了；\n复制启动文件到/etc/init.d/目录 把启动脚本mysql.server放到目录/etc/init.d/，同时改名为mysqld。 1 cp -ar /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld 1 2 # 编辑文件 vim /etc/init.d/mysqld 检查以下这几个路径是否正确 创建所需目录 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 创建存储数据目录 mkdir /usr/local/mysql/data # 创建数据日志目录 mkdir /usr/local/mysql/log # 创建临时文件目录 mkdir /usr/local/mysql/tmp # 创建运行文件目录 mkdir /usr/local/mysql/run # 创建启动错误日志 touch /usr/local/mysql/log/mysqld_safe_error.log # 创建默认的错误日志目的地 touch /usr/local/mysql/log/alert.log # 创建慢查询日志文件 touch /usr/local/mysql/log/slow.log # 创建通用查询日志文件 touch /usr/local/mysql/log/general.log 添加my.cnf配置文件 切换到/etc/目录下 1 cd /etc/ 创建一个mysql的配置文件my.cnf 1 touch my.cnf MySQL5.7的my.cnf详细说明可以参考官方解释：\nUsing Option Files Using Options to Set Program Variables centos7 mysql5.7开启binlog：centos7 mysql5.7开启binlog\nmy.cnf配置示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 # mysqld_safe脚本启动时读取的配置 [mysqld_safe] # 存放MySQL后台程序pid的文件位置 pid-file=/usr/local/mysql/run/mysqld.pid # 启动错误日志 log-error=/usr/local/mysql/log/mysqld_safe_error.log # 本地mysql客户端程序的配置 [mysql] # 本地mysql客户端连接的端口 port=3306 # 本地mysql客户端命令提示信息 prompt=\\\\u@\\\\d \\\\r:\\\\m:\\\\s\u0026gt; # 本地mysql客户端字符集 default-character-set=utf8mb4 # 开启命令补全 no-auto-rehash # 所有mysql客户端程序读取的配置块 [client] # 连接端口 port=3306 # mysql的主机和客户机在同一host上的时候，使用unix domain socket作为通讯协议的载体文件 socket=/usr/local/mysql/run/mysql.sock # mysql服务端程序mysqld、mysqld_safe和mysqld_multi的配置文件 [mysqld] # 进程崩溃时生成core file dump文件，便于程序调试和问题排查 core-file # 该参数指定了安装mysql的安装路径（mysql安装目录），填写全路径可以解决相对路径所造成的问题。 basedir=/usr/local/mysql # 启动bin_log log-bin=mysql-bin server-id=1 binlog_format=ROW # 该参数指定了mysql的数据文件的存放目录，数据库文件即我们常说的mysql data文件。 datadir=/usr/local/mysql/data # 临时目录 tmpdir=/usr/local/mysql/tmp # 用于错误消息的区域设置。默认值时en_US。服务器将参数转换为语言名，并将其与lc_messages_dir的值结合，以生成错误消息文件的位置。 lc_messages=en_US # 错误消息所在目录。服务器使用该值和lc_messages的值来生成错误消息文件的位置。 lc_messages_dir=/usr/local/mysql/share # 默认的错误日志目的地。如果目标是控制台，则值为stderr。否则，目标是一个文件，log_error值时文件名。 log-error=/usr/local/mysql/log/alert.log # 慢查询日志文件名。默认值是host_name-slow.log，但可以通过slow_query_log_file选项更改初始值。 slow_query_log_file=/usr/local/mysql/log/slow.log # 通用查询日志文件的名称。默认值是host_name.log，但初始值可以通过general_log_file选项更改。 general_log_file=/usr/local/mysql/log/general.log # mysql的主机和客户机在同一host上的时候，使用unix domain socket作为通讯协议的载体文件 socket=/usr/local/mysql/run/mysql.sock # 服务端字符集 character-set-server=utf8mb4 # 此变量控制写入错误日志的消息中的时间戳的时区，以及写入文件的一般查询日志和慢查询日志消息中的时间戳的时区。 log_timestamps=SYSTEM # 操作系统中可用于mysqld的文件描述符的数量 open_files_limit=61535 # 同时允许的最大客户连接数 max_connections=1000 # mysql_stmt_send_long_data() C API函数发送的一个包或任何生成/中间字符串的最大大小，或任何参数的最大大小。默认是64MB。 max_allowed_packet=1G # 如果设置为0，表名将按指定的方式存储，并且比较区分大小写。如果设置为1，表名将以小写形式存储在磁盘上，比较不区分大小写。如果设置为2，则表名按给定值存储，但以小写进行比较。此选项也适用于数据库名称和表别名。 lower_case_table_names=1 # 慢查询日志是否开启。取值为0（或OFF）表示关闭日志，取值为1（或ON）表示打开日志。默认值取决于是否给出--slow_query_log选项。日志输出的目标由log_output系统变量控制；如果该值为NONE，则即使启用了日志，也不会写入任何日志项。 slow_query_log=1 # validate_password插件的加载方法 plugin-load-add=validate_password.so # validate-password在服务器启动时使用该选项来控制插件的激活 validate-password=FORCE_PLUS_PERMANENT 给mysql的配置文件添加执行权限 1 chmod -R 775 /etc/my.cnf 启动mysql服务 \u0026amp;\u0026amp; 设置开机自启 启动前先查询是否启动过 1 2 ps -ef|grep -v grep |grep mysql ps -ef|grep -v grep |grep mysqld 启动mysql服务 1 /etc/init.d/mysqld start 启动失败 1 Starting MySQL.. ERROR! The server quit without updating PID file (/usr/local/mysql/data/localhost.yline.pid). 替换配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 [client] default-character-set = utf8mb4 [mysql] default-character-set = utf8mb4 [mysqld] port = 3306 basedir = /usr/local/mysql datadir = /usr/local/mysql/data socket = /usr/local/mysql/run/mysql.sock symbolic-links = 0 log-error = /usr/local/mysql/log/alert.log pid-file = /usr/local/mysql/run/mysqld.pid # 禁用主机名解析 skip-name-resolve # 默认的数据库引擎 default-storage-engine = InnoDB innodb-file-per-table = 1 innodb_force_recovery = 1 group_concat_max_len = 10240 sql_mode = NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES expire_logs_days = 7 memlock # 字符集配置 character-set-client-handshake = FALSE character-set-server = utf8mb4 collation-server = utf8mb4_unicode_ci init_connect = \u0026#39;SET NAMES utf8mb4\u0026#39; # GTID 配置 server_id = 330759 binlog_format = row gtid_mode = on enforce-gtid-consistency = true log_bin = mysql57-bin log-slave-updates = on skip_slave_start = 1 # 慢查询日志 slow_query_log = 1 long_query_time = 2 log_queries_not_using_indexes = 0 slow_query_log_file = /usr/local/mysql/log/slow.log # 自动修复 relay_log_info_repository = TABLE master_info_repository = TABLE relay_log_recovery = on relay_log_purge = 1 # 数据安全性配置 log_bin_trust_function_creators = on sync_binlog = 1 explicit_defaults_for_timestamp = true # 优化配置 ft_min_word_len = 1 lower_case_table_names = 1 max_allowed_packet = 256M query_cache_size = 64M query_cache_limit = 1M join_buffer_size = 16M thread_cache_size = 64 # InnoDB 优化 innodb_buffer_pool_size = 2G innodb_log_file_size = 256M innodb_log_buffer_size = 4M innodb_flush_log_at_trx_commit = 1 innodb_log_files_in_group = 3 innodb_file_per_table = 1 innodb_write_io_threads = 8 innodb_read_io_threads = 8 innodb_purge_threads = 1 innodb_max_dirty_pages_pct = 90 innodb_lock_wait_timeout = 120 innodb_strict_mode = 1 innodb_large_prefix = on [mysqldump] quick default-character-set = utf8mb4 max_allowed_packet = 256M 还是如下报错： 1 Starting MySQL.. ERROR! The server quit without updating PID file (/usr/local/mysql/data/mysqld.pid). 找到原因：一般是root用户执行导致，如果是root以外的用户执行不会报错\n解决方法：修改/usr/local/mysql/support-files/mysql.server和/etc/init.d/mysqld文件\n编辑/usr/local/mysql/support-files/mysql.server和/etc/init.d/mysqld文件 1 2 3 4 5 # 编辑/usr/local/mysql/support-files/mysql.server vim /usr/local/mysql/support-files/mysql.server # 编辑/etc/init.d/mysqld vim /etc/init.d/mysqld 使用/+关键字找到$bindir/mysqld_safe 在后面添加 --user=root 按esc，然后用:wq保存文件 重新启动 1 /etc/init.d/mysqld start 启动成功\n设置开机自启 1 2 3 4 // 添加服务 chkconfig --add mysqld // 显示服务列表 chkconfig --list 开机自启设置成功\n登陆mysql \u0026amp;\u0026amp; 修改mysql密码 1 mysql -uroot -p 输入密码（在这里输入密码是看不到的） 出现报错 1 ERROR 2002 (HY000): Can\u0026#39;t connect to local MySQL server through socket \u0026#39;/tmp/mysql.sock\u0026#39; (2) 解决方法：在/tmp下做一个mysql.sock的软链接 1 ln -s /usr/local/mysql/run/mysql.sock /tmp/mysql.sock 重新登陆 1 mysql -uroot -p 登陆进来后修改密码（修改为123456） 1 set password for root@localhost = password(\u0026#39;123456\u0026#39;); 修改成功\n按ctrl+d退出重新试一下 再次登陆 1 mysql -uroot -p123456 开放远程登陆 \u0026amp;\u0026amp; 测试本地客户端连接 开放远程登陆 1 2 3 4 5 6 #登录进来之后，切换到mysql库 use mysql; #修改用户权限 update user set user.Host=\u0026#39;%\u0026#39; where user.User=\u0026#39;root\u0026#39;; #刷新权限 flush privileges; 防火墙放行3306端口 1 2 3 4 5 6 # 检查3306端口是否放行 firewall-cmd --query-port=3306/tcp # 打开3306端口 firewall-cmd --zone=public --add-port=3306/tcp --permanent # 重新加载防火墙 firewall-cmd --reload 连接测试 准备工具：Navicat Cracker 或者 navicat-keygen-16 ","date":"2025-10-11T18:34:30+08:00","permalink":"https://YLine-hub.github.io/p/centos7.6mysql%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/","title":"【CentOS7.6】MySQL安装配置"},{"content":"jdk8安装配置 环境：\nCentOS7.6 64位系统 查询系统位数\n64位系统：x686或x86_64 32位系统：i686或i386 1 uname -m 可以看到我的系统是64位的\n方法一（推荐） 手动下载安装包 Java SE 8 - Oracle 通过MobaXterm上传到/opt目录下 MobaXterm选中内容将会自动复制 注意：上传文件的路径建议用英文。如果用中文的话可能会导致文件无法上传。\n解压安装包 1 2 cd /opt tar -zxvf jdk-8u202-linux-x64.tar.gz 将解压的文件夹移动到/usr/local下并改为java 解压完成后，当前目录会有一个jdk1.8.0_202的文件夹。将文件夹移动到/usr/local/java下（一般安装的软件都会放到/usr/local/目录下）。 1 2 # 将文件移动到/usr/local目录下，并将文件名改为java mv jdk1.8.0_202/ /usr/local/java 设置环境变量 编辑profile文件 1 vim /etc/profile 配置环境变量 1 2 3 export JAVA_HOME=/usr/local/java export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=$PATH:$JAVA_HOME/bin 使环境变量生效 1 source /etc/profile 验证是否完成安装 1 java -version 方法二 查询系统是否有jdk 1 2 3 java -version rpm -qa | grep java 批量卸载系统自带 1 2 3 rpm -qa | grep java | xargs rpm -e --nodeps # 或者 rpm -e --nodeps java* 检查yum中是否有java安装包 1 yum list java* 找到自己需要的jdk8 使用yum安装jdk8 1 yum install -y java-1.8.0-openjdk 验证 1 java -version ","date":"2025-10-10T15:27:53+08:00","permalink":"https://YLine-hub.github.io/p/centos7.6jdk8%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/","title":"【CentOS7.6】jdk8安装配置"},{"content":"Shell文件包含 介绍 和其他语言一样，Shell 也可以包含外部脚本。 可以很方便的封装一些公用的代码作为一个独立的文件。 基本语法 1 2 3 4 5 . filename # 注意点号(.)和文件名中间有一空格 或 source filename 示例 创建脚本1：include1.sh 1 2 3 #!/bin/bash url=\u0026#34;www.baidu.com\u0026#34; 创建脚本2：include2.sh 1 2 3 4 5 6 7 8 9 #!/bin/bash # 使用.号来引用include1.sh文件 . ./include1.sh # 或者使用以下包含文件代码 # source ./include1.sh echo \u0026#34;百度地址：$url\u0026#34; 为include2.sh添加执行权限并执行 1 2 chmod +x include2.sh ./include2.sh 注：被包含的文件 test1.sh 不需要可执行权限。\n","date":"2025-10-10T15:06:21+08:00","permalink":"https://YLine-hub.github.io/p/shell%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/","title":"Shell文件包含"},{"content":"Shell 输入/输出重定向 重定向命令列表\n命令 说明 command \u0026gt; file 将输出重定向到file command \u0026lt; file 将输入重定向到file command \u0026raquo; file 将输出以追加的方式重定向到file n \u0026gt; file 将文件描述符为n的文件重定向到file n \u0026raquo; file 将文件描述符为n的文件以追加的方式重定向到file n \u0026gt;\u0026amp; m 将输出文件m和n合并 n \u0026lt;\u0026amp; m 将输入文件m和n合并 \u0026laquo; tag 将开始标记tag和结束标记tag之间的内容作为输入 需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。\nShell输出重定向 基本语法 1 command1 \u0026gt; file1 示例 将命令的完整的输出重定向在用户文件中(users)，没有users文件会自动创建 1 who \u0026gt; users 查看文件内容 1 cat users 输出重定向会覆盖文件内容 1 echo \u0026#34;www.baidu.com\u0026#34; \u0026gt; users 如果不希望文件内容被覆盖，可以使用\u0026raquo;追加到文件末尾 1 echo \u0026#34;www.google.com\u0026#34; \u0026gt;\u0026gt; users Shell输入重定向 基本语法 1 command1 \u0026lt; file1 示例 统计users文件的行数 1 wc -l users 也可也将输入重定向到users文件 1 wc -l \u0026lt; users 注意：上述两个例子结果不同：第一个例子会输出文件名，第二个不会，因为他仅仅知道从标准输入读取内容。\n同时替换输入和输出，执行命令command1，从文件infile读取内容，然后将输出写入到outfile 1 command1 \u0026lt; infile \u0026gt; outfile 统计users文件的行数，并输出到linefile文件内 重定向深入讲解 一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：\n标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。 基本语法 如果希望stderr重定向到file 1 command 2\u0026gt;file 如果希望 stderr 追加到 file 文件末尾 1 command 2\u0026gt;\u0026gt;file 2 表示标准错误文件(stderr)。\n如果希望将 stdout 和 stderr 合并后重定向到 file 1 2 3 4 5 command \u0026gt; file 2\u0026gt;\u0026amp;1 # 或者 command \u0026gt;\u0026gt; file 2\u0026gt;\u0026amp;1 如果希望对 stdin 和 stdout 都重定向 1 command \u0026lt; file1 \u0026gt;file2 Here Document 介绍 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。 基本语法 将两个 delimiter 之间的内容(document) 作为输入传递给 command。 1 2 3 command \u0026lt;\u0026lt; delimiter document delimiter 注意：\n结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。 开始的delimiter前后的空格会被忽略掉。 示例 在命令行中通过wc -l命令计算Here Document的行数 1 2 3 4 5 $ wc -l \u0026lt;\u0026lt; EOF \u0026gt; www.baidu.com \u0026gt; www.google.com \u0026gt; EOF 2 # 输出结果为2行 也可也将Here Document用在脚本中 1 2 3 4 5 6 #!/bin/bash cat \u0026lt;\u0026lt; EOF www.baidu.com www.google.com EOF /dev/null 文件 介绍 如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null 1 command \u0026gt; /dev/null /dev/null /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃。 如果尝试从该文件读取内容，那么什么也读不到。 但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到\u0026quot;禁止输出\u0026quot;的效果。 如果希望屏蔽 stdout 和 stderr\n1 command \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 注意：0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。 这里的 2 和 \u0026gt; 之间不可以有空格，2\u0026gt; 是一体的时候才表示错误输出。 ","date":"2025-10-10T14:18:27+08:00","permalink":"https://YLine-hub.github.io/p/shell%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/","title":"Shell输入输出重定向"},{"content":"Shell 函数 介绍 用户定义函数，然后在shell脚本中可以随便调用。 基本语法 1 2 3 4 5 6 [ function ] funname [()] { action; [return int;] } 说明：\n1、可以带function fun()定义，也可也直接fun()定义，不带任何参数 2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。return 后跟数值n(0-255) 示例 第一个函数 1 2 3 4 5 6 7 8 #!/bin/bash demoFun(){ echo \u0026#34;这是我的第一个 shell 函数！\u0026#34; } echo \u0026#34;-----函数开始执行-----\u0026#34; demoFun echo \u0026#34;-----函数执行完毕-----\u0026#34; 输出：\n1 2 3 -----函数开始执行----- 这是我的第一个 shell 函数! -----函数执行完毕----- 定义带有return语句的函数 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/bash funWithReturn(){ echo \u0026#34;这个函数会对输入的两个数进行相加运算...\u0026#34; echo \u0026#34;输入第一个数字：\u0026#34; read aNum echo \u0026#34;输入第二个数字：\u0026#34; read bNum echo \u0026#34;两个数字分别为 $aNum 和 $bNum !\u0026#34; return $(($aNum+$bNum)) } funWithReturn echo \u0026#34;输入的两个数字之和为 $? !\u0026#34; 函数返回值在调用该函数后通过$?来获得\n注意： return 语句只能返回一个介于0到255之间的整数，而两个数字的和可能超过这个范围，要解决这个问题，您可以修改return语句，直接使用echo输出而不是使用return：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/bash funWithReturn(){ echo \u0026#34;这个函数会对输入的两个数进行相加运算...\u0026#34; echo \u0026#34;输入第一个数字：\u0026#34; read aNum echo \u0026#34;输入第二个数字：\u0026#34; read bNum echo \u0026#34;两个数字分别为 $aNum 和 $bNum !\u0026#34; sum=$(($aNum + $bNum)) echo \u0026#34;两个数字之和为 $sum\u0026#34; } funWithReturn 函数参数 介绍 在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数\u0026hellip; 示例 1 2 3 4 5 6 7 8 9 10 11 12 #!/bin/bash funWithParam(){ echo \u0026#34;第一个参数为 $1 !\u0026#34; echo \u0026#34;第二个参数为 $2 !\u0026#34; echo \u0026#34;第十个参数为 $10 !\u0026#34; echo \u0026#34;第十个参数为 ${10} !\u0026#34; echo \u0026#34;第十一个参数为 ${11} !\u0026#34; echo \u0026#34;参数总数有 $# 个!\u0026#34; echo \u0026#34;作为一个字符串输出所有参数 $* !\u0026#34; } funWithParam 1 2 3 4 5 6 7 8 9 34 73 注意： $10 不能获取第十个参数，获取第十个参数需要${10}。当n\u0026gt;=10时，需要使用${n}来获取参数。\n特殊参数： 参数处理 说明 $# 传递到脚本或函数的参数个数 $* 以一个单字符串显示所有向脚本传递的参数 $$ 脚本运行的当前进程ID号 $! 后台运行的最后一个进程的ID号 $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。 $- 显示Shell使用的当前选项，与set命令功能相同 $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 ","date":"2025-10-10T13:02:15+08:00","permalink":"https://YLine-hub.github.io/p/shell%E5%87%BD%E6%95%B0/","title":"Shell函数"},{"content":"echo 介绍 用于在标准输出（通常是终端）显示一行文本或变量的值。 语法格式 1 echo [options] string 基本用法 简单文本输出 1 echo \u0026#34;Hello, World!\u0026#34; 输出：\n1 Hello, World! 输出变量 1 2 name=\u0026#34;Linux User\u0026#34; echo \u0026#34;Welcome, $name\u0026#34; 输出：\n1 Welcome, Linux User! 不带引号的输出（不建议） 1 echo This is a test 输出：\n1 This is a test printf 介绍 用于格式化输出的 Shell 命令，它源自 C 语言的 printf() 函数。 基本语法 1 printf format-string [arguments...] 参数说明：\nformat-string: 包含普通字符和格式说明符的字符串 arguments\u0026hellip;: 与格式说明符对应的变量或值 常用格式说明符：\n%s: 字符串 %d: 十进制整数 %f: 浮点数 %c: 字符 %x: 十六进制数 %o: 八进制数 %b: 二进制数 %e: 科学计数法表示的浮点数 示例 基本使用 1 2 3 4 5 6 7 8 #!/bin/bash # 简单字符串输出 printf \u0026#34;Hello, World!\\n\u0026#34; # 带变量的输出 name=\u0026#34;Alice\u0026#34; printf \u0026#34;Hello, %s\\n\u0026#34; \u0026#34;$name\u0026#34; 输出：\n1 2 Hello, World! Hello, Alice 常用格式说明符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #!/bin/bash # 整数 # decimal adj、十进制的，小数的；n、十进制，小数 # hex n、十六进制 # octal adj、八进制的 prinf \u0026#34;Decimal: %d\\nHex: %x\\nOctal: %o\\n\u0026#34; 255 255 255 # 浮点数 # scientific adj、科学的；细致严谨的 printf \u0026#34;Float: %f\\nScientific: %e\\n\u0026#34; 3.14159 3.14159 # 字符串 printf \u0026#34;Name: %s\\n\u0026#34; \u0026#34;Bob\u0026#34; # 字符 printf \u0026#34;First letter: %c\\n\u0026#34; \u0026#34;A\u0026#34; 输出：\n1 2 3 4 5 6 7 Decimal: 255 Hex: ff Octal: 377 Float: 3.141590 Scientific: 3.141590e+00 Name: Bob First letter: A 格式化控制 1 2 3 4 5 6 7 8 9 10 #!/bin/bash # 字段宽度和对齐 printf \u0026#34;|%10s|\\n|%-10s|\\n\u0026#34; \u0026#34;right\u0026#34; \u0026#34;left\u0026#34; # 数字前导零 printf \u0026#34;Year: %04d\\n\u0026#34; 23 # 浮点数精度 printf \u0026#34;Pi: %.2f\\n\u0026#34; 3.14159 输出：\n1 2 3 4 | right| |left | Year: 0023 Pi: 3.14 多参数处理 1 2 3 #!/bin/bash printf \u0026#34;%-10s %5d %8.2f\\n\u0026#34; \u0026#34;Apple\u0026#34; 5 2.5 \u0026#34;Orange\u0026#34; 3 1.75 输出：\n1 2 Apple 5 2.50 Orange 3 1.75 扩展应用 创建表格输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/bin/bash # 表头 # quantity n、数量 printf \u0026#34;%-15s %10s %10s %10s\\n\u0026#34; \u0026#34;Item\u0026#34; \u0026#34;Quantity\u0026#34; \u0026#34;Price\u0026#34; \u0026#34;Total\u0026#34; # 分割线 printf \u0026#34;%-15s %10s %10s %10s\\n\u0026#34; \u0026#34;---------------\u0026#34; \u0026#34;----------\u0026#34; \u0026#34;----------\u0026#34; \u0026#34;----------\u0026#34; # 数据行 printf \u0026#34;%-15s %10s %10s %10s\\n\u0026#34; \u0026#34;Notebook\u0026#34; 3 2.50 7.50 printf \u0026#34;%-15s %10s %10s %10s\\n\u0026#34; \u0026#34;Pen\u0026#34; 5 1.20 6.00 printf \u0026#34;%-15s %10s %10s %10s\\n\u0026#34; \u0026#34;Eraser\u0026#34; 2 0.50 1.00 # 总计行 printf \u0026#34;%-15s %10s %10s %10.2f\\n\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;Total:\u0026#34; \u0026#34;14.50\u0026#34; 输出：\n1 2 3 4 5 6 Item Quantity Price Total --------------- ---------- ---------- ---------- Notebook 3 2.50 7.50 Pen 5 1.20 6.00 Eraser 2 0.50 1.00 Total: 14.50 进度条实现 1 2 3 4 5 6 7 #!/bin/bash for i in {1..20};do printf \u0026#34;\\rProgress: [%-20s] %d%%\u0026#34; $(printf \u0026#34;%${i}s\u0026#34; | tr \u0026#39; \u0026#39; \u0026#39;#\u0026#39;) $((i*5)) sleep 0.1 done printf \u0026#34;\\n\u0026#34; 颜色输出 1 2 3 4 5 6 7 #!/bin/bash RED=\u0026#39;\\033[0;31m\u0026#39; GREEN=\u0026#39;\\033[0;32m\u0026#39; NC=\u0026#39;\\033[0m\u0026#39; # No color printf \u0026#34;${RED}Error:${NC} Something went wrong\\n\u0026#34; printf \u0026#34;${GREEN}Success:${NC} Operation completed\\n\u0026#34; 格式输出： 1 2 3 4 5 6 #!/bin/bash printf \u0026#34;%-10s %-8s %-4s\\n\u0026#34; 姓名 性别 体重kg printf \u0026#34;%-10s %-8s %-4.2f\\n\u0026#34; 郭靖 男 66.1234 printf \u0026#34;%-10s %-8s %-4.2f\\n\u0026#34; 杨过 男 48.6543 printf \u0026#34;%-10s %-8s %-4.2f\\n\u0026#34; 郭芙 女 47.9876 输出：\n1 2 3 4 姓名 性别 体重kg 郭靖 男 66.12 杨过 男 48.65 郭芙 女 47.99 test 介绍 条件判断工具，用于评估表达式并返回布尔值（真/假），它通常与 if 语句结合使用。 语法格式 1 2 test expression 或 [ expression ] # 注意方括号内必须有空格 文件测试操作 常用文件测试选项 操作符 描述 示例 -e 文件是否存在 [ -e file.txt ] -f 是普通文件 [ -f /path/to/file ] -d 是目录 [ -d /path/to/dir ] -r 可读 [ -r file.txt ] -w 可写 [ -w file.txt ] -x 可执行 [ -x script.sh ] -s 文件大小\u0026gt;0 [ -s logfile ] -L 是符号链接 [ -L symlink ] 示例 1 2 3 4 5 6 7 8 9 10 11 #!/bin/bash file=\u0026#34;/etc/passwd\u0026#34; if [ -e \u0026#34;$file\u0026#34; ];then echo \u0026#34;$file 存在\u0026#34; if [ -r \u0026#34;$file\u0026#34; ];then echo \u0026#34;并且可读\u0026#34; fi else echo \u0026#34;$file 不存在\u0026#34; fi 输出：\n1 2 /etc/passwd 存在 /etc/passwd 可读 字符串比较 操作符 描述 示例 -z string 字符串为空 [ -z \u0026ldquo;$var\u0026rdquo; ] -n string 字符串非空 [ -n \u0026ldquo;$var\u0026rdquo; ] string1 = string2 字符串相等 [ \u0026ldquo;$var1\u0026rdquo; = \u0026ldquo;$var2\u0026rdquo; ] string1 != string2 字符串不等 [ \u0026ldquo;$var1\u0026rdquo; != \u0026ldquo;$var2\u0026rdquo; ] 示例 1 2 3 4 5 6 7 8 9 10 11 12 #!/bin/bash read -p \u0026#34;输入用户名：\u0026#34; username if [ -z \u0026#34;$username\u0026#34; ];then echo \u0026#34;错误：用户名不能为空\u0026#34; exit 1 elif [ \u0026#34;$username\u0026#34; = \u0026#34;root\u0026#34; ];then echo \u0026#34;警告：不建议使用root账号\u0026#34; else echo \u0026#34;欢迎，$username\u0026#34; fi 输出：\n1 2 输入用户名: yline 欢迎, yline 数值比较 操作符 描述 示例 -eq 等于 [ \u0026ldquo;$a\u0026rdquo; -eq \u0026ldquo;$b\u0026rdquo; ] -ne 不等于 [ \u0026ldquo;$a\u0026rdquo; -ne \u0026ldquo;$b\u0026rdquo; ] -gt 大于 [ \u0026ldquo;$a\u0026rdquo; -gt \u0026ldquo;$b\u0026rdquo; ] -ge 大于或等于 [ \u0026ldquo;$a\u0026rdquo; -ge \u0026ldquo;$b\u0026rdquo; ] -lt 小于 [ \u0026ldquo;$a\u0026rdquo; -lt \u0026ldquo;$b\u0026rdquo; ] -le 小于或等于 [ \u0026ldquo;$a\u0026rdquo; -le \u0026ldquo;$b\u0026rdquo; ] 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/bash read -p \u0026#34;输入年龄：\u0026#34; age if [ \u0026#34;$age\u0026#34; -lt 0 ];then echo \u0026#34;年龄不能为负数\u0026#34; elif [ \u0026#34;$age\u0026#34; -lt 18 ];then echo \u0026#34;未成年人\u0026#34; elif [ \u0026#34;$age\u0026#34; -ge 18 ] \u0026amp;\u0026amp; [ \u0026#34;$age\u0026#34; -lt 60 ];then echo \u0026#34;成年人\u0026#34; else echo \u0026#34;老年人\u0026#34; fi 输出：\n1 2 输入年龄: 12 未成年人 逻辑操作符 操作符 描述 示例 ! 逻辑非 [ ! -f \u0026ldquo;$file\u0026rdquo; ] -a 逻辑与 [ \u0026ldquo;$a\u0026rdquo; -eq 1 -a \u0026ldquo;$b\u0026rdquo; -eq 2 ] -o 逻辑或 [ \u0026ldquo;$a\u0026rdquo; -eq 1 -o \u0026ldquo;$b\u0026rdquo; -eq 2 ] **现代推荐写法：**使用\u0026amp;\u0026amp;和 替代-a和-o,更符合POSIX标准 高级用法：[[]] 和 （（）） 双括号[[]]\n支持模式匹配：[[ \u0026ldquo;$var\u0026rdquo; == *.txt ]] 支持正则表达式：[[ \u0026ldquo;$var\u0026rdquo; =~ ^[0-9]+$ ]] 更安全的字符串处理 算术比较(())\n专为数值比较设计：(( a \u0026gt; b )) 支持更复杂的算数表达式 示例\n1 2 3 4 5 6 7 8 9 #!/bin/bash if [[ \u0026#34;$file\u0026#34; == *.log ]];then echo \u0026#34;这是日志文件\u0026#34; fi if (( $count \u0026gt; 10 ));then echo \u0026#34;数量超过10\u0026#34; fi 实际应用示例 检查服务是否运行 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/bash read -p \u0026#34;请输入要查询的服务：\u0026#34; service if [ -z \u0026#34;$service\u0026#34; ];then echo \u0026#34;服务名不能为空\u0026#34; exit 1 elif systemctyl is-active --quiet \u0026#34;$service\u0026#34;; then echo \u0026#34;$service 正在运行\u0026#34; else echo \u0026#34;$service 未运行\u0026#34; # 可以添加启动服务的命令 fi 备份文件检查 1 2 3 4 5 6 7 8 9 10 11 12 #!/bin/bash backup_file=\u0026#34;/backups/data_$(date + %Y%m%d).tar.gz\u0026#34; if [ ! -f \u0026#34;$backup_file\u0026#34; ];then echo \u0026#34;错误：备份文件 $backup_file 不存在\u0026#34; exit 1 elif [ ! -s \u0026#34;$backup_file\u0026#34; ];then echo \u0026#34;警告：备份文件为空\u0026#34; else echo \u0026#34;备份验证成功\u0026#34; fi ","date":"2025-10-09T17:33:47+08:00","permalink":"https://YLine-hub.github.io/p/shell%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/","title":"Shell实用指令"},{"content":"基础元字符 元字符 作用 * 前一个字符匹配0次或任意多次 . 匹配除换行符外的任意一个字符 + 匹配前面的模式一次或多次 ? 匹配前面的模式0次或一次 ^ 匹配首行。例如，^hello会匹配以hello开头的行 $ 匹配行尾。例如，hello$会匹配以hello结尾的行 [] 匹配中括号中指定的任意一个字符，而且只匹配一个字符。例如，[aeiu]匹配任意一个元音字母，[0-9]匹配任意一位数字，[a-z][0-9]匹配由小写字母和一位数字构成的两位字符 [^] 匹配除中括号中字符外的任意一个字符。例如，[^0-9]匹配一位非数字字符，[^a-z]匹配任意一位非小写字母 \\ 转义符，用于取消特殊符号的含义 \\{n\\} 表示其前面的字符恰好出现n次。例如，[0-9]\\{4\\}匹配4位数字，[1][3-8][0-9]\\{9\\}匹配手机号码 \\{n,\\} 表示其前面的字符出现不少于n次。例如，[0-9]\\{2,\\}匹配两位以上的数字 \\{n,m\\} 表示其前面的字符至少出现n次，最多出现m次。例如，[a-z]\\{6,8\\}匹配6至8位的小写字母 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 示例1：使用.匹配任意字符 echo \u0026#34;cat dog pig\u0026#34; | grep \u0026#34;d.g\u0026#34; # 输出：dog # 示例2：使用*匹配零次或多次 echo \u0026#34;color colour\u0026#34; | grep \u0026#34;colou*r\u0026#34; # 输出：color colour # 示例3：使用^和$匹配行的开始和结束 echo -e \u0026#34;start\\nend\\nstart end\u0026#34; | grep \u0026#34;^start\u0026#34; # 输出：start start end # 示例4：使用字符集[] echo \u0026#34;bag big bog bug\u0026#34; | grep \u0026#34;b[aeiou]g\u0026#34; # 输出：bag big bog bug # 示例5：使用否定字符集[^] echo \u0026#34;bag big bog bug\u0026#34; | grep \u0026#34;b[^i]g\u0026#34; # 输出：bag bog bug Shell中使用正则表达式的工具 grep命令 语法格式 1 grep [options] pattern [file...] options: -E:使用扩展正则表达式 -i:忽略大小写 -v:反向匹配，显示不匹配的行 -n:显示匹配行的行号 -r:递归搜索目录 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 示例1：基本搜索 echo -e \u0026#34;apple\\nbanana\\ncherry\u0026#34; | grep \u0026#34;an\u0026#34; # 输出：banana # 示例2：使用-i忽略大小写 echo -e \u0026#34;Apple\\nbanana\\Cherry\u0026#34; | grep -i \u0026#34;a\u0026#34; # 输出：Apple # banana # 示例3：使用-v反向匹配 echo -e \u0026#34;apple\\nbanana\\ncherry\u0026#34; | grep -v \u0026#34;an\u0026#34; # 输出：apple # cheery # 示例4：使用-n显示行号 echo -e \u0026#34;apple\\nbanana\\ncheery\u0026#34; | grep -n \u0026#34;e\u0026#34; # 输出：1:apple # 3:cheery # 示例5：使用-E启用扩展正则表达式 echo -e \u0026#34;color\\ncolour\u0026#34; | grep -E \u0026#34;colou?r\u0026#34; # 输出：color # colour sed命令 语法格式 1 sed [opions] \u0026#39;command\u0026#39; [file...] 常用命令：\ns/pattern/replacement/：替换 /pattern/d：删除 /pattern/p：打印 options:\n-E：使用正则表达式 -i：直接修改文件内容 -n：抑制自动打印模式空间 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 示例1：基本替换 echo \u0026#34;Hello，World\u0026#34; | sed \u0026#39;s/World/Universe/\u0026#39; # 输出：Hello，Universe # 示例2：全局替换 echo \u0026#34;color color\u0026#34; | sed \u0026#39;s/color/colour/g\u0026#39; # 输出：colour colour # 示例3：删除匹配行 echo -e \u0026#34;apple\\nbanana\\ncherry\u0026#34; | sed \u0026#39;/banana/d\u0026#39; # 输出：apple # cherry # 示例4：只打印匹配行 echo -e \u0026#34;apple\\nbanana\\ncherry\u0026#34; | sed -n \u0026#39;/a/p\u0026#39; # 输出：apple # banana # 示例5：使用-E启用扩展正则表达式 echo \u0026#34;123-456-7890\u0026#34; | sed -E \u0026#39;s/([0-9]{3})-([0-9]{3})-([0-9]{4})/(\\1)\\2-\\3/\u0026#39; # 输出：(123)456-7890 # 其中\\1，\\2，\\3分别是第一个、第二个、第三个匹配的内容 awk命令 语法格式 1 awk [options] \u0026#39;pattern {action}\u0026#39; [file...] 常用内置变量： $0：整行内容 $1，$2，\u0026hellip;：第一个字段，第二个字段，以此类推 NF：字段数量 NR：当前处理的行号 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 示例1：打印特定列 echo -e \u0026#34;John 25\\nJane 30\\nBob 35\u0026#34; | awk \u0026#39;{print $1}\u0026#39; # 输出：John # Jane # Bob # 示例2：使用正则表达式匹配 echo -e \u0026#34;apple 5\\nbanana 3\\ncherry 8\u0026#34; | awk \u0026#39;/a/ {print $0}\u0026#39; # 输出：apple 5 # banana 3 # 示例3：计算总和 echo -e \u0026#34;apple 5\\nbanana 3\\ncherry 8\u0026#34; | awk \u0026#39;{sum += $2} END {print \u0026#34;Total:\u0026#34;, sum}\u0026#39; # 输出：Total: 16 # 示例4：自定义字段分隔符 echo \u0026#34;2023-05-15,John,Doe\u0026#34; | awk -F\u0026#39;,\u0026#39; \u0026#39;{print $2}\u0026#39; # 输出：John # 示例5：条件处理 echo -e \u0026#34;John 25\\nJane 30\\nBob 35\u0026#34; | awk \u0026#39;$2 \u0026gt; 28 {print $1 \u0026#34; is over 28\u0026#34;}\u0026#39; # 输出：Jane is over 28 # Bob is over 28 Shell正则表达式示例 正则表达式(Regular Expression) 简称regex\n=~: 进行正则表达式匹配\n匹配手机号 1 2 3 4 5 6 7 8 9 #!/bin/bash read -p \u0026#34;请输入手机号：\u0026#34; phone_number if [[ phone_number =~ ^1[3456789][0-9]\\{9\\} ]];then echo \u0026#34;您输入的手机号 $phone_number 符合要求\u0026#34; else echo \u0026#34;您输入的手机号 $phone_number 不符合要求\u0026#34; fi 手机号正确，但是返回不符合要求 进行调试\n1 2 3 4 # 调试语法 bash -x regex1.sh # 或者 sh -x regex1.sh 原因：这里能看到这个参数并没有变成我们需要的值 修正：在参数phone_number前加上$使值传入 修改如下：\n1 2 3 4 5 6 7 8 9 #!/bin/bash read -p \u0026#34;请输入手机号：\u0026#34; phone_number if [[ $phone_number =~ ^1[3456789][0-9]\\{9\\} ]];then echo \u0026#34;您输入的手机号 $phone_number 符合要求\u0026#34; else echo \u0026#34;您输入的手机号 $phone_number 不符合要求\u0026#34; fi 可以看到还是不符合要求，其中红框内变成了\\{9} 修正：将\\{9\\}替换为{9} 修改如下：\n1 2 3 4 5 6 7 8 9 #!/bin/bash read -p \u0026#34;请输入手机号：\u0026#34; phone_number if [[ $phone_number =~ ^1[3456789][0-9]{9} ]];then echo \u0026#34;您输入的手机号 $phone_number 符合要求\u0026#34; else echo \u0026#34;您输入的手机号 $phone_number 不符合要求\u0026#34; fi 上述代码利用了=~运算符来进行正则表达式匹配，其中^1[3456789][0-9]{9}表示以1为开头，第二位为3/4/5/6/7/8/9重任意一个，后面跟着9位数字的字符串。\n查询目录下的所有.sh文件 1 2 3 4 5 #!/bin/bash for file in ./*.sh; do echo \u0026#34;$file\u0026#34; done 替换字符串中的数字 1 2 3 4 5 6 7 8 9 10 11 #!/bin/bash string=\u0026#34;\u0026#34;abcd1234\u0026#34; echo \u0026#34;替换前：$string\u0026#34; # 将字符串中的所有数字替换为 # new_string=(echo \u0026#34;$string\u0026#34; | sed \u0026#39;s/[0-9]/#/g\u0026#39;) echo \u0026#34;替换后：$new_string\u0026#34; # 修正：使用 $() 而不是 () 1 2 3 4 5 6 7 8 9 10 11 #!/bin/bash string=\u0026#34;\u0026#34;abcd1234\u0026#34; echo \u0026#34;替换前：$string\u0026#34; # 将字符串中的所有数字替换为 # # 修正：使用 $() 而不是 () new_string=$(echo \u0026#34;$string\u0026#34; | sed \u0026#39;s/[0-9]/#/g\u0026#39;) echo \u0026#34;替换后：$new_string\u0026#34; 匹配URL地址 1 2 3 4 5 6 7 8 #!/bin/bash read -p \u0026#34;请输入 URL 地址：\u0026#34; url if [[ $url =~ ^(http|https)://[a-z0-9]+(\\.[a-z0-9]+){1,3}.* ]]; then echo \u0026#34;您输入的 URL 地址 $url 符合要求\u0026#34; else echo \u0026#34;您输入的 URL 地址 $url 不符合要求\u0026#34; fi ^(http|https)://[a-z0-9]+(\\.[a-z0-9]+){1,3}.* (http|https)表示http或https开头 [a-z0-9]+(\\.[a-z0-9]+){1,3}表示后面跟着1到3段类似于.xxx的字符串 .*表示.后面还可以跟着任意字符 其他技巧 grep 查找文件的指定内容的行 1 grep pattern file 查找文件test.txt中包含单词hello的行： 1 grep hello test.txt awk 对文本进行分割、筛选、统计等操作 1 awk \u0026#39;/pattern/ { action }\u0026#39; file 查找文件test.txt中长度大于10的行 1 awk \u0026#39;length \u0026gt; 10\u0026#39; test.txt sed 匹配和替换操作 1 sed \u0026#39;s/pattern/replacement/\u0026#39; file 将文件test.txt中的所有空格替换为下划线 1 sed \u0026#39;s/ /_/g\u0026#39; test.txt ","date":"2025-10-08T21:04:44+08:00","permalink":"https://YLine-hub.github.io/p/shell%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"Shell正则表达式"},{"content":"流程控制 条件判断 判断条件 （1）关系运算符 运算符 说明 -eq 相等 -ne 不相等 -gt 大于 -lt 小于 -ge 大于等于 -le 小于等于 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #!/bin/bash a=10 b=20 if [ $a -eq $b ] then echo \u0026#34;$a -eq $b : a 等于 b\u0026#34; else echo \u0026#34;$a -eq $b : a 不等于 b\u0026#34; fi if [ $a -ne $b ] then echo \u0026#34;$a -ne $b : a 不等于 b\u0026#34; else echo \u0026#34;$a -ne $b : a 等于 b\u0026#34; fi if [ $a -gt $b ] then echo \u0026#34;$a -gt $b : a 大于 b\u0026#34; else echo \u0026#34;$a -gt $b : a 不大于 b\u0026#34; fi if [ $a -lt $b ] then echo \u0026#34;$a -lt $b : a 小于 b\u0026#34; else echo \u0026#34;$a -lt $b : a 不小于 b\u0026#34; fi if [ $a -ge $b ] then echo \u0026#34;$a -ge $b : a 大于或等于 b\u0026#34; else echo \u0026#34;$a -ge $b : a 小于 b\u0026#34; fi if [ $a -le $b ] then echo \u0026#34;$a -le $b : a 小于或等于 b\u0026#34; else echo \u0026#34;$a -le $b : a 大于 b\u0026#34; fi （2）布尔运算符 运算符 说明 ! 非运算，表达式为true则返回false -o 或运算，有一个表达式为true则返回true -a 与运算，两个表达式都为true才返回true 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/bash a=10 b=20 if [ $a != $b ] then echo \u0026#34;$a != $b : a 不等于 b\u0026#34; else echo \u0026#34;$a == $b : a 等于 b\u0026#34; fi if [ $a -lt 100 -a $b -gt 15 ] then echo \u0026#34;$a 小于 100 且 $b 大于 15 : 返回 true\u0026#34; else echo \u0026#34;$a 小于 100 且 $b 大于 15 : 返回 false\u0026#34; fi if [ $a -lt 100 -o $b -gt 100 ] then echo \u0026#34;$a 小于 100 或 $b 大于 100 : 返回 true\u0026#34; else echo \u0026#34;$a 小于 100 或 $b 大于 100 : 返回 false\u0026#34; fi if [ $a -lt 5 -o $b -gt 100 ] then echo \u0026#34;$a 小于 5 或 $b 大于 100 : 返回 true\u0026#34; else echo \u0026#34;$a 小于 5 或 $b 大于 100 : 返回 false\u0026#34; fi （3）逻辑运算符 1 2 \u0026amp;\u0026amp; 逻辑AND || 逻辑OR 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/bin/bash a=10 b=20 if [[ $a -lt 100 \u0026amp;\u0026amp; $b -gt 100 ]] then echo \u0026#34;$a 小于 100 AND $b 大于 100 : 返回 true\u0026#34; else echo \u0026#34;$a 小于 100 AND $b 大于 100 : 返回 false\u0026#34; fi if [[ $a -lt 100 || $b -gt 100 ]] then echo \u0026#34;$a 小于 100 OR $b 大于 100 : 返回 true\u0026#34; else echo \u0026#34;$a 小于 100 OR $b 大于 100 : 返回 false\u0026#34; fi （4）字符串运算符 运算符 说明 = 检测两个字符是否相等，相等返回true != 检测两个字符是否不相等，不相等返回true -z 检测字符串长度是否为0，为0返回true -n 检测字符串长度是否不为0，不为0返回true $ 检测字符串是否不为空，不为空返回true 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #!/bin/bash a=\u0026#34;abc\u0026#34; b=\u0026#34;efg\u0026#34; if [ $a = $b ] then echo \u0026#34;$a = $b : a 等于 b\u0026#34; else echo \u0026#34;$a = $b : a 不等于 b\u0026#34; fi if [ $a != $b ] then echo \u0026#34;$a != $b : a 不等于 b\u0026#34; else echo \u0026#34;$a != $b : a 等于 b\u0026#34; fi if [ -z $a ] then echo \u0026#34;-z $a : 字符串长度为 0\u0026#34; else echo \u0026#34;-z $a : 字符串长度不为 0\u0026#34; fi if [ -n $a ] then echo \u0026#34;-n $a : 字符串长度不为 0\u0026#34; else echo \u0026#34;-n $a : 字符串长度为 0\u0026#34; fi if [ $a ] then echo \u0026#34;$a : 字符串不为空\u0026#34; else echo \u0026#34;$a : 字符串为空\u0026#34; fi if语句 方式一 1 2 3 4 5 6 7 if [ 判断条件 ]; then 代码逻辑 else 代码逻辑 fi # 注意：[]中的内容左右两边要有空格，[]结尾用带有; 方法二 1 2 3 4 5 6 7 if [ 判断条件 ] then 代码逻辑 else 代码逻辑 fi # 注意：跟上面基本一致，少了个分号\u0026#39;;\u0026#39; 多重判断 1 2 3 4 5 6 7 8 9 10 if [ 判断条件 ] then 代码逻辑 elif [ 判断逻辑 ] then 代码逻辑 else 代码逻辑 fi # 注意：就是用elif来拼接，用上面两种写法都可以 示例 示例：传参判断成绩等级 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 0 =\u0026lt; D \u0026lt;= 50 # 50 \u0026lt; C \u0026lt;= 70 # 70 \u0026lt; B \u0026lt;= 90 # 90 \u0026lt; A \u0026lt;= 100 #!/bin/bash if [ $1 -ge 0 -a $1 -lt 50 ] then echo \u0026#34;成绩为：$1，评分为：D\u0026#34; elif [ $1 -gt 50 -a $1 -le 70 ] then echo \u0026#34;成绩为：$1，评分为：C\u0026#34; elif [ $1 -gt 70 -a $1 -le 90 ] then echo \u0026#34;成绩为：$1，评分为：B\u0026#34; elif [ $1 -gt 90 -a $1 -le 100 ] then echo \u0026#34;成绩为：$1，评分为：A\u0026#34; else echo \u0026#34;成绩不合法\u0026#34; fi 报错： 原因：变量的值为空值，这个空值没有范围\n解决办法，加一个前提条件，输入非数字就直接退出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 0 =\u0026lt; D \u0026lt;= 50 # 50 \u0026lt; C \u0026lt;= 70 # 70 \u0026lt; B \u0026lt;= 90 # 90 \u0026lt; A \u0026lt;= 100 #!/bin/bash if [[ ! $1 =~ ^[0-9]+$ ]] then echo \u0026#34;输入非数字，退出\u0026#34; exit elif [ $1 -ge 0 -a $1 -lt 50 ] then echo \u0026#34;成绩为：$1，评分为：D\u0026#34; elif [ $1 -gt 50 -a $1 -le 70 ] then echo \u0026#34;成绩为：$1，评分为：C\u0026#34; elif [ $1 -gt 70 -a $1 -le 90 ] then echo \u0026#34;成绩为：$1，评分为：B\u0026#34; elif [ $1 -gt 90 -a $1 -le 100 ] then echo \u0026#34;成绩为：$1，评分为：A\u0026#34; else echo \u0026#34;成绩不合法\u0026#34; fi 分支控制 语法格式 1 2 3 4 5 6 7 8 9 10 11 12 case 变量 in \u0026#34;变量值1\u0026#34;) 逻辑代码1 ;; \u0026#34;变量值2\u0026#34;) 逻辑代码2 ;; ... *) 默认逻辑 ;; esac 示例 示例：根据传参判断星期 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/bash echo -e \u0026#34;今天是星期几？\\n\u0026#34; case $1 in 1) echo \u0026#34;月曜日\u0026#34; ;; 2) echo \u0026#34;火曜日\u0026#34; ;; 3) echo \u0026#34;水曜日\u0026#34; ;; 4) echo \u0026#34;木曜日\u0026#34; ;; 5) echo \u0026#34;金曜日\u0026#34; ;; 6) echo \u0026#34;土曜日\u0026#34; ;; 7) echo \u0026#34;日曜日\u0026#34; ;; *) echo \u0026#34;输入错误\u0026#34; ;; esac 循环语句 for循环 方式一 1 2 3 4 5 for 暂时变量 in 变量1 变量2 变量3 ... do 代码逻辑 done # 注意：遍历时将变量1,2,3...分别赋值给暂时变量 方式二 1 2 3 4 5 for ((初始值; 循环控制条件; 变量变化)) do 代码逻辑 done # 注意：跟java语法遍历类似，只是用了两个()进行括起 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #!/bin/bash if [ -z \u0026#34;$1\u0026#34; ] then echo \u0026#34;参数不能为空\u0026#34; exit fi for item in $* do echo \u0026#34;item is $item\u0026#34; done echo \u0026#34;-------------------\u0026#34; for ((i=0; i\u0026lt;$#;i++)) do echo \u0026#34;num is $i\u0026#34; done while循环 语法格式 1 2 3 4 while 条件 do 代码逻辑 done 示例 1 2 3 4 5 #!/bin/bash if [[ ! $1 =~ ^[0-9]+$ ]] then echo \u0026#34;输入非数字，退出\u0026#34; ","date":"2025-10-08T15:39:07+08:00","permalink":"https://YLine-hub.github.io/p/shell%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","title":"Shell流程控制"},{"content":"流程 1️⃣ 先写命令（快速验证核心逻辑） 1 2 # 直接硬编码执行（不要想任何变量） grep \u0026#34;ERROR\u0026#34; /var/log/app.log | awk \u0026#39;{print $3}\u0026#39; \u0026gt; error_codes.txt 2️⃣ 结构化升级（按顺序添加） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 加入变量（路径/参数抽象化） log_dir=\u0026#34;/var/log\u0026#34; output_file=\u0026#34;error_codes_$(date +%F).txt\u0026#34; # 加入循环（处理多个文件） for log_file in \u0026#34;$log_dir\u0026#34;/*.log; do grep \u0026#34;ERROR\u0026#34; \u0026#34;$log_file\u0026#34; done \u0026gt; temp_errors.txt # 加入判断（条件处理） if [[ -s temp_errors.txt ]]; then awk \u0026#39;{print $3}\u0026#39; temp_errors.txt \u0026gt; \u0026#34;$output_file\u0026#34; else echo \u0026#34;未发现错误日志\u0026#34; \u0026gt; \u0026#34;$output_file\u0026#34; fi # 加入函数（复杂操作封装） extract_errors() { grep \u0026#34;ERROR\u0026#34; \u0026#34;$1\u0026#34; | cut -d\u0026#39;:\u0026#39; -f2 } extract_errors \u0026#34;$log_file\u0026#34; \u0026gt;\u0026gt; temp_errors.txt 3️⃣ 防御武装（输入合规+防崩溃） 1 2 3 4 5 6 7 8 9 10 11 12 # 输入合规检查（放在脚本开头） if [[ $# -eq 0 ]]; then echo \u0026#34;用法: $0 [日志目录]\u0026#34; exit 1 elif [[ ! -d \u0026#34;$1\u0026#34; ]]; then echo \u0026#34;错误：目录 $1 不存在\u0026#34; \u0026gt;\u0026amp;2 exit 2 fi # 防崩溃装甲（紧接合规检查后） set -euo pipefail trap \u0026#39;rm -f temp_errors.txt\u0026#39; EXIT 4️⃣ 安全收尾（说明+清理） 1 2 3 4 5 6 7 8 9 10 # 资源清理（通过trap已实现） # 脚本自文档（结尾注释块） : \u0026lt;\u0026lt;\u0026#39;EOF\u0026#39; === 脚本说明 === 功能: 提取应用错误码 输入: 日志目录路径 输出: error_codes_日期.txt 依赖: grep, awk, cut EOF 🛠 万能模板（直接填空使用） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #!/bin/bash # ===== 1.裸写命令区 ===== # [在此处写下你的原始命令] # grep \u0026#34;pattern\u0026#34; /path/file # ===== 2.结构化升级 ===== input_path=${1:-\u0026#34;/default/path\u0026#34;} # 变量 for item in \u0026#34;$input_path\u0026#34;/*; do # 循环 if [[ -f \u0026#34;$item\u0026#34; ]]; then # 判断 process_item \u0026#34;$item\u0026#34; # 函数 fi done process_item() { # [你的处理逻辑] } # ===== 3.防御武装 ===== [ $# -gt 1 ] \u0026amp;\u0026amp; { echo \u0026#34;参数过多\u0026#34;; exit 1; } # 输入合规 set -euo pipefail # 防崩溃 trap \u0026#39;cleanup\u0026#39; EXIT # 清理挂钩 cleanup() { rm -f tmp_*; } # 清理函数 # ===== 4.安全收尾 ===== :\u0026lt;\u0026lt;\u0026#34;NOTE\u0026#34; === 使用须知 === 1. 本脚本用于... 2. 输入要求... 3. 输出文件... NOTE ✅ 每个步骤的检查清单 步骤 必做事项 检查问题 1 核心命令能直接运行成功 去掉变量能否执行？ 2 所有路径参数都变量化 硬编码路径是否已消除？ 重复操作使用循环 同样操作是否出现3次以上？ 复杂逻辑封装为函数 主流程是否超过20行？ 3 检查关键输入是否存在 如果输入不存在会崩溃吗？ 设置set -euo pipefail 命令失败会继续执行吗？ 定义trap清理资源 脚本崩溃会留下垃圾文件吗？ 4 添加基本用法注释 三个月后还能看懂用法吗？ ","date":"2025-10-08T14:46:39+08:00","permalink":"https://YLine-hub.github.io/p/linux%E5%86%99%E8%84%9A%E6%9C%AC%E7%9A%84%E6%B5%81%E7%A8%8B/","title":"Linux写脚本的流程"},{"content":"Shell编程 介绍 Shell 是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序。 Shell入门 使用vim新建文件text.sh 1 vim test.sh 输入脚本解析器和脚本执行内容 1 2 #!/bin/bash echo \u0026#34;Hello World!\u0026#34; 按Esc，并输入:wq进行保存\n运行脚本\n1 ./test.sh -bash: ./test.sh: 权限不够\n添加执行权限 1 chmod u+x test.sh 重新运行脚本 Shell变量 介绍 Shell变量：系统变量 和 用户自定义变量 系统变量：$HOME，$PWD，$SHELL，$USER set指令可查看所有系统变量 自定义变量：变量=值 撤销变量：unset 变量 声明静态变量：readonly 变量（不能unset） 变量定义规则 只包含字母、数字和下划线，不能以数字开头 避免使用 Shell 关键字，如if、then、else、fi、for、while等 使用大写字母表示常量 避免使用特殊符号和空格 变量的使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 赋值 变量=值 # 使用一 $变量 # 使用二（推荐） ${变量} # 赋值一（命令） 变量=`命令` # 赋值二（命令） 变量=$(命令) 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/bin/bash echo \u0026#34;-------------------\u0026#34; A=100 echo \u0026#34;A=${A}\u0026#34; echo \u0026#34;A=$A\u0026#34; echo \u0026#34;-------------------\u0026#34; unset A echo \u0026#34;A=${A}\u0026#34; echo \u0026#34;A=$A\u0026#34; echo \u0026#34;-------------------\u0026#34; NOW=`date` echo \u0026#34;${NOW}\u0026#34; echo \u0026#34;$NOW\u0026#34; echo \u0026#34;-------------------\u0026#34; NOW_TIME=$(date) echo \u0026#34;${NOW_TIME}\u0026#34; echo \u0026#34;$NOW_TIME\u0026#34; 运行脚本 设置环境变量 介绍 linux上所有的环境变量都配置在/etc/profile中 export 变量=值来配置环境变量 配置完毕后，通过source /etc/profile，重新加载配置文件来使用 示例 添加环境变量 1 export LINUX_OWNER=yline 重新加载配置文件（如果没这一步将不会生效） 1 source /etc/profile 输出测试 1 echo \u0026#34;${LINUX_OWNER}\u0026#34; 位置参数变量 介绍 在我们执行shell脚本的时候，可以在后面拼接参数，进行传参，例：./test.sh hello world。\nshell脚本有对应的参数变量来接收这些参数。\n$n （n为数字）\n以空格来切分命令，将上面命令变成[./test.sh, hello, world]，通过$0, $1, $2来获取参数 如果个数达到10位数以上，需要用大括号括住数字${10} $*\n以一个单字符串显示所有向脚本传递的参数。 如\u0026quot;$*\u0026ldquo;用「\u0026quot;」括起来的情况、以\u0026rdquo;$1 $2 … $n\u0026quot;的形式输出所有参数。 获取全部参数，会将传入的参数hello world视为一个整体 $@\n与$*相同，但是使用时加引号，并在引号中返回每个参数。 如\u0026quot;$@\u0026ldquo;用「\u0026quot;」括起来的情况、以\u0026rdquo;$1\u0026quot; \u0026ldquo;$2\u0026rdquo; … \u0026ldquo;$n\u0026rdquo; 的形式输出所有参数。 获取全部参数，与$*不同，会将hello和world区分为个体 $#\n统计传入参数的个数 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/bash echo \u0026#34;---------------\u0026#34; echo \u0026#34;$0,$1,$2\u0026#34; echo \u0026#34;---------------\u0026#34; echo \u0026#34;$*\u0026#34; echo \u0026#34;---------------\u0026#34; echo \u0026#34;$@\u0026#34; echo \u0026#34;---------------\u0026#34; echo \u0026#34;$#\u0026#34; 带参运行test3.sh 预定义变量 介绍 shell本身有定义好的变量提供用户使用。\n$$\n获取当前进行的PID $!\n获取后台运行的最后一个进程的进程号 $?\n最后一次执行的命令的返回状态（0=正常，非0=异常） 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/bash echo \u0026#34;---------------\u0026#34; echo \u0026#34;current_PID = $$\u0026#34; ../test.sh \u0026amp; echo \u0026#34;---------------\u0026#34; echo \u0026#34;last_PID = $!\u0026#34; echo \u0026#34;---------------\u0026#34; echo \u0026#34;status = $?\u0026#34; 运行脚本 1 ./test4.sh 字符串 介绍 shell编程中最常用最有用的数据类型，可以用单引号，也可以用双引号，也可也不用引号。 示例 单引号 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； 单引号字符串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。 1 2 3 4 #!/bin/bash str=\u0026#39;this is a string\u0026#39; echo \u0026#34;$str\u0026#34; 双引号 双引号里可以有变量 双引号里可以出现转义字符 echo -e 关键词 其中 -e 表示启用转义字符 1 2 3 4 5 #!/bin/bash your_name=\u0026#34;yline\u0026#34; str=\u0026#34;Hello,I know you are \\\u0026#34;$your_name\\\u0026#34;!\\n\u0026#34; echo -e $str 拼接字符串 1 2 3 4 5 6 7 8 9 10 11 12 #!/bin/bash your_name=\u0026#34;yline\u0026#34; # 使用双引号拼接 greeting=\u0026#34;hello, \u0026#34;$your_name\u0026#34; !\u0026#34; greeting_1=\u0026#34;hello, ${your_name} !\u0026#34; echo $greeting $greeting_1 # 使用单引号拼接 greeting_2=\u0026#39;hello, \u0026#39;$your_name\u0026#39; !\u0026#39; greeting_3=\u0026#39;hello, ${your_name} !\u0026#39; echo $greeting_2 $greeting_3 获取字符串长度 1 2 3 string=\u0026#34;abcd\u0026#34; echo ${#string} # 输出4 echo ${#string[0]} # 输出4 变量为字符串时，${#string}等价于${#string[0]} 提取子字符串 从字符串第2个字符开始截取4个字符 1 2 3 4 #!/bin/bash string=\u0026#34;Hello World!\u0026#34; echo ${string:1:4} 第一个字符串索引为0 查找字符串 查找字符o或r的位置（哪个先出现就计算哪个） 1 2 3 4 #!/bin/bash string=\u0026#34;Hello World!\u0026#34; echo `expr index \u0026#34;$string\u0026#34; or` # 输出为5 数组 介绍 Bash Shell只支持一维数组，初始化不需要定义数组大小 数组元素小标由0开始 语法格式 1 array_name=(value1 value2 ... valuen) 定义数组 格式 1 array_name=(value0 value1 value2 value3) 或者\n1 2 3 4 5 6 array_name=( value0 value1 value2 value3 ) 单独定义数组的各个分量\n1 2 3 array_name[0]=value0 array_name[1]=value1 array_name[n]=valuen 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/bin/bash array1=(A B \u0026#34;C\u0026#34; D) array2[0]=A array2[1]=B array2[2]=\u0026#34;C\u0026#34; array3[3]=D echo \u0026#34;----------------------------\u0026#34; echo \u0026#34;array1[0]=${array1[0]}\u0026#34; echo \u0026#34;array1[1]=${array1[1]}\u0026#34; echo \u0026#34;array1[2]=${array1[2]}\u0026#34; echo \u0026#34;array1[3]=${array1[3]}\u0026#34; echo \u0026#34;----------------------------\u0026#34; echo \u0026#34;array2[0]=${array2[0]}\u0026#34; echo \u0026#34;array2[1]=${array2[1]}\u0026#34; echo \u0026#34;array2[2]=${array2[2]}\u0026#34; echo \u0026#34;array2[3]=${array2[3]}\u0026#34; echo \u0026#34;----------------------------\u0026#34; 读取数组 格式 1 ${array_name[index]} 示例 1 2 3 4 5 6 7 #!/bin/bash my_array=(A B \u0026#34;C\u0026#34; D) echo \u0026#34;第一个元素为: ${my_array[0]}\u0026#34; echo \u0026#34;第二个元素为: ${my_array[1]}\u0026#34; echo \u0026#34;第三个元素为: ${my_array[2]}\u0026#34; echo \u0026#34;第四个元素为: ${my_array[3]}\u0026#34; 关联数组 Bash 支持关联数组，可以使用任意的字符串、或者整数作为下标来访问数组元素。\n格式 -A 选项就是用于声明一个关联数组 关联数组的键是唯一的。 1 declare -A array_name 示例 1 2 3 4 5 6 7 8 9 10 #!/bin/bash declare -A site site[\u0026#34;baidu\u0026#34;]=\u0026#34;www.baidu.com\u0026#34; site[\u0026#34;google\u0026#34;]=\u0026#34;www.google.com\u0026#34; site[\u0026#34;taobao\u0026#34;]=\u0026#34;www.taobao.com\u0026#34; echo ${site[\u0026#34;baidu\u0026#34;]} echo ${site[\u0026#34;google\u0026#34;]} echo ${site[\u0026#34;taobao\u0026#34;]} 获取数组中的所有元素 使用@或*可以获取数组中的所有元素\n1 2 3 4 5 6 7 8 9 #!/bin/bash my_array[0]=A my_array[1]=B my_array[2]=C my_array[3]=D echo \u0026#34;数组的元素为：${my_array[*]}\u0026#34; echo \u0026#34;数组的元素为：${my_array[@]}\u0026#34; 1 2 3 4 5 6 7 8 9 #!/bin/bash declare -A site site[\u0026#34;baidu\u0026#34;]=\u0026#34;www.baidu.com\u0026#34; site[\u0026#34;google\u0026#34;]=\u0026#34;www.google.com\u0026#34; site[\u0026#34;taobao\u0026#34;]=\u0026#34;www.taobao.com\u0026#34; echo \u0026#34;数组的元素为：${site[*]}\u0026#34; echo \u0026#34;数组的元素为：${site[@]}\u0026#34; 在数组前加一个感叹号！可以获取数组的所有键 1 2 3 4 5 6 7 8 9 #!/bin/bash declare -A site site[\u0026#34;baidu\u0026#34;]=\u0026#34;www.baidu.com\u0026#34; site[\u0026#34;google\u0026#34;]=\u0026#34;www.google.com\u0026#34; site[\u0026#34;taobao\u0026#34;]=\u0026#34;www.taobao.com\u0026#34; echo \u0026#34;数组的键为：${!site[*]}\u0026#34; echo \u0026#34;数组的键为：${!site[@]}\u0026#34; 获取数组的长度 获取数组的长度方法与获取字符串长度的方法相同 1 2 3 4 5 6 7 8 9 #!/bin/bash my_array[0]=A my_array[1]=B my_array[2]=\u0026#34;C\u0026#34; my_array[3]=D echo \u0026#34;数组元素个数为：${#my_array[*]}\u0026#34; echo \u0026#34;数组元素个数为：${#my_array[@]}\u0026#34; 运算符 算数运算符 使用方式 1 2 3 4 5 (1)$((运算表达式)) (2)$[运算表达式] (3)expr 运算表达式 示例 1 2 3 4 5 6 7 8 9 10 11 #!/bin/bash echo \u0026#34;----------------------\u0026#34; echo \u0026#34;(2+3)*4 = $(((2+3)*4))\u0026#34; echo \u0026#34;----------------------\u0026#34; echo \u0026#34;(2+3)*4 = $[(2+3)*4]\u0026#34; echo \u0026#34;----------------------\u0026#34; TEMP=`expr 2 + 3` echo \u0026#34;(2+3)*4 = `expr $TEMP \\* 4`\u0026#34; ","date":"2025-10-05T17:05:56+08:00","permalink":"https://YLine-hub.github.io/p/shell%E7%BC%96%E7%A8%8B/","title":"Shell编程"},{"content":"端口管理 lsof 介绍 lsof（list open files）\n一个列出当前系统打开文件的工具。\n基本语法 1 lsof -i:端口号 示例 查看服务器80端口占用情况 1 2 3 4 5 6 7 8 9 COMMAND：进程名称 PID：进程标识符 USER：进程所有者 FD：文件描述符，应用程序通过描述符识别该文件。如cwd、txt等 TYPE：文件类型，如DIR、REG等 DEVICE：指定磁盘的名称 SIZE：文件大小 NODE：索引节点（文件在磁盘上的标识） NAME：代开文件的确切名称 查看所有端口使用情况 更多lsof命令：\n1 2 3 4 5 6 7 8 9 lsof -i:8080：查看8080端口占用 lsof abc.txt：显示开启文件abc.txt的进程 lsof -c abc：显示abc进程现在打开的文件 lsof -c -p 1234：列出进程号为1234的进程所打开的文件 lsof -g gid：显示归属gid的进程情况 lsof +d /usr/local/：显示目录下被进程开启的文件 lsof +D /usr/local/：同上，但是会搜索目录下的目录，时间较长 lsof -d 4：显示使用fd为4的进程 lsof -i -U：显示所有打开的端口和UNIX domain文件 netstat 介绍 用于显示 tcp，udp 的端口和进程等相关情况。 基本语法 1 2 # 查看端口占用语法格式 netstat -tunlp | grep 端口号 options: -t (tcp) 仅显示tcp相关选项 -u (udp)仅显示udp相关选项 -n 拒绝显示别名，能显示数字的全部转化为数字 -l 仅列出在Listen(监听)的服务状态 -p 显示建立相关链接的程序名 示例 查看80端口情况 更多命令：\n1 2 3 netstat -ntlp //查看当前所有tcp端口 netstat -ntulp | grep 80 //查看所有80端口使用情况 netstat -ntulp | grep 3306 //查看所有3306端口使用情况 ","date":"2025-10-05T03:06:03+08:00","permalink":"https://YLine-hub.github.io/p/linux%E7%AB%AF%E5%8F%A3%E7%AE%A1%E7%90%86/","title":"Linux端口管理"},{"content":"服务管理 介绍 服务的本质就是进程，但是是运行在后台的，通常会监听某个端口，等待其他进程的请求，因此我们又称为守护进程。\n查看服务 centos7以下：文件夹下 /etc/init.d/ 下的文件名就是已启动的服务名。 centos7以上：指令 systemctl list-units --type=service查看已启动服务 1 systemctl list-units --type=service 管理指令 CentOS7以前\n1 2 3 4 5 service (服务名) start : 启动服务 service (服务名) stop : 关闭服务 service (服务名) restart : 重启服务 service (服务名) reload : 重载服务 service (服务名) status : 服务状态 CentOS7以后，service替换成systemctl，但仍然能够使用service\n1 2 3 4 5 systemctl start (服务名): 启动服务 systemctl stop (服务名): 关闭服务 systemctl restart (服务名): 重启服务 systemctl reload (服务名): 重载服务 systemctl status (服务名): 服务状态 查看防火墙状态 1 systemctl status firewalld 关闭防火墙，并再次查看防火墙状态 1 2 systemctl stop firewalld systemctl status firewalld 重启防火墙 1 2 systemctl start firewalld systemctl status firewalld 自启动设置 CentOS7以前\n1 2 3 chkconfig : 查看服务在各运行级别的自启动情况 chkconfig (服务名) : 查看指定服务在各运行级别的启动情况 chkconfig --level (级别) (服务名) on/off : 指定某个服务在指定运行级别是否自启动 CentOS7以后\n1 2 systemctl list-unit-files : 查看服务自启动情况 systemctl enable/disable (服务名) : 服务自启动/关闭自启动 查看sshd自启动情况 1 systemctl list-unit-files | grep sshd 关闭sshd自启动 1 2 systemctl disable sshd systemctl list-unit-files | grep sshd 重启sshd自启动 1 2 systemctl enable sshd systemctl list-unit-files | grep sshd 端口测试 介绍 window自带的一个指令 telnet 来测试某服务的端口是否处于监听状态（启动状态） 格式：telnet ip地址 端口号 开启方法 测试 测试sshd端口22 1 telnet 192.168.172.100 22 没有报错并显示以下界面，即端口22处于监听状态 测试192.168.172.100服务器80端口 1 telnet 192.168.172.100 80 Connecting To 192.168.172.100\u0026hellip;Could not open connection to the host, on port 80: Connect failed\n表示该80端口未处于监听状态\n打开192.168.172.100服务器80端口 1 2 3 4 5 6 # 查看80端口开放状态 firewall-cmd --query-port=80/tcp # 永久打开80端口 firewall-cmd --add-port=80/tcp --permanent # 重启防火墙 firewall-cmd --reload 发现还是无法连接\n测试192.168.172.132服务器80端口 该服务器部署了gitlab服务，80端口处于监听状态，运行了http服务\n查看132服务器80端口使用情况 1 lsof -i:80 ","date":"2025-10-05T02:02:34+08:00","permalink":"https://YLine-hub.github.io/p/linux%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/","title":"Linux服务管理"},{"content":"进程管理 介绍 Linux中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个ID号。\n每一个进程，都会有对应一个父进程，父进程可以有多个子进程。\n每个进程都有两种存在方式： 前台和后台\n前台进程：用户可以在屏幕进行操作。 后台进程：进程在运行，但无法在屏幕上看到。 进程显示 显示系统执行的进程 1 2 3 4 5 ps ps -a : 显示所有进程信息 ps -u : 以用户格式显示进程信息 ps -x : 显示后台进程运行的参数 ps -f : 显示父进程ID 查找指定进程：\n1 ps -ef | grep 关键字 PID：进程识别号 TTY：终端机号 TIME：此进程所消耗CPU时间 CMD：正在执行的命令/进程名 USER：用户名 %CPU：CPU %MEN：内存占用率 VSZ：使用虚拟内存大小 RSS：使用物理内存大小 STAT：进程状态 START：进程开始时间 COMMAND：进程执行的命令行 能看到指令运行的参数 PPID：父进程 显示进程树 1 2 3 pstree pstree -p 显示进程的PID pstree -u 显示进程所属用户 -bash: pstree: 未找到命令\n查询pstree所在包 1 yum search pstree 安装psmisc 1 yum -y install psmisc 测试 树型结构显示进程 进程终止 指令 1 2 kill (进程号：PID) kill -9 (进程号：PID) : 强制终止进程 1 2 killall (进程名，支持通配符*) killall -9 (进程名) ： 强制终止匹配的所有进程 同时登陆yline和root用户 查询进程yline 1 ps -ef | grep yline 杀死进程yline 1 kill 8913 进程监控 指令 1 2 3 4 top : 动态显示进程信息 top -d (秒数) : 设置指定秒数更新进程信息 top -i : 不显示任何闲置或僵死的进程 top -p (进程PID) : 监控指定进程信息 1 top 只显示当前正在运行的进程 1 top -i 只显示PID为682的进程 1 top -p 682 交互指令 进入进程监控界面之后可以输入一下指令，达到想要的效果。 1 2 3 4 5 6 P : 以CPU使用率进行排序（默认） M : 以内存的使用率进行排序 N : 以PID进行排序 u : 监控指定用户的进程 k : 杀死指定进程 q : 退出监控 ","date":"2025-10-04T22:13:48+08:00","permalink":"https://YLine-hub.github.io/p/linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","title":"Linux进程管理"},{"content":"Linux问题记录 问题一：开机提示emergency mode（紧急模式） 问题现象：\n进入紧急模式原因：\n/etc/fstab文件配置存在错误导致挂载文件系统时失败。 文件系统存在错误。 系统更新后的脚本错误。 (1)：在下列位置输入root密码使用root账号登陆 (2)：打开/etc/fstab 1 vi /etc/fstab (3)：注释掉原先添加的部分 (4)：reboot重启 1 reboot (5)：找到原因，配置fstab文件错误 该处应该是defaults (6)：重新配置并保存重启 1 /dev/sdb1 /home/newdisk ext4 defaults 0 0 (7)：查看是否配置成功 1 lsblk -f 可以看到自动配置硬盘成功 ","date":"2025-10-04T16:28:52+08:00","permalink":"https://YLine-hub.github.io/p/linux%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","title":"Linux问题记录"},{"content":"Linux网络配置 虚拟网络 介绍 （1）windows与虚拟网络联通\nwindow下有一个网卡为 “VMware Network Adapter VMnet8” ，是用于与虚拟机进行通讯。 window可以用ipconfig查看ip地址，linux可以用ifconfig查看ip地址。 可以看到这两个网络是同一网段。\n（2）windows与internet连接\n通过windows下的真实网卡，经历路由器网关，跟互联网进行交互。 查看默认网关 1 ip route show 网络配置 网络配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 查看网卡配置文件 $ cat /etc/sysconfig/network-scripts/ifcfg-ens33 TYPE=\u0026#34;Ethernet\u0026#34; # 网卡类型，Ethernet表示以太网 PROXY_METHOD=\u0026#34;none\u0026#34; # 代理方式：关闭状态 BROWSER_ONLY=\u0026#34;no\u0026#34; # 只是浏览器（yes|no） BOOTPROTO=\u0026#34;dhcp\u0026#34; # 设置网卡获得ip地址的方式（static|dhcp|none） DEFROUTE=\u0026#34;yes\u0026#34; # 设置为默认路由（yes|no） IPV4_FAILURE_FATAL=\u0026#34;no\u0026#34; # 是否开启IPV4致命错误检测（yes|no） IPV6INIT=\u0026#34;yes\u0026#34; # IPV6是否自动初始化 IPV6_AUTOCONF=\u0026#34;yes\u0026#34; # IPV6是否自动配置 IPV6_DEFROUTE=\u0026#34;yes\u0026#34; # IPV6是否可以为默认路由 IPV6_FAILURE_FATAL=\u0026#34;no\u0026#34; # 是否开启IPV6致命错误检测 IPV6_ADDR_GEN_MODE=\u0026#34;stable-privacy\u0026#34; # IPV6地址生成模型 NAME=\u0026#34;ens33\u0026#34; # 网卡物理设备名称 UUID=\u0026#34;8b1f9fd5-9d4b-46f7-ba3f-0ff3f862e0c2\u0026#34; # UUID识别码 DEVICE=\u0026#34;ens33\u0026#34; # 网卡设备名称 ONBOOT=\u0026#34;yes\u0026#34; # 开机自启 配置静态ip 打开文件ifcfg-ens33 1 vi /etc/sysconfig/network-scripts/ifcfg-ens33 配置参数 1 2 3 4 5 BOOTPROTO=\u0026#34;static\u0026#34; IPADDR=192.168.172.100 # 网关和DNS1相同即可 GATWAY=192.168.172.2 DNS1=192.168.172.2 重启网络 1 systemctl restart network ","date":"2025-10-03T21:16:25+08:00","permalink":"https://YLine-hub.github.io/p/linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/","title":"Linux网络配置"},{"content":"Linux磁盘管理 磁盘分区 分区原因 数据的安全性隔离：独立分开每个分区，使各区数据不会相互影响。\n系统的效率考虑：加快数据寻址的效率。\n分区方式 mbr分区 最多支持四个主分区 系统只能安装主分区 拓展分区要占一个主分区 MBR最大只支持2TB，但拥有最好的兼容性 适用场景：旧设备通常使用BIOS启动，仅支持MBR。 磁盘容量小于2TB。 需要兼容旧操作系统（如32位Windows）。\ngpt分区 支持无线多个主分区（但操作系统可能限制） 最大支持18EB的大容量（1EB = 1024PB，1PB = 1024TB） 适用场景：现代设备通常支持UEFI，推荐使用GPT。 磁盘容量大于2TB。 更高的可靠性和扩展性需求。\nLinux分区 介绍 Linux采用一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录关联起来。\n分区命名 （1）Linux的硬盘分为IDE（旧），SCSI（新）硬盘两种\n（2）IDE分区命名： 盘号标识符为：hdx~\nhd为设备类型，即指IDE硬盘 x为盘号【a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘】 ~为区号，即此分区为当前盘号的第几个分区【1~4主分区，5后为逻辑分区】 例如： hda1 （3）SCSI分区命名： 基本和IDE一致，只是设备类型不同，为sdx~\n例如：sda1 分区查看 lsblk(list block) 1 lsblk -f NAME: 块设备名称，例如 sda, sda1。 FSTYPE: 文件系统类型，例如 ext4, ntfs, swap 等。 FSVER: 文件系统版本（如果适用）。 LABEL: 文件系统标签（如果有设置）。 UUID: 文件系统的唯一标识符。 MOUNTPOINT: 当前挂载点（如果设备已挂载）。 磁盘挂载 挂载案例 给虚拟机创建一个新的硬盘，并挂载到/home/newdisk下 挂载步骤 给虚拟机添加新的硬盘 ハードディスク：harddisk 硬盘\n点击编辑虚拟机的设定 点击添加 选择硬盘然后点击下一步 默认SCSI硬盘即可 填写自己需要的硬盘数量并点击下一步 点击完成后，虚拟机设定内就会新增一个硬盘 点击ok并启动虚拟机 输入lsblk -f查看是否又新的硬盘 这块sdb就是新添加的硬盘\n分区 命令行输入：fdisk 设备位置，进入分区引导程序 输入m，查看指令目录\nn ： 添加一个新的分区\nw ： 写入到磁盘并退出\n输入指令n，添加新分区\n分区类型 ： p=主分区，e=扩展分区\n分区号码 ： 默认1\n起始扇区 ： 默认2048\n最后扇区 ： 默认硬盘最后的字节\n输入指令w，写入到磁盘并退出 查看磁盘分区，其中sdb1只有分区名，没有其他信息，需要进行格式化 1 lsblk -f 格式化 将分区格式化为ext4文件系统 1 mkfs -t ext4 /dev/sdb1 查看分区，sdb1已经属于ext4文件系统，且拥有唯一标识 挂载 创建新的目录，并将新的硬盘挂载在目录下 设置自动挂载 由于重启后需要重新挂载，设置自动挂载后，重启就不需要再重新挂载 1 2 # 打开/etc/fstab vi /etc/fstab 仿照上面的格式，写入挂载信息，并保存 1 2 # 挂载设备 挂载目录 文件系统 defaults 0 0 /dev/sdb1 /home/newdisk ext4 defaults 0 0 磁盘命令 df 介绍（检查硬盘占用情况） 检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。 基本语法 1 df [options] 目录或文件名 options：\n-h：以人类可读的方式显示输出结果（例如，使用 KB、MB、GB 等单位）。\n-T：显示文件系统的类型。\n-t \u0026lt;文件系统类型\u0026gt;：只显示指定类型的文件系统。\n-i：显示 inode 使用情况。\n-H：该参数是 -h 的变体，但是使用 1000 字节作为基本单位而不是 1024 字节。这意味着它会以 SI（国际单位制）单位（例如 MB、GB）而不是二进制单位（例如 MiB、GiB）来显示磁盘使用情况。\n-k：这个选项会以 KB 作为单位显示磁盘空间使用情况。\n-a：该参数将显示所有的文件系统，包括虚拟文件系统，例如 proc、sysfs 等。如果没有使用该选项，默认情况下，df 命令不会显示虚拟文件系统。\n示例 将系统内所有文件系统列出来 1 df 将容量结果以易读的容量格式显示出来 1 df -h 将系统内所有特殊文件格式及名称都列出来 1 df -aT 将/etc地下的可用的磁盘容量以易读的容量格式显示 1 df -h /etc du 介绍（检查指定目录磁盘占用情况） 对文件和目录磁盘使用的空间的查看。 基本语法 1 du [options] 文件或目录 options:\n-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。 -h ：以人们较易读的容量格式 (G/M) 显示； -s ：仅显示指定目录或文件的总大小，而不显示其子目录的大小。 -S ：包括子目录下的总计，与 -s 有点差别。 -k ：以 KBytes 列出容量显示； -m ：以 MBytes 列出容量显示； -c ：并统计总用量； 示例 列出当前目录下所有文件夹容量（包括子目录和隐藏文件夹） 1 du 将文件的容量也列出来 检查根目录底下每个目录所占容量 fdisk 介绍 磁盘分区表操作工具 基本语法 1 fdisk [options] 装置名称 options: -l : 输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。 示例 列出所有分区信息 1 fdisk -l 实用指令 查询指定目录下文件个数 1 ls -l 目录 | grep \u0026#34;^-\u0026#34; | wc -l 列出指定目录中的所有文件 1 ls -l /usr/lib/python2.7/site-packages/ 列出指定目录中“-”开头的文件 1 ls -l /usr/lib/python2.7/site-packages/ | grep \u0026#34;^-\u0026#34; 统计指定目录下“-”开头文件的个数 1 2 # wc(word count)统计个数 ls -l /usr/lib/python2.7/site-packages/ | grep \u0026#34;^-\u0026#34; | wc -l 查看指定目录文件个数（包含子目录） 跟上面基本一样，只是添加-R来进行递归 1 ls -lR 目录 | grep \u0026#34;^-\u0026#34; | wc -l 树形结构显示文件 1 tree 目录 安装tree命令 1 yum -y install tree 树形结构显示目录 ","date":"2025-10-01T13:50:43+08:00","permalink":"https://YLine-hub.github.io/p/linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/","title":"Linux磁盘管理"},{"content":"Linux用户账号管理 用户登陆与注销 登陆时尽量少用root账号登陆，因为它是系统管理员，权限最大，为避免操作失误。可以利用普通用户登陆，登陆后再用“su 用户名”命令来切换程系统管理员身份。\n切换用户：su 用户名\n注销用户：logout\nuseradd添加用户 基本语法 1 useradd options username options:\n-c comment 指定一段注释性描述。 -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 -g 用户组 指定用户所属的用户组。 -G 用户组，用户组 指定用户所属的附加组。 -s Shell文件 指定用户的登录Shell。 -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号 -m 用户目录如果不存在则自动创建。 username: 自定新账号的登录名\n示例 创建用户sam，其中-d和-m用来产生用户目录 1 useradd -d /home/sam -m sam 创建用户gem，该用户登陆Shell是/bin/sh，属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。 1 useradd -s /bin/sh -g group -G adm,root gem 以下是三个用户\n增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。 userdel删除用户 基本语法 1 userdel options username options\n-r 用于把用户的主目录一起删除。 示例 删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。 1 userdel -r sam usermod修改用户 基本语法 1 usermod options username options 包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。\n示例 将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。 1 usermod -s /bin/ksh -d /home/z -g developer sam passwd用户口令管理 用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。 基本语法 1 passwd options username options:\n-l 锁定口令，即禁用账号。 -u 口令解锁。 -d 使账号无口令。 -f 强迫用户下次登录时修改口令。 示例 如果是默认用户，修改当前用户的口令 1 2 3 4 $ passwd Old password:****** New password:******* Re-enter new password:******* 如果是超级用户，可以用下列形式修改指定任何用户的口令 1 2 3 $ passwd sam New password:******* Re-enter new password:******* 为用户指定空口令 1 $ passwd -d sam 删除sam用户口令，锁定sam，下一次sam就不再被允许登陆。 1 $ passwd -l sam 其他 用户与组的相关文件/etc/passwd 1 2 3 4 5 6 7 8 # /etc/passwd文件 # 用户 (user）的配置文件，记录用户的各种信息 cat /etc/passwd # 每行的含义: 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell yline:x:1000:1000:yline:/home/yline:/bin/bash /etc/shadow文件 1 2 3 4 5 6 # 口令的配置文件 cat /etc/shadow # 每行的含义: 登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 root:$6$qWXOPskK$JtjIOb0PE4k.86YmO4GbNolp.4ZmD8iMZDpNogyCzMNbbLsMdV17EcrpYVB/OW7CysD2KP.2rfV/nHucGkcLY1:20358:0:99999:7::: /etc/group文件 1 2 3 4 5 # 组(group)的配置文件，记录Linux包含的组的信息 cat /etc/group # 每行含义: 组名:口令:组标识号:组内用户列表 Linux用户组管理 groupadd增加用户组 1 groupadd options group 常用选项\n-g GID 指定新用户组的组标识号（GID）。 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。 示例 增加用户组group1，新组标识号是在当前最大组标识号上加1 1 groupadd group1 增加用户组group2，同时指定新组标识号为101 1 groupadd -g 101 group2 groupdel删除用户组 基本语法 1 groupdel group 示例 删除用户组group1 1 groupdel group1 groupmod修改用户组 基本语法 1 groupmod options group 常用选项：\n-g GID 为用户组指定新的组标识号。 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。 -n新用户组 将用户组的名字改为新名字 示例 将用户组group2的组标识号修改为102 1 groupmod -g 102 group2 将group2的标识号改为10000，组名修改为group3 1 groupmod -g 10000 -n group3 group2 newgrp切换用户组 如果用户同时属于多个组，那么用户可以在用户组之间切换\n切换到root组\n1 newgrp root 批量添加用户 编辑文本用户文件 每一列按照/etc/passwd密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号。\nuser.txt范例\n1 2 3 4 5 6 user001:x:1003:1000:users:/home/user001:/bin/bash user002:x:1004:1000:users:/home/user002:/bin/bash user003:x:1005:1000:users:/home/user003:/bin/bash user004:x:1006:1000:users:/home/user004:/bin/bash user005:x:1007:1000:users:/home/user005:/bin/bash user006:x:1008:1000:users:/home/user006:/bin/bash 以root身份导入用户 以root身份执行/user/sbin/newusers，从刚创建的user.txt中导入数据，创建用户 1 newusers \u0026lt; user.txt 然后执行vipw 或 vi /etc/passwd检查/etc/passwd文件中是否已经出现这些用户的数据，并且用户的宿主目录是否已经创建。 编辑每个用户的密码对照文件 1 2 # 格式 用户名：密码 passwd.txt范例 1 2 3 4 5 6 user001:123456 user002:123456 user003:123456 user004:123456 user005:123456 user006:123456 以root身份执行/usr/sbin/chpasswd 创建用户密码，chpasswd 会将经过/usr/bin/passwd命令编码过的密码写入/etc/passwd的密码栏 1 cat passwd.txt | chpasswd 注意： 一开始使用chpasswd \u0026lt; passwd.txt命令更新密码，一直显示密码错误。目前不知道原因。\n权限管理 文件的基本属性 文件类型 说明 - 普通文件 d 目录 l 软连接 c 字符设备【键盘、鼠标等】 b 块文件，硬盘 权限类型 说明 r read，读，查看文件 w write，写，修改文件，也可以删除文件 x execute，执行，执行文件 - 没有权限 权限的rwx可以用数字来表示\nr = 4 w = 2 x = 1 文件的权限修改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 修改文件 / 目录权限 # 方式一 chmod u=[rwx], g=[rwx], o=[rwx] 文件/目录名 #例：chmod u=rwx, g=rx, o=r hello.txt # u --- user 所有者 # g --- group 所在组 # o --- other 其他组 # a --- all 全部 # 方式二 chmod [ugoa][+-][rwx] 文件/目录名 #例：chmod u+r hello.txt # + --- 添加权限 # - --- 移除权限 # 方式三 chmod [数字权限][数字权限][数字权限] 文件/目录名 #例：chmod 764 hello.txt # r=4 w=2 x=1 # 7=rwx 6=rw 5=rx 3=wx # 第一个为所有者，第二为所在组，第三为其他组 用方法一分别给所有者所有权限，所在组读执行权限，其他组读权限 1 chmod u=rwx,g=rx,o=r hello.txt 用方法二给所在组添加写权限 1 chmod g+w hello.txt 用方法三添加所有权限 1 chmod 777 hello.txt ","date":"2025-09-30T10:32:33+08:00","permalink":"https://YLine-hub.github.io/p/linux%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/","title":"Linux用户组管理与权限管理"},{"content":"用法：按f12打开浏览器开发者工具，切换到控制台，然后复制粘贴以下脚本，回车。\n1 2 3 4 5 6 7 8 var article_content=document.getElementById(\u0026#34;article_content\u0026#34;); article_content.removeAttribute(\u0026#34;style\u0026#34;); var follow_text=document.getElementsByClassName(\u0026#39;follow-text\u0026#39;)[0]; follow_text.parentElement.parentElement.removeChild(follow_text.parentElement); var hide_article_box=document.getElementsByClassName(\u0026#39; hide-article-box\u0026#39;)[0]; hide_article_box.parentElement.removeChild(hide_article_box); ","date":"2025-09-30T10:14:04+08:00","permalink":"https://YLine-hub.github.io/p/csdn%E8%B7%B3%E8%BF%87%E5%85%B3%E6%B3%A8%E5%8D%9A%E4%B8%BB%E5%8D%B3%E5%8F%AF%E9%98%85%E8%AF%BB%E5%85%A8%E6%96%87/","title":"csdn跳过[关注博主即可阅读全文]"},{"content":"Linux文本编辑器 介绍 所有的Linux系统都会默认配置vi文本编辑器 vim具有程序编辑能力，可以看做vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计，而且还有代码补完，编译以及错误跳转等功能 三种模式 命令模式 启动 vi/vim，便进入了命令模式。\n此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符。\n常见命令 /+关键字 \u0026ndash; 查找关键字 切换输入操作 i \u0026ndash; 切换到输入模式，在光标当前位置开始输入文本。 a \u0026ndash; 进入插入模式，在光标下一个位置开始输入文本。 o \u0026ndash; 在当前行的下方插入一个新行，并进入插入模式。 O \u0026ndash; 在当前行的上方插入一个新行，并进入插入模式。 光标移动操作 G \u0026ndash; 光标移动到文件最后一行的位置。 gg \u0026ndash; 光标移动到文件第一行的位置。 shift + 4 \u0026ndash; 光标移动到当前行行尾。 shift + 6 \u0026ndash; 光标移动到当前行行首。 复制粘贴操作 dd \u0026ndash; 剪切当前行。 yy \u0026ndash; 复制当前行。 p（小写） \u0026ndash; 粘贴剪贴板内容到光标下方。 P（大写）\u0026ndash; 粘贴剪贴板内容到光标上方。 删除操作 x \u0026ndash; 删除当前光标所在处的字符。 撤销回退操作 u \u0026ndash; 撤销上一次操作。 Ctrl + r \u0026ndash; 重做上一次撤销的操作。 切换底线命令模式 : \u0026ndash; 切换到底线命令模式，以在最底一行输入命令。 输入模式 在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到普通模式。 底线命令模式 在命令模式下按下 :（英文冒号）就进入了底线命令模式。\n按 ESC 键可随时退出底线命令模式。\n基本命令 :w：保存文件。 :q：退出 Vim 编辑器。 :wq：保存文件并退出 Vim 编辑器。 :q!：强制退出Vim编辑器，不保存修改。 :set nu或set number：显示行号 ","date":"2025-09-29T20:57:21+08:00","permalink":"https://YLine-hub.github.io/p/linux%E7%9A%84vi%E4%B8%8Evim%E4%BD%BF%E7%94%A8/","title":"Linux的vi与vim使用"},{"content":"星期 月曜日 火曜日 水曜日 木曜日 金曜日 土曜日 日曜日 windows 常用工具 電卓（でんたく）：计算器 コントロール　パネル：control panel 控制面板 プログラム：program 节目；程序 システム：system 系统 セキュリティ：security 安全；保安；防护 ハードウェア：hardware 硬件 サウンド：sound 声音；音响 生词 機能（きのう）：机能；功能；作用 または：或者 有効（ゆうこう）：有效；生效 無効（むこう）：无效；失效 ユーザー：user 用户 アカウント：account 账号 カスタマイズ：customize 定制；个性化设置 地域（ちいき）：地区；区域 ","date":"2025-09-28T17:19:03+08:00","permalink":"https://YLine-hub.github.io/p/%E6%97%A5%E8%AF%AD%E7%94%9F%E8%AF%8D/","title":"日语生词"},{"content":"","date":"2025-09-28T16:28:56+08:00","permalink":"https://YLine-hub.github.io/p/java%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/","title":"Java开发工程师学习路线"},{"content":"运维工程师学习路线 初级运维工程师 中级运维工程师 高级运维工程师 ","date":"2025-09-28T16:28:33+08:00","permalink":"https://YLine-hub.github.io/p/%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/","title":"运维工程师学习路线"},{"content":"Linux常用指令 帮助指令 介绍 用来了解不熟悉的指令 man 基本语法 1 2 # 获取帮助信息 man [选项] [节号] 命令/主题 常见选项 -f：显示与指定关键字相关的手册页面。 -k：搜索手册页中与关键字匹配的条目。 -a：显示所有匹配的手册页面。 -w：仅显示手册页的位置，而不显示其内容。 常见节号 1：用户命令 2：系统调用 3：C库函数 4：设备和特殊文件 5：文件格式和约定 6：游戏和演示 7：杂项 8：系统管理命令 示例 1 2 # 查看ls命令的手册页面 man ls 1 2 # 查看C语言标准库函数printf的手册页面 man 3 printf 1 2 # 搜索包含特定关键字ls的手册页面条目 man -k ls 常用参数 1 2 3 4 5 6 箭头上：向上移动 箭头下：向下移动 大写N：向上查找 小写n：向下查找 /或? : 查找内容 q : 退出 help 基本语法 1 2 3 4 5 6 # 方法一 help [选项] 命令 # 方法二 命令 --help 基本选项 -d 显示内建命令的简要描述。 -m 按照 man 手册的格式输出帮助信息。 -s 仅输出内建命令的命令格式。 示例 1 2 # 查看cd命令的帮助信息 help cd 1 2 # 使用简短格式显示帮助 help -s cd 1 2 # 按man手册格式显示帮助 help -m cd 1 2 # 查看ls命令手册 ls --help 目录指令 pwd 介绍（显示目录） 显示当前目录的完整路径 基本语法 1 pwd [选项] 基本选项 -L（\u0026ndash;logical）：显示逻辑路径（默认）。\n-P（\u0026ndash;physical）：显示物理路径。\n\u0026ndash;help\t:显示帮助信息\n\u0026ndash;version\t:显示版本信息\n示例 1 2 3 4 5 6 7 8 9 $ mkdir -p /var/www/html $ ln -s /var/www/html/ myweb $ cd myweb/ $ pwd /home/yline/myweb # 逻辑路径（当前目录） $ pwd -L /home/yline/myweb # 逻辑路径 $ pwd -P /var/www/html # 物理路径 ls 介绍（查看目录） 用于显示指定工作目录下的内容 基本语法 1 ls [选项] [路径/文件] 常见选项 -a：显示所有文件（包括隐藏文件） -A：显示除.和..外的所有文件（包括隐藏文件） -l：以详细信息列出文件 -lh：以详细信息列出文件，并以可读的格式显示文件大小（如KB、MB） -t：按修改时间排序（最新优先） -r：反向排序（配合-t、-S等使用） -S：按文件大小排序（大文件优先） -R：递归列出子目录内容 示例 1 2 # 详细出当前目录所有文件（包含隐藏文件） ls -la 1 2 # 按照大小反向排序，并详细列出文件 ls -lShr 1 2 # 递归列出/opt/vmware-tools-distrib/ 及其所有子目录的内容，并显示可读的文件大小（kb） ls -lhR /opt/vmware-tools-distrib/ 1 2 # 仅显示/opt/这个目录的详细信息 ls -ld /opt 1 2 # 按修改时间排序(最新最后) ls -ltr 1 2 # 列出当前目录下所有名称是s开头的文件（最新最后） ls -ltr s* 选项 -l 详解 第一列的字符表示文件或目录的类型和权限。\n- 表示普通文件 d 表示目录 l 表示符号链接 c 表示字符设备文件 b 表示块设备文件 s 表示套接字文件 p 表示管道文件 其余 9 个字符表示文件或目录的访问权限，分别对应三个字符一组的 rwx 权限。\nr 表示读取权限 w 表示写入权限 x 表示执行权限 - 表示没有对应权限 1 2 # 前三个字符表示所有者的权限，中间三个字符表示所属组的权限，后三个字符表示其他用户的权限。 -rw-r--r-- 1 user group 4096 Feb 21 12:00 file.txt 其他常用操作 1 2 # 显示当前目录下最近修改的 5 个文件。 ls -lt | head -5 1 2 # 统计当前目录下的文件数量(不包括隐藏文件)。 ls | wc -l 注意事项 可以通过输出文件颜色，判断文件类型：\n蓝色：目录 绿色：可执行文件 红色：压缩文件 青色：链接文件 黄色：设备文件 cd 介绍（切换目录） 用于改变当前工作目录，切换到指定路径的命令。 基本语法 1 cd dirName dirName：要切换的目标目录，可以是相对路径或绝对路径。 示例 切换绝对路径 1 cd /path/to/directory 切换相对路径：指定相对于当前目录的路径来切换到目标路径 1 cd relative/path/to/directory 切换到/usr/bin/ 目录 1 cd /usr/bin 切换到上级目录 1 cd .. 切换到上上级目录 1 cd ../.. 切换到主目录（home）：使用~表示当前用户的主目录 1 cd ~ 切换到上次访问的目录 1 cd - 切换到环境变量指定的目录 1 cd $VAR_NAME mkdir 介绍（创建目录） 用于创建目录 基本语法 1 mkdir [-p] dirName 示例 在当前目录下创建一个myweb目录 1 mkdir myweb 在var下的www目录下创建一个myweb目录。（若www目录不存在，则自动创建一个） 注：不加-p参数的话，若www目录原本不存在，则会报错\n1 mkdir -p /var/www/myweb rmdir 介绍（删除目录） 用于删除空的目录 基本语法 1 mkdir [-p] dirName 示例 删除当前目录下的myweb空目录 1 rmdir myweb 若myweb不为空目录的话则报错：rmdir: failed to remove ‘myweb/’: Directory not empty\n删除www目录下名为myweb的子目录。若myweb删除后，www目录成为空目录，则www也删除 1 rmdir -p www/myweb 文件指令 touch 介绍（创建文件） 修改文件或目录的时间属性。若文件不存在，则会建立一个新文件 基本语法 1 touch 文件名 示例 创建空白文件index.html 1 touch index.html 将index.html文件的时间属性修改为当前系统时间（index.html存在，且时间不为最新时间） 1 touch index.html 创建多个空白文件 1 touch file1.txt file2.txt cp 介绍（复制文件） 用于复制文件或目录 基本语法 options : 选项 source : 源文件 dest ： 目标文件 1 cp [options] source dest 基本选项 -r 或 -R：递归复制目录及其内容（用于复制目录）。\n-i：交互模式，覆盖前提示用户确认。\n-f：强制复制，覆盖目标文件而不提示。\n-v：显示详细的复制过程（verbose）。\n-p：保留文件的原始属性（如权限、时间戳等）。\n-a：归档模式，等同于 -dpR，保留所有文件属性和递归复制目录。\n-u：仅当源文件比目标文件新时才复制（更新模式）。\n-l：创建硬链接而不是复制文件。\n-s：创建符号链接（软链接）而不是复制文件。\n示例 复制文件到目标目录 1 cp file.txt /path/to/destination 复制文件并重命名 1 cp file.txt /path/to/destination/newfile.txt 递归复制目录 1 2 # 将目录/source_dir及其目录下所有内容，递归复制到/destination目录 cp -r /path/to/source_dir /path/to/destination 交互模式复制 1 cp -i file.txt /path/to/destination 如果目标位置已存在同名文件，会提示用户确认是否覆盖，输入y就表示同意覆盖\n默认有-i选项，不加也行\n保留模式复制 1 cp -p file.txt /path/to/destinatino 复制文件并保留其原始属性（如权限、时间戳等 ）\n创建硬链接或符号链接 1 2 cp -l file.txt /path/to/destination/ # 创建硬链接 cp -s file.txt /path/to/destination/ # 创建符号链接 同时复制多个目标 1 cp *.txt /path/to/destination/ 结合find命令复制特定文件 1 2 # 查找并复制所有 .log 文件到目标目录。 find /path/to/source -name \u0026#34;*.log\u0026#34; -exec cp {} /path/to/destination/ \\; mv 介绍（移动文件【重命名】） 用来为文件或目录改名，或者移动到其他位置 基本语法 1 mv [options] source dest 基本选项 -b: 当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。 -i: 如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作。 -f: 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。 -n: 不要覆盖任何已存在的文件或目录。 -u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。 基本语法 命令格式 运行结果 mv source_file dest_file 将source_file改名为dest_file mv source_file dest_dir 将source_file移动到dest_dir目录下 mv source_dir dest_dir dest_dir存在，将source_dir移动到dest_dir下；dest_dir不存在，则将source_dir改名为dest_dir 示例 将文件aaa改名为bbb 1 mv aaa bbb 将info目录放入logs目录中。（若logs不存在，则将info改名为logs） 1 mv info/ logs 将/var/www/myweb下的所有文件和目录移动到当前目录下 1 mv /var/www/myweb . cat 介绍（查看、追加文件） 用于查看和连接文件 基本语法 1 cat [options] file 基本选项 -n：显示行号，会在输出的每一行前加上行号。 -b：显示行号，但只对非空行进行编号。 -s：压缩连续的空行，只显示一个空行。 -E：在每一行的末尾显示 $ 符号。 -T：将 Tab 字符显示为 ^I。 -v：显示一些非打印字符。 示例 查看文件内容 1 cat file1.txt 输入并覆盖文件内容 1 2 3 4 5 6 $ cat file1.txt abc $ cat \u0026gt; file1.txt 123 $ cat file1.txt 123 追加内容到文件末尾 1 2 3 4 5 6 7 $ cat file1.txt 123 $ cat \u0026gt;\u0026gt; file1.txt 456 $ cat file1.txt 123 456 连接文件，将file1和file2的内容合并到file3中 1 2 3 4 5 6 7 8 9 10 $ cat file1.txt 123 456 $ cat file2.txt iop $ cat file1.txt file2.txt \u0026gt; file3.txt $ cat file3.txt 123 456 iop 显示多个文件的内容 1 cat file1.txt file2.txt 使用管道，将cat的输出作为另一个命令的输入 1 cat filename | command 查看文件的最后3行（使用管道） 1 cat file1.txt | tail -n 3 查看文件并显示行号 1 cat -n file1.txt 查看文件并显示行号（空行不显示） 1 cat -b file1.txt 显示文件，并和连续空行 1 cat -s file1.txt 可以看到上一个的9、10两个空行被并合\n将file3文件的内容加上行号覆盖到file2文件中 1 cat -n file3.txt \u0026gt; file2.txt 显示文件内容，并用$表示行结束 1 cat -e file1.txt 把 file1 和 file2 的内容加上行号（空白行不加）之后将内容加到 file3 最后 1 cat -b file1.txt file2.txt \u0026gt;\u0026gt; file3.txt 清空file2的内容 1 cat /dev/null \u0026gt; file2.txt 使用cat制作镜像 cat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入： 1 cat /dev/fd0 \u0026gt; OUTFILE 相反的，如果想把 image file 写到软盘，输入： 1 cat IMG_FILE \u0026gt; /dev/fd0 head 介绍（查看文件开头） 用于查看文件的开头部分 基本语法 1 head [options] 文件 基本选项 -q : 隐藏文件名 -v : 显示文件名 -c \u0026lt;数目\u0026gt; : 显示的字节数。 -n \u0026lt;行数\u0026gt; : 显示的行数。 示例 显示file1的开头10行。（默认带参-n 10） 1 2 3 head file1.txt # 等价于 head -n 10 file1.txt 显示file1的开头5行 1 head -n 5 file1.txt 显示file1前20个字节 1 head -c 20 file1.txt tail 介绍（查看文件结尾） 查看文件的尾部内容 基本语法 1 tail [options] 文件 基本选项 -f : 循环读取 -q : 不显示处理信息 -v : 显示详细的处理信息 -c \u0026lt;数目\u0026gt; : 显示的字节数 -n \u0026lt;行数\u0026gt; : 显示文件的尾部 n 行内容 --pid=PID : 与-f合用,表示在进程ID,PID死掉之后结束 -q : 从不输出给出文件名的首部 -s : 与-f合用,表示在每次反复的间隔休眠S秒 示例 显示file1的最后10行 1 tail file1.txt 显示file1最后10行，并随file1的更新继续向下显示（常用于跟踪日志文件） 1 tail -f file1.txt 显示file1的内容，从第20行至末尾 1 tail -n +20 file1.txt 显示文件的最后10个字符 1 tail -c 10 file1.txt echo 介绍（显示文本） 在终端显示文本信息 输出变量的值 生成格式化的字符串 向文件追加内容 基本语法 1 echo [option] 字符串 常用选项 -n : 不输出换行符 -e : 启用转义字符解释 -E : 禁用转义字符解释（默认） 示例 输出字符串 1 echo \u0026#34;Hello,World!\u0026#34; 输出变量 1 2 name=\u0026#34;Linux User\u0026#34; echo \u0026#34;Welcome,$name!\u0026#34; 不带引号输出字符串（注意特殊字符） 1 echo Hello,World! -n:禁止换行 1 2 echo -n \u0026#34;Loading...\u0026#34; echo \u0026#34; success!\u0026#34; 结果:\n1 \u0026#34;Loading... success!\u0026#34; -e:启用转义字符 1 echo -e \u0026#34;First line\\nSecond line\u0026#34; 结合转义字符输出彩色文本 1 2 echo -e \u0026#34;\\033[31mRed Text\\033[0m\u0026#34; echo -e \u0026#34;\\033[42;30mGreen Background\\033[0m\u0026#34; 常用转义字符 \\n：换行 \\t：制表符 \\\\：反斜杠 \\a：警报（蜂鸣） 颜色代码 \\033[31m：红色 \\033[32m：绿色 \\033[0m：重置颜色 高级用法 使用重定向将输出保存到文件 \u0026gt; : 覆盖文件 \u0026gt;\u0026gt; : 在末尾追加内容 1 echo \u0026#34;Log entry\u0026#34; \u0026gt;\u0026gt; log.txt 命令替换：输出其他命令的执行结果 1 echo \u0026#34;Current date: $(date)\u0026#34; 格式化输出：结合printf风格的格式化 1 echo -e \u0026#34;Name\\tAge\\n----\\t---\\nAlice\\t25\\nBob\\t30\u0026#34; 简单应用示例 (1)创建简单菜单 1 2 3 4 5 6 7 8 #!/bin/bash echo \u0026#34;============ Menu ============\u0026#34; echo \u0026#34;1. Check system info\u0026#34; echo \u0026#34;2. List directory contents\u0026#34; echo \u0026#34;3. Show current user\u0026#34; echo \u0026#34;4. Exit\u0026#34; echo \u0026#34;==============================\u0026#34; echo -n \u0026#34;Please enter your choice [1-4]: \u0026#34; (2)进度条模拟 1 2 3 4 5 6 7 #!/bin/bash echo -n \u0026#34;Progress: [\u0026#34; for i in {1..20}; do echo -n \u0026#34;#\u0026#34; sleep 0.1 done echo \u0026#34;] Done!\u0026#34; (3)配置文件生成 1 2 3 4 5 6 #!/bin/bash config_file=\u0026#34;app.conf\u0026#34; echo \u0026#34;# Application Configuration\u0026#34; \u0026gt; $config_file echo \u0026#34;LOG_LEVEL=DEBUG\u0026#34; \u0026gt;\u0026gt; $config_file echo \u0026#34;MAX_CONNECTIONS=100\u0026#34; \u0026gt;\u0026gt; $config_file echo \u0026#34;Configuration file $config_file created\u0026#34; sh文件的运行（执行shell脚本） 方法一 1 sh f1.sh 方法二 1 bash f1.sh 方法三 1 ./f1.sh 若出现 -bash: ./f1.sh: Permission denied 则需要授权\n1 2 3 4 5 # 添加可执行权限 chmod +x f1.sh # 添加所有权限 chmod 777 f1.sh 方法四 1 . f1.sh ln 介绍（创建链接） 为某个文件在另个位置建立同步链接\n软连接\n1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式 2.软链接可以 跨文件系统 ，硬链接不可以 3.软链接可以对一个不存在的文件名进行链接 4.软链接可以对目录进行链接 硬链接\n1.硬链接，以文件副本的形式存在。但不占用实际空间。 2.不允许给目录创建硬链接 3.硬链接只有在同一个文件系统中才能创建 基本语法 1 ln [options] source dest 基本选项 -s : 软链接(符号链接) 示例 给文件创建软连接，若f1.sh丢失，fufu将失效 1 ln -s f1.sh fufu 给文件创建硬链接 1 ln f1.sh fufu2 fufu2与f1.sh文件属性都相同\n历史指令 history 介绍 记录用户在终端执行的所有命令历史。\n作用：\n追溯操作：查看之前执行过的命令 快速重用：无需重新输入长命令 问题排查：检查系统操作记录 效率提升：通过历史命令快速完成重复工作 基本语法 1 history [options] [parameter] 基本选项 -c : 清除所有历史记录\thistory -c -d : 删除指定位置的历史记录\thistory -d 1005 -a : 立即将内存中的历史写入历史文件\thistory -a -n : 从历史文件中读取未读的历史记录\thistory -n -r : 读取历史文件内容到当前会话\thistory -r -w : 将当前历史记录写入历史文件\thistory -w 示例 常看完整历史记录 1 history 查看最近10条记录 1 history 10 清除所有记录 1 history -c 删除第1010条历史记录 1 history -d 1010 使用技巧 （1）快速执行历史命令 1 2 3 !1024 # 执行历史记录中编号为1024的命令 !! # 重新执行上一条命令 !vim # 执行最近一条以vim开头的命令 （2）搜索历史命令 使用Ctrl+R可以反向搜索历史命令，输入部分关键词即可找到匹配命令\n（3）历史命令替换 1 ^old^new # 将上一条命令中的old替换为new后执行 1 2 $ cat file1.txt $ ^file1^file2 # 相当于执行 cat file2.txt （4）显示命令时间戳 在 ~/.bashrc 中添加以下配置可以显示命令执行时间：\n1 export HISTTIMEFORMAT=\u0026#34;%F %T \u0026#34; 然后执行\n1 source ~/.bashrc 之后 history 命令会显示每条命令的执行时间。\n实际应用场景 找回忘记的命令 1 history | grep \u0026#34;apt install\u0026#34; 统计最常用的命令 1 history | awk \u0026#39;{CMD[$2]++;count++;} END {for (a in CMD)print CMD[a] \u0026#34; \u0026#34; CMD[a]/count*100 \u0026#34;% \u0026#34; a;}\u0026#39; | grep -v \u0026#34;./\u0026#34; | column -c3 -s \u0026#34; \u0026#34; -t | sort -nr | nl | head -n10 备份历史记录 1 2 history -a # 确保最新命令已写入文件 cp ~/.bash_history ~/command_history_backup_$(date +%F).txt 找出最近5条使用yum的命令 1 history | grep yum | tail -5 环境变量配置 通过环境变量可以自定义 history 命令的行为： 变量 说明 推荐值 HISTSIZE 内存中保存的历史命令数量 5000 HISTFILESIZE 历史文件中保存的命令数量 10000 HISTCONTROL 控制历史记录方式 ignoredups:erasedups HISTIGNORE 指定不记录的命令 \u0026ldquo;ls:cd:pwd:exit\u0026rdquo; 示例（添加到 ~/.bashrc 中） 1 2 3 4 5 export HISTSIZE=5000 export HISTFILESIZE=10000 export HISTCONTROL=ignoredups:erasedups export HISTIGNORE=\u0026#34;ls:cd:pwd:exit\u0026#34; export HISTTIMEFORMAT=\u0026#34;%F %T \u0026#34; 注意事项 隐私安全：历史记录可能包含敏感信息（如密码），注意保护 多终端问题：不同终端会话默认不会实时共享历史记录 历史记录丢失：异常退出可能导致命令未保存 大文件处理：过大的历史文件可能影响性能 时间指令 date 介绍（显示时间） 用来显示或设定系统的日期与时间 示例 显示当前时间 1 2 3 4 5 6 7 8 9 10 11 12 # 显示日期 date #显示当前时间 date +%Y #显示当前年份 date +%m #显示当前月份 date +%d #显示当前日份 date \u0026#34;+%Y-%m-%d %H:%M:%S\u0026#34; #显示年月日时分秒 date -s 时间字符串 #修改系统时间，例：2021-4-15 12:00:00 1 cal #显示日历时间 搜索指令 find 介绍 用于在指定目录下查找文件和目录。 基本语法 1 find [path] [condition] [action] 示例 查找当前目录及其子目录下名为file.txt的文件 1 find . -name file.txt 将当前目录及其子目录下所有文件后缀.c的文件列出来 1 find . -name \u0026#34;*.c\u0026#34; 将当前目录及其子目录中所有文件列出来 1 find . -type f 查找/home目录及其子目录下大于1MB的文件 1 find /home -size +1M 查找/var/www 目录及其子目录下7天前被修改过的文件 1 find /var/www -mtime +7 查找/var/www 目录及其子目录下7天内被访问的文件 1 find /var/www -atime -7 找并执行操作（例如删除）： 这个例子中，-exec 选项允许你执行一个命令，{} 将会被匹配到的文件名替代，\\; 表示命令结束。\n1 find /path/to/search -name \u0026#34;pattern\u0026#34; -exec rm {} \\; locate 介绍 用于查找符合条件的文档。 示例 查找所有带passwd的文件 1 locate passwd 查找/var/www/myweb 下所有file开头的文件 1 locate /var/www/myweb/file 忽略大小写查找/var/www/myweb 下所有f开头的文件 1 locate -i /var/www/myweb/f grep 介绍 用于查找文件里符合条件的字符串或正则表达式 基本语法 1 2 3 4 5 # 语法一 grep [options] pattern [files] # 语法二 comman | grep [options] pattern [files] 示例 1 2 3 4 5 6 7 8 # 显示匹配行及行号 grep -n 查找内容 源文件 # 忽略大小写 grep -i 查找内容 源文件 # cat 查找后的内容用grep查找某个内容 cat 源文件 | grep 查找内容 压缩和解压 tar 介绍 用于打包和解压文件 基本语法 -f archive.tar：指定归档文件的名称。 [files\u0026hellip;]：要打包的文件和目录。 1 tar [options] -f archive.tar [files...] 基本选项 -c：创建一个新的归档文件。 -x：解压归档文件。 -t：列出归档文件的内容。 -r：向现有归档文件中追加文件。 -u：仅追加比归档文件中已有文件更新的文件。 -d：找到归档文件中与文件系统不同步的差异。 -A：将一个 .tar 文件追加到另一个 .tar 文件中。 示例 创建归档文件 : 将文件file1、file2和dir打包到一个名为arc.tar的归档文件中\n-c: 创建新的归档文件 -v: 显示详细输出，列出被添加到归档中的文件 -f: 指定归档文件的名称 1 tar -cvf arc.tar file1 file2 dir 解压归档文件：解压名为 archive.tar 的归档文件，还原其中包含的文件和目录。\n-x: 解压归档文件 -v: 显示详细输出，列出被解压的文件 -f: 指定要解压的归档文件的名称 1 tar -xvf archive.tar 压缩归档文件：将名为 directory 的目录打包成一个归档文件，然后使用 gzip 进行压缩，生成名为 archive.tar.gz 的文件。\n-c: 创建新的归档文件 -z: 使用 gzip 压缩归档文件 -v: 显示详细输出，列出被添加到归档中的文件 -f: 指定归档文件的名称 1 tar -czvf archive.tar.gz directory 列出归档文件中的内容：列出名为 archive.tar 的归档文件中包含的所有文件和目录。\n-t: 列出归档文件中的内容 -v: 显示详细输出，列出归档文件中的所有文件和目录 -f: 指定要列出内容的归档文件的名称 1 tar -tvf archive.tar 追加文件到已存在的归档中：将名为 newfile 的文件添加到已存在的名为 archive.tar 的归档文件中。\n-r: 向已存在的归档中追加文件 -v: 显示详细输出，列出被添加到归档中的文件 -f: 指定已存在的归档文件的名称 1 tar -rvf archive.tar newfile 创建一个经过 gzip 压缩的归档文件：打包 directory 目录下的所有文件和子目录，并使用 gzip 压缩，生成名为 archive.tar.gz 的归档文件。\n-z: 表示要使用 gzip 进行压缩。 -c: 表示创建新的归档文件。 -v: 表示详细输出，列出被添加到归档中的文件。 -f: archive.tar.gz: 指定归档文件的名称为 archive.tar.gz。 1 tar -zcvf archive.tar.gz directory 解压一个已经被 gzip 压缩的归档文件：解压 example.tar.gz 文件，并在当前目录下恢复其中包含的文件和目录。\n-z: 表示要使用 gzip 解压归档文件。 -x: 表示解压操作。 -v: 表示详细输出，列出被解压的文件。 -f: example.tar.gz: 指定要解压的归档文件的名称为 example.tar.gz。 1 tar -zxvf example.tar.gz 其他命令 详情请看：Linux命令大全\n","date":"2025-09-27T23:10:09+08:00","permalink":"https://YLine-hub.github.io/p/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","title":"Linux常用指令"},{"content":"CentOS7.6找回密码 通过单用户模式修改root密码，因为单用户模式不需要账号登陆\n在开机界面时按下e，进入编辑模式 在截图位置，添加rw single init=/bin/bash，然后按ctrl+x引导系统，进入单用户模式 然后输入passwd来重置root密码 1 passwd 在此处分别输入两次新密码，这里不会有东西显示。\n其中乱码部分是因为设置的系统为中文，这里无法显示。\n若是英文的话，修改成功以后这里会显示successfully 输入touch /.autorelabel更新selinux信息 1 touch /.autorelabel 运行exec /sbin/init来重启系统 1 exec /sbin/init 重新用新密码登陆即可 ","date":"2025-09-27T17:37:30+08:00","permalink":"https://YLine-hub.github.io/p/centos7.6%E6%89%BE%E5%9B%9E%E5%AF%86%E7%A0%81/","title":"CentOS7.6找回密码"},{"content":"日语翻译 各种小写输入方法 ぇ、ェ： l（小写L） + e\nぃ、ィ： l（小写L） + i\nぉ、ォ： l（小写L） + o\nXshell 输入gnome-session -version时出现弹窗 生词 転送（てんそう）：转送 要求（ようきゅう）：要求 処理（しょり）：处理 ソフトウェア：software 软件 インストール：install 安装 プログラム：program 程序；计划；节目 実行（じっこう）：实行 直接（ちょくせつ） 体験版（たいけんばん） ダウンロード：download 下载 セッション：session / ˈseʃ(ə)n / 会话；会议；会期 プロパティ：property / ˈprɑːpərti / 属性；特性；财产 接続（せつぞく）：连接 トンネリング：tunneling / ˈtʌnlɪŋ / n、隧道效应；开挖隧道 ページ：page 页；页面 オフ：off 关闭；休息 オプション：option / ˈɑːpʃ(ə)n / 选择 メッセージ：message　信息；消息；短信 フォワーディング： forwarding 转发 フォワード： forward / ˈfɔːrwərd / 转发 翻译的句子 X11転送要求を処理するには、Xmanagerソフトウェアが必要です。 Xmanagerをインストールすると、Xtermやgonome-terminalなどのX11プログラムをXshellから実行し、Windowsで直接使用することができます。 Xmanager体験版を今すぐダウンロードしますか？ （セッションプロパティ　-\u0026gt; 接続　-\u0026gt; SSH -\u0026gt;　トンネリングページでX11転送オプションをオフにすることで、このメッセージをオフにすることができます）\n翻译 对于处理X11的转发请求，Xmanager软件是必须的。 安装Xmanager就能直接在windows中使用，通过Xshell运行Xterm、gonome-terminal等X11程序。 现在马上下载Xmanager体验版吗？ （在 会话属性-\u0026gt;连接-\u0026gt;SSH-\u0026gt;开启隧道页面 中 用关闭X11转发选项，能够关闭这个消息）\n关闭该消息 右键プロパティ 点击トンネリング 关闭X11转发 再次输入没有信息弹出 Xshell的重新连接 重新连接服务器 1 reconnect VMware 点击下面叉叉关闭虚拟机时 生词 パワーオン：power on 仮想（かそう）：虚拟；假想 マシン：machine 机器；机械 引き続き（ひきつづき）：继续；连续 バックグラウンド：background 背景；幕后 サスペンド：suspend 暂停；中止；悬挂 语法 Vた後で：之后；然后；之后接着 ～たり～たり：又\u0026hellip;又\u0026hellip;；或\u0026hellip;或\u0026hellip;；有时\u0026hellip;有时\u0026hellip; 翻译的句子 「Centos　test」は現在パフーオン状態です。 仮想マシンを引き続きバックグラウンドで実行したり、サスペンドした後で使用したり、今すぐパフーオフしたりできます。 サスペンド パフーオフ バックグラウンドで実行 キャンセル\n翻译 centos test现在时开机状态。 能够继续在幕后运行虚拟机，或者现在暂停之后再使用，或者现在马上关机。 暂停 关机 挂起运行 取消\n安全中心添加排除项 生词 プライバシー：privacy 隐私；私密 セキュリティ：security 安全；防护 ウイルス：virus 病毒 脅威（きょうい）：威胁 防止（ぼうし）：防止；预防 除外（じょがい）：排除；不包括；例外 追加（ついか）：增加；追加；补充 削除（さくじょ）：删除；消除；取消 項目（こうもく）：项目 デバイス：device 设备 脆弱（ぜいじゃく）：脆弱；易碎；不牢固 含む（ふくむ）：包含 スキャン：扫描；浏览；审查 操作 打开设置 按win键，在搜索栏中输入：設定（せってい） 打开设置，点击：プライバシーとセキュリティ 点击：Windows セキュリティ 点击：Windows セキュリティを開く，打开windows安全中心 在Windows　セキュリティ中，点击：ウイルスと脅威の防止 点击ウイルスと脅威の防止の設定下的設定の管理 找到除外，点击下面的除外の追加または削除 点击除外の追加来添加排除项 翻译的句子 除外 Microsoft Defender ウイルス対策は、除外されたアイテムをスキャンしません。除外された項目には、デバイスを脆弱にする脅威が含まれている可能性があります。 除外の追加または削除\n翻译 排除项 Microsoft Defender 应对病毒是不会扫描排除的项目。对排除的项目来说，可能包含使设备脆弱的威胁。 增加或删除排除项\n","date":"2025-09-27T14:31:19+08:00","permalink":"https://YLine-hub.github.io/p/%E7%94%B5%E8%84%91%E6%97%A5%E8%AF%AD%E5%8C%96%E4%BD%BF%E7%94%A8-%E6%97%A5%E8%AF%AD%E7%BF%BB%E8%AF%91/","title":"电脑日语化使用 日语翻译"},{"content":"Linux入门 Linux简介 介绍 linux是一个开源、免费的操作系统，其稳定性、安全性、处理多并发已经得到业界的认可，目前很多中型，大型甚至是集群项目都在使用linux，很多软件公司考虑到开发成本都首选linux，在中国软件公司得到广泛的使用。 Linux发行版 Ubuntu Fedora Debian Arch Linux Suse CentOS RedHat 国产： Deepin Ubuntu Kylin StartOS Nova Linux网络连接方式 桥接模式（Bridge Mode） 将虚拟机直接连接到宿主机所在的物理网络中，虚拟机拥有与宿主机相同的网络环境。\n特点\n虚拟机与宿主机处于同一网段。 虚拟机拥有独立的真实IP地址。 虚拟机可以直接与外部网络通信。 优点：\n处于同一网段，虚拟系统可以和处于同网段的外部系统通讯。\n支持高级网络功能，如VLAN、QoS和安全策略。\n缺点：\n容易造成IP冲突，因为同一个网段最多255个IP地址。\n缺乏隔离，可能导致不必要的广播流量和潜在的安全风险。\n示例\n假设宿主机的IP地址为192.168.1.10，虚拟机的IP地址为192.168.1.22，两者处于同一网段。\n1 2 # 桥接模式下虚拟机的网络配置 ifconfig eth0 192.168.1.22 netmask 255.255.255.0 NAT模式（Network Address Translation） NAT模式通过宿主机的IP地址与外部网络通信，虚拟机的IP地址由宿主机的虚拟网络提供。\n特点\n虚拟机与宿主机不在同一网段。 虚拟机通过宿主机的网关访问外部网络。 外部网络无法直接访问虚拟机。 优点：\n简化网络管理，避免IP冲突。\n提供了一定的安全性，因为内部网络与外部网络隔离。\n缺点：\n内部设备无法直接被外部访问。\n可能会增加网络延迟，因为需要进行地址转换。\n示例\n假设宿主机的IP地址为192.168.1.10，虚拟机的IP地址为192.168.2.3。\n1 2 # NAT模式下虚拟机的网络配置 ifconfig eth0 192.168.2.3 netmask 255.255.255.0 主机模式（Host-Only Mode） 主机模式下仅允许虚拟机与宿主机之间的通信，无法直接访问外部网络。\n特点\n虚拟机与宿主机处于同一网段。 虚拟机无法直接访问外部网络。 适用于隔离环境的开发和测试场景。 优点：\n提供了一个与物理网络隔离的虚拟网络环境，适合用于开发和测试。\n提高了安全性，因为虚拟机无法直接访问外部网络。\n缺点：\n无法直接访问外部网络，需要通过宿主机进行代理或路由。 示例\n假设宿主机的IP地址为192.168.56.1，虚拟机的IP地址为192.168.56.101。\n1 2 # 仅主机模式下虚拟机的网络配置 ifconfig eth0 192.168.56.101 netmask 255.255.255.0 Linux目录结构 树状目录结构 Linux文件系统采用层级式树状目录结构，在此结构中的最上层是根目录”/“，然后再次目录下创建其他目录。 Linux的基本理念：一切皆文件 目录介绍 /dev：（Device）存放Linux的外部设备，将硬件以文件的形式存放在该目录下。\n/lib：（Library）存放着系统最基本的动态连接共享库，类似于 Windows 里的 DLL 文件。\n/selinux：Redhat/CentOS特有的目录，Selinux是一个安全机制，类似windows的防火墙，但是这套机制比较复杂，这里存放selinux的相关文件。\n/tmp：（temporary）存放临时文件。\n/lost+found：一般是空的，当系统非法关机后，这里就存放了一些文件。\n/run：临时文件系统，存储系统启动以来的信息。重启时，这个目录下的文件应该被删掉或清除。/var/run 目录，应该让它指向 run。\n重要且尽量别动 /etc：（Etcetera）存放系统管理的配置文件和子目录。\n/bin：（Binaries） 存放常用命令。\n/sbin：（Superuser Binaries）存放超级管理员使用指令。\n/usr/bin：系统用户使用的命令。\n/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。\n重点目录 /boot：存放启动Linux时的一些核心文件，包括连接文件以及镜像文件。\n/home：用户主目录，在 Linux 中，每个用户都有一个自己的目录，目录名为用户账号名。\n/media：自动识别U盘、光驱等设备，识别后会挂载到这个目录下。\n/mnt：让用户临时挂载别的文件系统的，可以将光驱挂载在/mnt/ 上。\n/opt：（optional）给主机安装软件的目录。\n/root：超级权限者的用户主目录。\n/usr：（unix system resources）用户的很多应用程序和文件都放在这个目录下，类似于windows的program files目录。\n/usr/src：内核源代码默认的放置目录。 /var：（variable）存放经常修改的数据。如日志文件。\n以下目录尽量别动 /sys：Linux2.6内核后出现了新文件系统 sysfs 。\nsysfs 集成了3种文件系统的信息：针对进程信息的 proc 、针对设备的 devfs 、针对伪终端的 devpts 。\n/srv：存放一些服务启动之后需要提取的数据。\n/proc：（Processes）存储当前内核运行状态的特殊文件，是一个虚拟的目录，是系统内存的映射，可以通过访问这个目录来获取系统信息。\n该目录的内容在内存里，也可以直接修改其中某些文件，如可以通过下面的命令来屏蔽主机的ping命令： 1 echo 1 \u0026gt; /proc/sys/net/ipv4/icmp_echo_ignore_all Linux的运行级别 常用单词 rescue / ˈreskjuː / v、n、营救； multi / ˈmʌlti / pref、多 graphical / ˈɡræfɪkl / adj、绘画的；计算机图形的 isolate / ˈaɪsəleɪt / v、孤立，分离；单独考虑 adj、孤独的，孤立的 systemctl （ctl是 control 的缩写） 运行级别分类 运行级别 说明 适用环境 0 关机poweroff.target 系统关闭时使用 1 单用户模式rescue.target 系统维护或故障修复时使用（找回丢失密码） 2 多用户无网络模式 适用于网络功能不重要的场景 3 多用户有网络模式（常用）multi-user.target 适用于服务器环境 4 未定义（通常由系统自定义） 由系统或用户自定义功能 5 图形界面模式（常用）graphical.target 适用于桌面环境 6 重启reboot.target 系统重启时使用 运行级别配置文件：/etc/inittab (旧版本) 运行级别配置文件：/lib/systemd/system目录下的xxx.target文件(CentOS7以上) 常见Linux运行级别差异 系统版本 运行级别0 运行级别1 运行级别2 运行级别3 运行级别4 运行级别5 运行级别6 CentOS 7 关机 单用户模式 多用户模式 多用户模式 多用户模式 图形界面模式 重启 Ubuntu 关机 单用户模式 多用户模式 多用户模式 未定义 图形界面模式 重启 Slackware 关机 单用户模式 多用户模式 图形界面模式 未定义 未定义 重启 运行级别相关指令 查看当前运行级别 1 2 3 4 5 # 查看当前运行级别 runlevel # 查看默认运行级别（CentOS7以上） systemctl get-default 切换运行级别 1 2 3 4 5 6 7 # 适用于老旧系统 init 3 # 切换到运行级别3，字符界面 init 5 # 切换到运行级别5，图形界面 # 适用于现代系统 （CentOS7以上） systemctl isolate multi-user.target # 切换到运行级别3 systemctl isolate graphical.target # 切换到运行级别5 切换图形界面 切换图形界面 1 systemctl isolate graphical.target 发现并没有切换过去\n查看是否安装 1 rpm -qa | grep gnome-desktop 安装图形化界面 1 yum groupinstall \u0026#34;GNOME Desktop\u0026#34; \u0026#34;Graphical Administration Tools\u0026#34; 再次切换到图形化界面 1 systemctl isolate graphical.target 虚拟机已经成功切换到图形界面\n如果要设置默认启动图形化界面 1 systemctl set-default graphical.target ","date":"2025-09-26T17:30:21+08:00","permalink":"https://YLine-hub.github.io/p/linux%E5%85%A5%E9%97%A8/","title":"Linux入门"},{"content":"Centos打开80端口 查看端口是否开启 1 firewall-cmd --query-port=80/tcp 开启80端口，permanent永久，重启以后端口还会开启，若不加的话，重启以后端口要重新打开 单词：permanent / ˈpɜːrmənənt / adj.永久的 1 firewall-cmd --zone=public --add-port=80/tcp --permanent 重启防火墙，要重启防火墙后开启端口才会生效 1 firewall-cmd --reload ","date":"2025-09-26T17:22:53+08:00","permalink":"https://YLine-hub.github.io/p/centos%E6%89%93%E5%BC%8080%E7%AB%AF%E5%8F%A3/","title":"Centos打开80端口"},{"content":"VMware的Centos安装VMwareTools VMwareTools镜像准备 （1）VMware Tools 安装VMware Tools VMware安装VMTools的DVD 点击设置 添加一个DVD 使用VMware Tools镜像 启动centos 将VMTools挂载在虚拟机上 观察磁盘分区 1 lsblk 发现VMTools在磁盘sr0上\n创建一个目录作为挂载点 1 mkdir /media/dvd 将dvd挂载到创建的目录下 1 mount /dev/sr0 /media/dvd 查看dvd中的内容 1 ll /media/dvd 成功挂载到dvd目录下\n安装 将VMwareTools-10.3.26-22085142.tar.gz，复制到/opt目录下并命名为vm.tar.gz 1 cp /media/dvd/VMwareTools-10.3.26-22085142.tar.gz /opt/vm.tar.gz 在/opt目录下查看文件，并解压vm.tar.gz 1 2 3 cd /opt ll tar -zxvf vm.tar.gz 进入vmware-tools-distrib目录，并输入./vmware-install.pl尝试安装 1 2 3 cd vmware-tools-distrib/ ll ./vmware-install.pl 出现报错：-bash: ./vmware-install.pl: /usr/bin/perl: bad interpreter: No such file or directory，表明未安装编译环境\n安装编译环境 1 yum -y install perl gcc make kernel-headers kernel-devel 安装完成后再次尝试安装，安装时一直回车即可 1 ./vmware-install.pl 出现问题：The path \u0026quot;\u0026quot; is not a valid path to the 3.10.0-693.el7.x86_64 kernel headers\nctrl+c退出安装，使用yum更新再次重新安装 1 2 yum -y update ./vmware-install.pl 安装完成后，可以通过以下命令检查 VMware Tools 是否正常运行： 1 vmware-toolbox-cmd -v ","date":"2025-09-26T16:24:54+08:00","permalink":"https://YLine-hub.github.io/p/vmware%E7%9A%84centos%E5%AE%89%E8%A3%85vmwaretools/","title":"VMware的Centos安装VMwareTools"},{"content":"使用yum进行安装软件时出现报错：curl#6 - \u0026ldquo;Could not resolve host: mirrorlist.centos.org; Unknown error\u0026rdquo; 备份默认源文件 1 2 sudo mkdir -p /etc/yum.repos.d/backup sudo mv /etc/yum.repos.d/CentOS-*.repo /etc/yum.repos.d/backup/ 下载阿里云源文件 1 2 3 4 5 # 基础源文件 sudo curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo # 下载EPEL扩展源（可选） sudo curl -o /etc/yum.repos.d/epel.repo https://mirrors.aliyun.com/repo/epel-7.repo 清理并重建yum缓存 1 2 yum clean all yum makecache fast 检验是否更新，查看仓库列表 1 sudo yum repolist 再次安装已经能正常安装 ","date":"2025-09-26T16:12:03+08:00","permalink":"https://YLine-hub.github.io/p/linux%E6%9B%B4%E6%8D%A2yum%E6%BA%90%E4%B8%BA%E9%98%BF%E9%87%8C%E4%BA%91%E6%BA%90/","title":"Linux更换yum源为阿里云源"},{"content":"创建第一个Centos虚拟机 软件准备 （1）VMware Download VMware Workstaion Pro（Win/Linux）\nVMware Fusion (Mac) （2）Centos 7.6 ISO （清华源） （3）xshell 创建虚拟机 创建虚拟机 自定义（高级） 之后选择iso 选择Linux3.x\nCentos 7系列对应Linux3.x\nCentos 8系列对应Linux4.x\n设置虚拟机名和安装路径 选择2核2G 选择15G最大容量 初次开机前先对虚拟机进行设置 不需要声音就将其移除即可 CD/DVD选择自己下载的Centos7.6 iso镜像 点击ok后启动 安装Centos 选择安装Centos 选择自己需要的语言并进入 设置时间 设置分区 点击自己配置，后点击Done 配置后点击Done，然后点击接受改变 配置网络 注意记住ip，若没记住进入虚拟机后输入hostname -i 也可也查询ip 配置完成，点击安装 在等待安装时，分别设置root用户密码和第一个用户账户 创建好账号以后就可以等待安装了 安装完成后点击重启 xshell 远程连接centos 进入Centos后查询ip 1 hostname -i 在xshell中点击新建 输入服务器名称和ip后点击连接 点击保存 输入用户名和密码 连接成功 ","date":"2025-09-26T15:04:30+08:00","permalink":"https://YLine-hub.github.io/p/%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAcentos%E8%99%9A%E6%8B%9F%E6%9C%BA/","title":"创建第一个Centos虚拟机"},{"content":"github自动部署 创建新的仓库-项目主仓库 创建项目主仓库，存放项目源码，并将其设置为私有仓库 将不需要上传的文件忽略 在根目录下创建文件.gitignore\n1 2 3 4 public resources .hugo_build.lock hugo.exe 上传程序代码 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin https://github.com/YLine-hub/hugo-dev.git git push -u origin main 移除错误上传文件 突然发现多上传了hugo.exe，这时候就需要将它移除\n移除hugo.exe 1 git rm --cached hugo.exe 重新提交代码并推送 1 2 git commit -m \u0026#34;移除hugo.exe\u0026#34; git push -u origin main 自动部署 官方文档：hugo:Host on GitHub Pages\n(1)前往Settings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens，创建一个token，用于上面传到仓库\n(2)设置无限时间，作用范围选择repo和workflow (3)之后点击生成，获取token (4)使用注入变量注入token\n到项目仓库下，点击Settings 点击Secrets and variables，里面的Actions 创建一个新的环境变量TOKEN (5)在hugo主文件创建一个.githubb/workflows/xxxx.yaml文件，将以下内容复制进入，具体详情：查看【Github Action文档】\nhugo_deploy.yaml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 name: deploy # 代码提交到main分支时触发github action on: # 监听，当推送到分支main时将会自动触发 push: branches: - main jobs: deploy: runs-on: ubuntu-latest # 运行在ubuntu的最新版本上 steps: # 运行了四个脚本 - name: Chekout uses: actions/checkout@v4 # 比如该脚本来自 https://github.com/actions/checkout with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; # 安装的版本为最新 extended: true # 并且带有extended - name: Build Web # 生成静态页面 run: hugo -D # 生成脚本 - name: Deploy Web # 部署到静态页面仓库 uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.你的token变量名 }} EXTERNAL_REPOSITORY: 你的github名/你的仓库名 PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy # 提交信息 配置以下信息 1 2 3 4 5 6 7 8 9 10 jobs: ...... - name: Deploy Web # 部署到静态页面仓库 uses: peaceirls/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.TOKEN }} EXTERNAL_REPOSITORY: YLine-hub/YLine-hub.github.io PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy # 提交信息 提交代码 1 2 3 git add . git commit -m \u0026#34;update\u0026#34; git push 查看仓库是否运行了代码 运行失败，发现仓库名打错了，重新输入并上传 再次进入action，代码正在运行 运行成功以后，对本地和线上页面进行比较，发现还没更新 查看仓库以后，发现原来设置的仓库错了 恢复仓库 (1)查看历史版本 1 git relog/log (2)强制回滚历史版本 1 git reset 82c1130af45eeee3930b3d2e403458282f9f0296 (3)提交 1 git push origin main --force --force 为强制提交\n仓库回到历史版本\n(4)修改完代码以后重新提交，修改成功 ","date":"2025-09-25T19:34:37+08:00","permalink":"https://YLine-hub.github.io/p/github%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo/","title":"github自动部署hugo"},{"content":"stack自主配置 注：官方文档：stack-config\n核心配置文件hugo.yaml 语言配置 1 2 3 4 # Theme i18n support # Available values: ar, bn, ca, de, el, en, es, fr, hu, id, it, ja, ko, nl, pt-br, th, uk, zh-cn, zh-hk, zh-tw // 设置默认中文 DefaultContentLanguage: zh-cn 刷新后，界面默认变成中文\n建议：若默认语言为中文时，设置为true 1 2 3 # Set hasCJKLanguage to true if DefaultContentLanguage is in [zh-cn ja ko] # This will make .Summary and .WordCount behave correctly for CJK languages. hasCJKLanguage: true 配置国际化语言 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 languages: en: languageName: English title: Example Site weight: 1 params: sidebar: subtitle: Example description zh-cn: languageName: 中文 title: 演示站点 weight: 2 params: sidebar: subtitle: 演示说明 ar: languageName: عربي languagedirection: rtl title: موقع تجريبي weight: 3 params: sidebar: subtitle: وصف تجريبي 目前我只留下中文，同时国际化选项被去除 1 2 3 4 5 6 7 8 languages: zh-cn: languageName: 中文 title: 演示站点 weight: 2 params: sidebar: subtitle: 演示说明 该处title和subtitle分别能够修改这两处 1 2 3 4 5 6 7 8 languages: zh-cn: languageName: 中文 title: りんぼの個人ブログ weight: 2 params: sidebar: subtitle: 每天都要努力学习 设置图标\n推荐站点：free icons 下载以后，将图标名称改为favicon.ico，并将其放在static文件夹下 配置图标路径 1 2 3 params: ...... favicon: ./favicon.ico # e.g.: favicon placed in `static/favicon.ico` of your site folder, then set this field to `/favicon.ico` (`/` is necessary) 配置完后使用ctrl+f5进行强制刷新，就能看到图标出现了 日期格式化配置 当前日期格式:\n1 2 3 dateFormat: published: Jan 02, 2006 lastUpdated: Jan 02, 2006 15:04 MST 若要改成yyyy-MM-dd格式，只需要如下设置\n1 2 3 dateFormat: published: 2006-01-02 lastUpdated: Jan 02, 2006 15:04 MST 配置emoji 1 2 3 sidebar: emoji: 🏖️ ...... 设置头像 由于150x150的尺寸，不过由于自动缩放，所以只需要找等比例头像即可，将原先的头像名称复制给他并，放在dev/assets/img文件夹下 这时，头像也变成自己需要的头像\n关闭阅读时间和license 1 2 3 4 5 6 7 article: math: false toc: true readingTime: false # 关闭阅读时间啊 license: enabled: false # 关闭license default: Licensed under CC BY-NC-SA 4.0 关闭评论 单词：disqus(读作discuss) 留言功能， discuss 讨论，utterance 言论；表达\n1 2 3 comments: enabled: false # 关闭评论 provider: disqus 关闭标签云 1 2 3 4 5 6 7 8 9 10 11 12 13 14 widgets: homepage: - type: search # 搜索 - type: archives params: limit: 5 - type: categories # 分类 params: limit: 10 # - type: tag-cloud # params: # limit: 10 page: - type: toc 关闭github与twitter，等后期需要再加上 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ### Custom menu ### See https://stack.jimmycai.com/config/menu ### To remove about, archive and search page menu item, remove `menu` field from their FrontMatter # 注释掉，目前没啥用 # menu: # main: [] # social: # - identifier: github # name: GitHub # url: https://github.com/CaiJimmy/hugo-theme-stack # params: # icon: brand-github # - identifier: twitter # name: Twitter # url: https://twitter.com # params: # icon: brand-twitter 若需要这块功能的图标可以在：https://tabler.io/icons 找\n创建第一篇文章 所有文章放在/dev/content/post下\n创建第一篇文章 1 hugo new content post/myFirstBlog/index.md 创建后自动在文件夹中生成\n","date":"2025-09-25T16:19:14+08:00","permalink":"https://YLine-hub.github.io/p/stack-config/","title":"Stack Config"},{"content":"hugo+github搭建博客 下载hugo 进入hugo官网：hugo 点击github 找到历史版本 下载windows版本（最下面） 安装hugo 将下载的压缩包解压 在当前目录下打开cmd 创建项目 1 hugo new site dev 将hugo.exe复制到文件夹内 使用cmd进入文件夹中 1 cd dev 启动服务 1 hugo server -d 打开链接 http://localhost:1313/\n安装主题 在官网点击Themes 选择自己喜欢的主题并下载 将文件放在根目录下的themes文件夹中并解压 exampleSite为样例文件夹 将里面的content和hugo.yaml复制到根目录下 删去post下的rich-content文件夹，原因：其中引用的youtube中的视频，会导致超时 打开配置文件 hugo.yaml 删去配置文件hugo.toml\n根据主题名字修改文件夹名 重启服务 上传github 在github创建仓库 在hugo.yaml修改基础路径 重新生成一下文件 1 hugo -D 在根目录下生成的public，就是我们需要的生成的静态目录 命令行进入public文件夹下 根据github提供的命令上传文件 1 2 3 4 5 6 git init // 初始化git git add . // 将全部添加到本地仓库 git commit -m \u0026#34;first commit\u0026#34; // 提交 git branch -M main // 设置main git remote add origin https://github.com/YLine-hub/YLine-hub.github.io.git // 设置仓库地址 git push -u origin main // 推送到仓库 推送时出现报错，连接服务器失败 原因：经过查阅资料后，发现这是由于在使用 Git 时启用了网络代理，导致 Git 改变了默认端口，从而无法连接到 GitHub。因此，我们需要手动配置 Git 的代理端口来解决该问题。\n查看代理端口 \u0026ndash; 在wifi下，选择proxy \u0026ndash; 选择使用一个代理服务器后的set up \u0026ndash; 找到代理端口 打开命令行\n打开命令行（如 CMD 或 Git Bash），输入以下命令为 Git 配置 HTTP 和 HTTPS 的代理：\n1 2 git config --global http.proxy http://127.0.0.1:7890 git config --global https.proxy http://127.0.0.1:7890 再次提交代码 再次出现报错\n打开魔法，之后再次提交 使用账号登陆 双重验证 连接 同时代码上传成功 打开github，发现代码正常 开启静态页面 点击setting下的pages 选择主分支下的root，并点击保存 出现地址，就说明已经成功了 使用该链接就能进入网站中 ","date":"2025-09-25T15:58:33+08:00","permalink":"https://YLine-hub.github.io/p/hugo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","title":"hugo+github搭建博客"}]