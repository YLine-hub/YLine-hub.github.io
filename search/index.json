[{"content":"Mac和Win实现文件互传 Mac连接Win共享文件夹 打开Finder，点击菜单栏的移動，选择サーバへ接続 接続（せつぞく）：连接\n在红框内输入smb:// + ip，然后点击接続 然后分别输入win登陆用的用户名和密码，再点击接続 选择共享文件夹再点击ok 就弹出了win的共享文件夹 mac创建共享文件夹 点击左上角的苹果按钮，选择システム設定 在按边栏中选择一般，再点击共有 开启ファウル共有，再点击右边的叹号进入设置共享文件夹 点击左边的+号添加共享文件夹 选择要共享的文件夹再点击追加 点击添加的文件夹，再点击すべての人后面的読み出しのみ 选择読み/書き 设定完成以后点击完了 在终端输入ifconfig，找到ip ","date":"2025-10-22T21:31:57+08:00","permalink":"https://YLine-hub.github.io/p/macmac%E5%92%8Cwin%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%BA%92%E4%BC%A0/","title":"[Mac]mac和win实现文件互传"},{"content":"nginx 基础 nginx基础配置 最小配置文件 文件位置 默认位置 1 /usr/local/nginx/conf/nginx.conf 文件内容 nginx.conf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; # \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; # \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { root html; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache\u0026#39;s document root # concurs with nginx\u0026#39;s one # #location ~ /\\.ht { # deny all; #} } # another virtual host using mix of IP-, name-, and port-based configuration # #server { # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / { # root html; # index index.html index.htm; # } #} # HTTPS server # #server { # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / { # root html; # index index.html index.htm; # } #} } 简化文件（去掉所有注释） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 # 工作进程个数 为1 worker_processes 1; events { # 每个worker进程能创建1024个连接 worker_connections 1024; } http { # 引入配置文件mime.types # mime.types 解析文件类型并以相应的方式去读取文件 # 作用：告诉浏览器以什么方式去打开什么文件 include mime.types; # default_type表示默认类型，及如果这种类型不包含在mime.types 里面，就以application/octet-stream传输给我们的客户端（浏览器） default_type application/octet-stream; # sendfile：数据零拷贝 # 数据零拷贝：不需要复制和拷贝 # off : nginx复制一份文件，并读到应用程序内存中，再把数据复制给网络接口，最后发送出去 # on ： nginx推送给网络接口sendfile信号，网络接口直接读取文件，再发送出去 sendfile on; # 保持连接超时 keepalive_timeout 65; # 虚拟主机 vhost server { # 端口号 listen 80; # 域名、主机名 server_name localhost; # http://location/index.html location / { # 匹配页面的根目录 root html; # 默认页 index index.html index.htm; } # 发生服务器端错误时：500 502 503 504 # 跳转到 http://location/50x.html error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } 虚拟主机与域名解析 使用ip访问虚拟机的nginx 使用hosts文件解析域名 hosts文件位置[mac] mac:\n/private/etc/hosts hosts:\n1 2 3 4 5 6 7 8 9 ## # Host Database # # localhost is used to configure the loopback interface # when the system is booting. Do not change this entry. ## 127.0.0.1 localhost 255.255.255.255 broadcasthost ::1 localhost win:\nC:\\Windows\\System32\\drivers\\etc\\hosts 使用hosts解析虚拟机ip为域名 编辑hosts 1 sudo vim /etc/hosts 在hosts文件末尾添加以下内容 1 172.16.140.102 vm-2.com 使用浏览器打开vm-2.com nginx虚拟主机配置 配置两个网站 创建网站 创建项目目录 /www/book/index.html 1 this is a book web /www/vod/index.html 1 this is a vod web 配置hosts文件 模拟公网域名，给服务器添加两个二级域名 1 2 172.16.140.102 book.vm-2.html 172.16.140.102 vod.vm-2.html 配置nginx 在虚拟机中配置nginx 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 server { listen 80; server_name book.vm-2.com; location / { root /www/book; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } server { listen 80; server_name vod.vm-2.com; location / { root /www/vod; index index.html index.htm; } } nginx重新加载配置文件 1 systemctl reload nginx 浏览网站测试 serverName匹配规则 匹配顺序 从第一个server开始匹配，按顺序向下匹配，比如第一个server匹配的为book.vm-2.com，第二个server匹配的为*.vm-2.com。这时候请求的网址为test.vm-2.com，先会和第一个进行匹配，与book.vm-2.com匹配不上，就会向第二个server进行匹配，这时候与*.vm-2.com匹配上，就会请求第二个server的网页\n配置多个域名 1 2 3 4 5 6 7 8 9 10 server { listen 80; server_name vod.vm-2.com vod1.vm-2.com; location / { root /www/vod; index index.html index.htm; } } 通配符匹配 除了book.vm-2.com，全部匹配到第二个服务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 server { listen 80; server_name book.vm-2.com; location / { root /www/book; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } server { listen 80; # 通配符匹配 server_name *.vm-2.com; location / { root /www/vod; index index.html index.htm; } } 通配符结束匹配 www.vm-2.com匹配到第一个server，www.vm-2.com匹配到第二个server\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 server { listen 80; server_name www.vm-2.com; location / { root /www/book; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } server { listen 80; # 通配符结束匹配 server_name www.vm-2.*; location / { root /www/vod; index index.html index.htm; } } ","date":"2025-10-22T21:27:31+08:00","permalink":"https://YLine-hub.github.io/p/nginxnginx%E5%9F%BA%E7%A1%80/","title":"[Nginx]nginx基础"},{"content":"使用mac搭建第一个centos虚拟机 安装前置 VMware Fusion： VMware Download\nCentOS7镜像： Centos7-iso-quark\nCentOS9镜像(Linux 5.x)\n阿里源：CentOS9-arm-iso 清华源(推荐)：CentOS9-arm-iso CentOS10镜像(Linux 6.x)：\n清华源：CentO10-arm-iso 安装 配置虚拟机 点击新建 新規（しんき）：新规章；新建\n点击继续 イメージ：image 形象；图像；映像\n选择镜像路径并继续 选择linux-\u0026gt;Linux 5.x arm，然后点击继续 点击自定设置 カスタマイズ：customise 定制；个性化设置\n设置虚拟机名称并保存 分别修改处理器、内存和硬盘 プロセッサ：processor 处理器\nメモリ：memory 内存\nハードディスク：hard disk　硬盘\n选择2个处理器和2048m内存，然后点击すべてを表示返回全部 ハードディスク选择50G然后点击适用 適用（てきよう）：适用；应用\n选择完后就点叉叉关闭 启动虚拟机 点击中间的播放键 选择安装centos7 配置语言（使用默认英语即可），然后点击继续 这个界面分别要配置时区，硬盘，网络，root密码，用户 时区选择上海，然后配置当前时间\n硬盘选择custom，然后点击Done\n硬盘选择如下配置，然后点击Done 点击接受改变 网络自动获取即可，左下角的hostname可以自己设置，也可以不改 全部配置完之后点击开始安装 等待安装 使用shell连接linux服务器 登陆服务器以后查询ip 1 hostname -i ip : 172.16.140/128\n使用命令连接服务器 1 ssh -Y username@ip 输入密码（密码不会显示） 克隆虚拟机 フル：full全部的 作成（さくせい）：制作\n点击自己要克隆的虚拟机，选择仮想マシンー\u0026gt;フル　クローンを作成 设置虚拟机的名称然后保存到虚拟机目录下 将两台虚拟机打开，克隆的虚拟机ip是原本虚拟机的ip+1 如果想要设置静态ip：可以查看我的博客：Linux 网络配置 传输文件到Linux服务器 右键iterm 新建窗口 使用scp命令上传文件 常用参数：\n-r : 递归上传，常用上传文件夹及其子目录和文件 上传文件\n1 2 # scp 【本地文件路径】 【远程服务器用户名】@【远程服务器ip】:【服务器存放路径】 scp local_folder remote_username@remote_ip:remote_folder 上传文件夹 1 scp -r local_folder remote_username@remote_ip:remote_folder 使用scp命令下载文件 下载文件 1 2 #scp 【服务器用户名】@【服务器地址】：【服务器上存放文件的路径】【本地文件的路径】 scp remote_username@remote_ip:remote_folder local_folder 下载文件夹 1 scp -r remote_username@remote_ip:remote_folder local_folder 示例 上传一个文件到服务器 本地文件截屏 2025-09-10 14.41.41.40.png\n远程服务器172.16.140.129\n目录/home/lin\n1 scp 截屏2025-09-10\\ 14.41.40.png root@172.16.140.129:/home/lin 上传文件夹markdown到上述服务器 1 scp -r markdown root@172.16.140.129:/home/lin 下载/opt目录到本地 1 scp -r root@172.16.140.129:/opt /Users/line/project/linux ","date":"2025-10-22T21:24:28+08:00","permalink":"https://YLine-hub.github.io/p/macmac%E6%90%AD%E5%BB%BAcentos7/","title":"[Mac]mac搭建centos7"},{"content":"后台运行 临时后台运行相关命令 nohup\nsetid\n\u0026amp;\nscreen\n挂起、恢复进程 ctrl+z : 将正在执行的命令放到后台，并且处于暂停状态\njobs : 查看当前有多少在后台运行的命令\nfg : 将后台中的命令调回前台继续运行。\n1 2 # jobnumber为命令编号，而不是进程号 fg %jobnumber 1 fg 1 bg : 将后台暂停的命令，变成在后台继续执行\nkill\nkill %num (jobs查看job号) kill pid (ps查看进程号) ","date":"2025-10-22T21:21:24+08:00","permalink":"https://YLine-hub.github.io/p/linux%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%8C%82%E8%B5%B7%E6%81%A2%E5%A4%8D%E6%9C%AA%E5%AE%8C%E6%88%90/","title":"[Linux]后台进程运行、挂起、恢复(未完成)"},{"content":"nvm 配置国内镜像 配置nvm镜像 找到nvm目录下的setting.txt 淘宝镜像 1 2 node_mirror: https://npmmirror.com/mirrors/node/ npm_mirror: https://npmmirror.com/mirrors/npm/ 配置npm镜像 打开命令行输入 1 npm config set registry https://registry.npmmirror.com 将镜像配置复制到文件内 配置npm镜像 nvm常用命令 nvm查看可用版本号 1 2 3 nvm ls available # 或者 nvm list available 类型 说明 CURRENT 当前最新版本 LTS 长期支持版本 OLD STABLE 旧稳定版本 OLD UNSTABLE 旧非稳定版本 安装node 1 nvm install \u0026lt;version\u0026gt; 显示已安装的列表 1 2 3 nvm ls # 或者 nvm list 卸载指定版本node 1 nvm uninstall \u0026lt;version\u0026gt; 使用指定版本node 1 nvm use \u0026lt;version\u0026gt; ","date":"2025-10-22T20:36:07+08:00","permalink":"https://YLine-hub.github.io/p/windowsnvm%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F%E5%8F%8A%E4%BD%BF%E7%94%A8/","title":"[Windows]nvm配置镜像及使用"},{"content":"docker docker理念 一次镜像，处处运行。 docker是什么 Docker是基于Go语言实现的云开源项目。\nDocker的主要目标是“Build，Ship and Run Any App，Anywhere”，也就是通过对应组件的封装、分发、部署、运行的那个生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能呕做到“一次镜像，处处运行”。\nLinux容器技术的出现就解决了这样一个问题，而Docker就是在它的基础上发展过来的。将应用打成镜像，通过镜像成为运行在Docker容器上面的实例，而Docker容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。\n总结：解决了运行环境和配置问题的软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。\n容器与虚拟机 虚拟机 虚拟机：带环境安装的一种解决方案。它可以在一种操作系统里运行另一种操作系统。\n缺点： 资源占用多 冗余步骤多 启动慢 Linux容器 Linux容器：与系统其它部分隔离开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。\n对比 Docker容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统虚拟机则是在硬件层面实现虚拟化。与传统虚拟机相比，Docker优势体现为启动速度快，占用体积小。\nDocker与传统虚拟机：\n传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程； 容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。 每个容器之间相互隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。 docker作用 一次构建、随处运行。 更快速的应用交付和部署 更便捷的升级和扩缩容。 更简单的系统运维。 更高效的计算资源利用。 docker三要素 镜像（image）：一个只读的模板。镜像可以用来创建Docker容器，一个镜像可以创建很多容器。 容器（container）：用镜像创建的运行实例。 仓库（repository）：集中存放镜像文件的场所。 公开仓库：最大的公开仓库Docker Hub 私有仓库 镜像与容器 从面向对象角度 Docker利用容器独立运行的一个或一组应用，应用程序或服务运行在容器里，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。\n从镜像容器角度 可以把容器看作是一个简易版的Linux环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。\nCentOS7上安装docker CentOS9上安装docker 安装步骤 官方文档：Install Docker Engine on CentOS\n环境要求：CentOS Stream 9 或者 CentOS Stream 10\n删除老版本 1 2 3 4 5 6 7 8 sudo dnf remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 使用rpm仓库安装 生词： repository / rɪˈpɑːzətɔːri / n、仓库 步骤 安装仓库 1 sudo dnf -y install dnf-plugins-core 设置仓库源 国内源（推荐） 1 sudo dnf config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 官方源 1 sudo dnf config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 安装docker引擎 1 2 # 安装最新版本docker引擎 sudo dnf install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 配置国内镜像加速 1 vim /etc/docker/daemon.json 1 2 3 4 5 6 7 { \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://docker.m.daocloud.io\u0026#34;, \u0026#34;https://hub-mirror.c.163.com\u0026#34;, \u0026#34;https://mirrors.tuna.tsinghua.edu.cn/docker-ce/\u0026#34; ] } 开始docker引擎 1 sudo systemctl enable --now docker 验证 1 sudo docker version 第一个镜像 1 sudo docker run hello-world 报错 docker: Error response from daemon: Get \u0026ldquo;https://registry-1.docker.io/v2/\": dial tcp: lookup registry-1.docker.io on 172.16.140.2:53: no such host\n解决方法：配置DNS\n设置静态ip及dns:\n查看网络信息 1 ifconfig 可以看到网卡为ens160\n查找网络文件 1 2 # 在/etc目录文件匹配关键字\u0026#39;ens160\u0026#39;查找 grep -rnw \u0026#39;/etc\u0026#39; -e \u0026#39;ens160\u0026#39; 编辑网络配置文件 1 vim /etc/NetworkManager/system-connections/ens160.nmconnection 初始网络配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [connection] id=ens160 uuid=cda03551-52cb-3117-ac32-60f962d7c856 type=ethernet autoconnect-priority=-999 interface-name=ens160 timestamp=1760902922 [ethernet] [ipv4] method=auto [ipv6] addr-gen-mode=eui64 method=auto [proxy] 添加如下内容 1 2 3 4 [ipv4] ... address1=ip/24,gateway dns=dnsip1;dnsip2; 重新加载配置文件 1 nmcli c reload 启动ens160网卡 1 nmcli c up ens160 再次运行hello-world 1 docker run hello-world 卸载 阿里云镜像加速器配置 登陆阿里云，并点击控制台 在控制台中点击左上角的三横杠 在产品与服务中找到容器镜像服务 选择镜像工具下的镜像加速器 通过操作文档配置镜像加速 1 2 3 4 5 6 7 8 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u0026lt;\u0026lt;-\u0026#39;EOF\u0026#39; { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://********.mirror.aliyuncs.com\u0026#34;] } EOF sudo systemctl daemon-reload sudo systemctl restart docker 为什么docker会比虚拟机块 docker有着比虚拟机更少的抽象层 由于docker不需要Hypervisor（虚拟机）实现硬件资源虚拟化，运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。\ndocker利用的是宿主机的内核，而不需要加载操作系统OS内核 当新建一个容器时，docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较费事费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载OS，返回新建过程时分钟级别的。而docer由于直接利用宿主机的操作系统，则省略了返回过程，因此新建一个docker容器只需要几秒钟。\nDocker容器 虚拟机（VM） 操作系统 与宿主机共享OS 宿主机OS上运行虚拟机OS 存储大小 镜像小，便于存储和传输 镜像庞大（vmdk、vdi等） 运行性能 几乎无额外性能损失 操作系统额外的CPU、内存消耗 移植性 轻便、灵活，适应于Linux 笨重，与虚拟化技术耦合度高 硬件亲和性 面向软件开发者 面向硬件运维者 部署速度 速度快，秒级 较慢，10s以上 Docker常用命令 帮助启动类 启动类 1 2 3 4 5 systemctl start docker # 启动docker systemctl stop docker # 停止docker systemctl restart docker # 重启docker systemctl status docker # 查看docker状态 systemctl enable docker # 开机启动 帮助类 1 2 3 docker info # 查看docker概要信息 docker --help # 查看docker总体帮助文档 docker 具体命令 help # 查看docker命令帮助文档 镜像命令 查询本地镜像 1 docker images 列名 说明 REPOSITORY 表示镜像的仓库源 TAG 镜像的标签版本号 IMAGE ID 镜像ID CREATED 镜像创建时间 VIRTUAL SIZE 镜像大小 同一个仓库源有多个TAG版本，代表这个仓库源的不同个版本，我们使用REPOSITORY:TAG来定义不同的镜像。如果你不指定一个镜像的版本标签，例如你只使用ubuntu，docker将默认使用ubuntu:latest镜像\noptions 参数 说明 -a 列出本地所有的镜像（含历史映像层） -q 只显示镜像ID 列出所有镜像ID 1 docker images -qa 搜索仓库镜像 1 docker search INAEM（镜像名称） 参数 说明 NAME 镜像名称 DESCRIPTION 镜像描述 STARS 点赞数量 OFFICIAL 是否是官方的 AUTOMATED 是否是自动构建的 options:\n--limit N:只列出N个镜像，默认25个 查询前5个名称中有redis的镜像\n1 docker search --limit 5 redis 拉取镜像 下载最新版 1 docker pull \u0026lt;image-name\u0026gt; 下载指定版本 1 docker pull \u0026lt;image-name\u0026gt;[:TAG] 下载redis:6.0.8 生词 suppress / səˈpres / v、（武力）镇压；阻止（进程）；隐瞒（消息） verbose / vɜːrˈboʊs / adj、冗长的；啰嗦的 查看镜像/容器/数据卷所占空间 1 docker system df 列名 说明 TYPE 类型 TOTAL 总数 ACTIVE 正在使用数 SIZE 大小 RECLAIMABLE 可回收的磁盘空间大小 TYPE 说明 Images 镜像 Containers 容器 Local Volumes 本地卷（用于持久化数据） Build Cache 建缓存（用于加速 Docker 构建过程） 生词 reclaimable / rɪˈkleɪməbəl / adj、可回收的 volumes / ˈvɑːljəmz / n、体积，容量；卷 删除镜像 删除镜像 1 docker rmi INAME_or_IMAGEID options 删除单个镜像 1 docker rmi -f INAME_or_IMAGEID 删除多个镜像 1 docker rmi -f INAME1:TAG_or_IMAGEID INAME2:TAG_or_IMAGEID 删除全部镜像 1 docker rmi -f $(docker images -qa) 面试题 谈谈docker虚悬镜像是什么？ 是什么？ 仓库名、标签名都是\u0026lt;none\u0026gt;的镜像，俗称虚悬镜像dangling image\n容器命令 拉取镜像（ubuntu） 1 docker pull ubuntu 新建并启动容器 1 docker run [option] IMAGE [COMMAND] [ARG...] options 参数 说明 \u0026ndash;name=\u0026ldquo;NAME\u0026rdquo; 为容器指定一个名称 -d 后台运行容器并返回容器ID，也即启动守护式容器（后台运行） -i 以交互模式运行容器，通常与-t同时使用 -t 为容器分配一个伪输入终端，与-i同时使用，也即启动交互式容器（前台有伪终端，等待交互） -P 随机端口映射，大写P -p 指定端口映射，小写p docker启动ubuntu 1 2 # 启动ubuntu docker run ubuntu 启动后自动退出 原因：需要用伪终端交互打开\n1 2 3 4 # 使用伪终端交互使用ubuntu，并设置shell交互命令的接口(bin或者/bin/bash) # 在容器内使用bash命令 docker run -it ubuntu /bin/bash docker run -it ubuntu bash 查看docker正在运行的镜像 运行ubuntu并命名myu1 1 docker run -it --name=myu1 ubuntu bash 生词 -i : interactive / ˌɪntərˈæktɪv / adj、交互式的\n-t : tty 终端\nallocate / ˈæləkeɪt / v、分配\n查看容器 1 docker ps [options] options 参数 说明 -a show all containers -l show the latest created container -n show n last created containers -q only display container IDs 展示最后创建的容器 1 docker ps -l 展示正在运行的容器 1 docker ps 展示最后4个创建的容器 1 docker ps -n 4 只展示容器的ID 1 docker ps -q 生词 -q quiet / ˈkwaɪət / n/v、（使）安静 ； adj、安静的；沉默寡言的 退出容器 创建两个容器 1 docker run -it ubuntu bash 方式一：exit\nrun进去容器，exit退出，容器停止 退出容器 0a48ed6d8300\n发现运行中的容器0a48ed6d8300已经没了\n方式二：ctrl+p+q run进去容器，ctrl+p+q退出，容器不停止 使用ctrl+p+q，退出了容器，但是容器还在运行\n启动已经停止的容器 1 docker start CONTAINER_ID_OR_NAME 查看最后两个容器 1 docker ps -n 2 可以看到其中ID为0a48ed6d8300的状态已经停止了\n重启0a48ed6d8300 1 docker start 0a48ed6d8300 可以看到重启的容器状态已经是开启了\n重启容器 1 docker restart CONTAINER_ID_OR_NAME 停止容器 1 docker stop CONTAINER_ID_OR_NAME 强制停止容器 1 docker kill CONTAINER_ID_OR_NAME 删除已停止的容器 1 docker rm CONTAINER_ID 删除正在运行的容器 1 docker rm 0a48ed6d8300 1 2 Error response from daemon: cannot remove container \u0026#34;0a48ed6d8300\u0026#34;: container is running: stop the container before removing or force remove 来自daemon的错误响应：不能移除容器\u0026#34;0a48ed6d8300\u0026#34;，容器正在运行：移除之前停止这个容器或者强制移除 停止容器并删除 1 2 3 4 # 停止容器0a48ed6d8300 docker stop 0a48ed6d8300 # 删除容器0a48ed6d8300 docker rm 0a48ed6d8300 成功删除容器\n再次启动容器0a48ed6d8300 1 2 3 4 5 Error response from daemon: No such container: 0a48ed6d8300 Error: failed to start containers: 0a48ed6d8300 来自daemon的错误响应：没有这样的容器：0a48ed6d8300 错误：启动失败容器：0a48ed6d8300 强制删除容器3c64d193e546 1 docker rm -f 3c64d193e546 一次性删除多个容器 方式一 1 docker rm -f $(docker ps -a -q) 分析：\n1 2 # 查询所有容器，并只展示ID docker ps -a -q 1 2 # 将查询出来的容器IDs作为参数传给 docker rm -f docker rm -f $(docker ps -a -q) 方式二 1 docer ps -a -q | xargs docker rm 分析：\ndocker ps -a -q 查询出来的数据传给xargs，然后作为参数执行docker rm\n容器命令（重要） 下载镜像(redis) 1 docker pull redis 启动守护式容器（后台服务器） 在大部分的场景下，我们希望docker服务式在后台运行的，我们可以过-d指定容器的后台运行模式\n启动守护式容器 1 docker run -d \u0026lt;container_name\u0026gt; ubuntu前后台启动演示:\n使用镜像ubuntu以后台模式启动一个容器 1 docker run -d ubuntu 发现docker中没有运行中的容器\n查看docker容器运行（含历史映像） 1 docker ps -a 发现容器8d9e73743b1b已经退出了\n原因：Docker容器后台运行，就必须有一个前台进程。容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。\n这个是docker的机制问题，比如你的web容器，我们以nginx为例，正常情况下，我们配置服启动服务只需要启动响应式的service即可。例如service nginx start。但是，这样做，nginx为后台进程模式运行，就导致docker前台没有运行的应用，这样的容器后台启动后，就会立即自杀，因为他觉得他没事可做了。 所以，最佳的解决方案是，将你要运行的程序以前台进程的形式运行，常见就是命令行模式，表示我还有交互操作，别中断。\n前台运行ubuntu 1 docker run -it ubuntu redis前后台启动演示：\n前台交互式启动 1 docker run -it redis 如果不小心关掉，或者ctrl+c退出进程，redis就直接停止服务\n后台守护式启动 1 docker run -d redis 查看容器日志 语法 1 docker logs \u0026lt;container_id\u0026gt; 查看容器 1 docker ps 查看redis容器日志 1 docker logs a55b19d4ab06 查看容器内运行的进程 1 docker top \u0026lt;container_id\u0026gt; 查看redis容器内部运行的进程 1 docker top 查看容器内部细节 1 docker inspect \u0026lt;container_id\u0026gt; 查看redis容器内部细节 1 docker inspect 进入正在运行的容器并以命令行交互 方法一：docker exec\n语法 1 docker exec [options] \u0026lt;container_id\u0026gt; \u0026lt;command\u0026gt; 创建一个ubuntu 1 docker run -it ubuntu /bin/bash id为1fac0e86217b\n使用ctrl+p+q退出容器 查看正在运行的容器 1 docker ps 重新进入ubuntu容器 1 docker exec -it 1fac0e86217b /bin/bash 方法二：docker attach\n1 docker attach \u0026lt;container_id\u0026gt; 进入ubuntu容器 1 docker attach 1fac0e86217b docker exec和docker attach的区别\nattach直接进入容器启动命令的终端，不会启动新的进程用exit退出，会导致容器的停止。 exec是在容器中打开新的终端，并且可以启动新的进程，用exit退出，不会导致容器的停止。\ndocker exec docekr attach 可以看到使用exit退出后就没了\n可以看到容器处于停止状态\n推荐使用exec 进入正在运行的redis容器进行交互 查看容器id 1 docker ps 进入redis容器，使用/bin/bash 1 docker exec -it a55b19d4ab06 /bin/bash 使用redis客户端进入redis 1 redis-cli -p 6379 测试redis功能 退出容器 使用redis客户端打开redis容器 1 docker exec -it a55b19d4ab06 redis-cli 从容器内拷贝拷贝文件到主机上 语法 1 docker cp \u0026lt;container_id\u0026gt;:path destination_path 新建ubuntu 1 docker run -it ubuntu /bin/bash 在容器内创建a.txt文件 1 2 3 4 # 进入临时目录 cd /tmp # 创建a.txt文件 touch a.txt 复制文件a.txt到本地/opt目录下 path:/tmp/a.txt\n1 docker cp 006e879ee419:/tmp/a.txt /opt 查看拷贝的文件 1 ls /opt 导入导出容器 export 导入容器的内容流作为一个tar归档文件[对应import命令] 1 docker export [container_id] \u0026gt; [file_name].tar import 从tar包中的内容创建一个新的文件系统再导入为镜像[对应expor] 1 cat \u0026lt;file_name\u0026gt;.tar | docker import - \u0026lt;image_user\u0026gt;/\u0026lt;image_name\u0026gt;:\u0026lt;image_version\u0026gt; 案例 查询容器id 1 docker ps 导出ubuntu容器(默认导出到当前目录) 1 docker export 006e879ee419 \u0026gt; ubuntu_backup.tar 删除正在运行的ubuntu容器 1 docker rm -f 006e879ee419 导入容器 1 cat ubuntu_back.tar | docker import - yline/ubuntu:6.6.6 运行刚刚导入的镜像，并找到a.txt 1 docker run -it 7fd7d82b1ac0 /bin/bash 生词 detach / dɪˈtætʃ / v、使分离；脱离；派遣 override / ˌoʊvərˈraɪd / v、否决，推翻；比\u0026hellip;.更重要；n、（预算、薪金等）增加；（对决定等的）否决，撤销 sequence / ˈsiːkwəns / v、按顺序排列； n、顺序，次序 alias / ˈeɪliəs / n、别名 destination / ˌdestɪˈneɪʃ(ə)n / n、目的地 Docker镜像 镜像是什么 是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境（包括代码、运行时需要的库、环境变量和配置文件等），这个打包好的运行环境就是image镜像文件。\n只有通过这个镜像文件才能生成Docker容器实例（类似java中new出一个对象）\n","date":"2025-10-19T22:51:05+08:00","permalink":"https://YLine-hub.github.io/p/centos9docker%E5%9F%BA%E7%A1%80%E6%9C%AA%E5%AE%8C%E6%88%90/","title":"[CentOS9]docker基础(未完成)"},{"content":"Linux网络管理命令 netstat 简介 用于显示网络状态 语法 1 netstat [options] 常用参数 参数 含义 -n 不解析域名，以数字显示 -a 显示所有连线中的Socket -t 列出tcp网络封包的数据 -u 列出udp网络封包的数据 -p pid，显示进程号 -l 仅列出在监听的服务状态 -i 列出网卡信息 -r 列出路由表信息 列名分析 netstat -a 1 netstat -a | head 列名 含义 备注 proto(protocol) 网络连接的协议类型 如tcp、udp等 Recv-Q 接收socket(套接字)队列中的数据量 以字节为单位 Send-Q 发送socket(套接字)队列中的数据量 以字节为单位 Local Address 运行netstat命令的本地计算机地址 Foreign Address 与本机端口通信的外部eocket地址 State 每个服务网络连接的状态 netstat -r 1 netstat -r 列名 含义 备注 Destination 目标计算机的地址 Gateway 中间网关地址 Genmask 网络掩码 用于指定网络中的可用主机 Flags 标识路由类型 MSS 默认最大段大小 Window 默认窗口大小 irtt 发送信号并接收其确认的总时间 Iface 数据表将通过其路由的接口 netstat -i 1 netstat -i 列名 含义 备注 Iface 接口类型 MTU 最大传输单位 RX 接收数据包 TX 发送数据包 OK 无错误数据包 ERR 有错误数据包 DRR 丢包数量 OVR 数据包由于溢出而丢失 Fig 定义接口配置的标志 示例 显示系统网络状态的所有连接 1 netstat -a 显示系统网络状态的UDP连接信息 1 netstat -anu 显示网卡状态信息 1 netstat -i 显示网络路由表信息 1 netstat -r 查看关于sshd的PID值 1 netstat -p | grep ssh 使用管道符查看某个在运行的服务信息 1 nestat -antup | grep mysql 访问每种协议的统计信息 1 netstat -s ss 简介 显示套接字信息。（与netstat相似，速度更快更高效） 语法 filter : 过滤器\n1 ss [options] [filter] 基本参数 参数 含义 -n 不解析域名 -a 显示所有套接字 -l 仅显示监听状态的套接字 -o 显示TCP计时器信息 -e 显示详细的套接字信息 -m 显示socket的内存情况 -p 显示使用套接字的过程 -i 显示内部的TCP信息 -s 显示socket使用情况 -4 显示ipv4的套接字信息 -6 显示ipv6的套接字信息 -0 显示PACKET套接字信息 -t 显示TCP套接字信息 -u 显示UDP套接字信息 -d 显示DCCP套接字信息 -w 显示RAW套接字信息 -D 将原始TCP套接字信息转储到文件 -r 解析IP和端口号，解析主机名 列名分析 ss 1 ss | head -5 列名 含义 备注 Netid 网络标识符 State 每个服务的连接状态 Recv-Q 接收socket(套接字)队列中的数据量 以字节为单位 Send-Q 发送socket(套接字)队列中的数据量 以字节为单位 Local Address 运行本地的计算机地址 Port 服务端口 Peer Address 对等地址 常用命令 显示本地打开的所有端口 1 ss -l 显示每个进程具体打开的socket 1 ss -pl 显示所有tcp socket 1 ss -t -a 显示所有的udp socket 1 ss -u -a 显示所有已建立的SMTP连接 1 ss -o state established \u0026#39;( dport = :smtp or sport = :smtp )\u0026#39; 显示所有已建立的HTTP连接 1 ss -o state established \u0026#39;( dport = :http or sport = :http )\u0026#39; 找出所有连接X服务器的进程 1 ss -x src /tmp/.X11-unix/* 列出当前socket详细信息 1 ss -s 实例 列出已建立的连接 默认情况，只使用ss命令，不加任何参数的情况下，它会显示所有已建立连接的套接字列表信息 1 2 3 4 5 # 统计行数 ss | wc -l # 列出前三条 # 同 ss | head -3 ss | head -n 3 监听TCP协议的套接字信息 可以使用-l参数监听所有tcp协议的套接字内容 1 ss -lt 查看主机监听的端口 -n表示不解析域名，显示的是IP+端口的格式 1 ss -tnl 显示在运行进程的信息 需要使用到-p的参数，结合-tl是显示tcp协议的服务并且处于监听状态下的信息 1 ss -tlp 显示所有已经建立的信息 需要使用-a参数，表示显示所有的连接信息 1 ss -a | wc -l 还可以在加上-t -n参数使用 1 2 ss -ant ss -nt 显示套接字的使用信息 显示使用信息需要用到-s的参数 1 ss -s 匹配远程与本地地址和端口号 匹配远程地址和端口号 1 2 3 ss dst ip # 或者 ss dst ip:端口号 匹配本地端口和端口号 1 2 3 ss src ip # 或者 ss src ip:端口号 显示来源端口小于50的端口号的内容 1 ss -ntul sport lt 50 ss列出在FIN-WAIT-1状态的http、https连接 1 ss -o state fin-wait-1 \u0026#39;( sport = :http or sport = :https )\u0026#39; nc 简介 用于设置路由器 主要作用 实现任意 TCP/UDP 端口的侦听，nc 可以作为 server 以 TCP 或 UDP 方式侦听指定端口 端口的扫描，nc 可以作为 client 发起 TCP 或 UDP 连接 机器之间传输文件 机器之间网络测速 常用参数 参数 含义 -p\u0026lt;通信端口\u0026gt; 设置本地主机使用的通信端口 -l 监听模式 -u 使用UDP传输(tcp 不带参数，默认) -v 显示指令执行过程 -w\u0026lt;超时秒数\u0026gt; 设置连接超时时间 -z 使用0输入/输出模式，只在扫描通信端口时使用 实例 tcp端口扫描 1 nc -v -z -w 1 192.168.254.130 20-23 扫描192.168.254.130的端口，范围是20-23，-w 1表示1秒超时，v表示详细输出\nudp端口扫描 1 nc -u -z -w 2 192.168.254.130 20-23 扫描80端口 1 nc -nvv 192.168.254.130 80 扫描22端口 1 nc -nvv 192.168.254.130 22 终端之间通信聊天 服务端监听服务, 客户端请求 (服务端 \u0026lt;== 请求 ==\u0026gt; 客户端) 文件传输 ","date":"2025-10-17T13:38:23+08:00","permalink":"https://YLine-hub.github.io/p/linux%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/","title":"[Linux]网络管理命令"},{"content":"使用攻略 快捷键(win) 文本操作 ctrl + \u0026lt;- : 移动到整个单词前面 ctrl + -\u0026gt; : 移动到整个单词后面 home : 移动到行首 end : 移动到行尾 ctrl + home : 移动到文件首行 ctrl + end : 移动到文件末行 ctrl + shift + k : 删除当前行 键盘没有home和end键 快捷键 功能 备注 shift+7(小键盘) home 或者关闭Num灯直接按7 shift+1(小键盘) end 或者关闭Num灯直接按1 快捷打开 ctrl+` : 快速打开命令行 快捷键(mac) 文本操作 command + shift + k : 删除当前行 mac和win的按键对应 mac win Command Win Option Alt Control Ctrl Delete Backspace Return Enter 注意：快捷键中 mac 的command 对应 win 的ctrl\n","date":"2025-10-17T12:53:41+08:00","permalink":"https://YLine-hub.github.io/p/vscode%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5/","title":"[VScode]使用攻略"},{"content":"安装前准备 卸载mariadb 查看是否安装mariadb 1 rpm -qa | grep mariadb 卸载 1 rpm -e --nodeps mariadb-libs-5.5.60-1.el7_5.x86_64 查看那是否卸载干净 1 rpm -qa | grep mariadb 检查依赖 libaio 查看是否安装libaio 1 rpm -qa | grep libaio 如果没有安装则执行 1 yum install libaio -y numactl 检查是否安装numactl 1 rpm -qa | grep numactl 如果没有则执行安装 1 yum install -y numactl 安装mysql 下载依赖包 检查glibc版本 1 ldd --version 下载相应glibc版本的mysql 直接下载安装包并上传到服务器，或者复制下载地址 在服务器上下载 1 wget https://downloads.mysql.com/archives/get/p/23/file/mysql-8.0.35-linux-glibc2.17-x86_64.tar.xz 解压并重命名 注：本文上传到了/opt目录下\n进入下载目录 1 cd /opt 解压安装包 1 tar -xvf mysql-8.0.35-linux-glibc2.17-x86_64.tar.xz 移动解压目录到/usr/local目录下并改名为mysql 1 mv mysql-8.0.35-linux-glibc2.17-x86_64 /usr/local/mysql 创建存储数据文件夹 1 mkdir /usr/local/mysql/data 设置用户组并赋权 创建用户组 1 groupadd mysql 创建用户(无登录模式) 1 useradd -s /usr/sbin/nologin -r -g mysql mysql 更改属主和属组 1 chown -R mysql:mysql /usr/local/mysql/ 更改权限 1 chmod -R 755 /usr/local/mysql/ 初始化mysql 进入mysql/bin目录 1 cd /usr/local/mysql/bin 初始化 1 ./mysqld --initialize --user=mysql --datadir=/usr/local/mysql/data --basedir=/usr/local/mysql 初始密码：qt\u0026amp;ASa4cif\u0026amp;o\n配置参数文件 编辑my.cnf文件 1 vim /etc/my.cnf my.cnf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 [client] port = 3306 socket = /usr/local/mysql/data/mysql.sock default-character-set = utf8mb4 [mysql] default-character-set = utf8mb4 [mysqld] character-set-client-handshake = FALSE character-set-server = utf8mb4 collation-server = utf8mb4_general_ci init_connect = \u0026#39;SET NAMES utf8mb4\u0026#39; port = 3306 socket = /usr/local/mysql/data/mysql.sock skip-external-locking key_buffer_size = 16M max_allowed_packet = 1M table_open_cache = 64 sort_buffer_size = 512K net_buffer_length = 8K read_buffer_size = 256K read_rnd_buffer_size = 512K myisam_sort_buffer_size = 8M datadir = /usr/local/mysql/data #lower_case_table_names=1 #如果要设置lower_case_table_names可以在初始化里面设置 ./mysqld --initialize --user=mysql --datadir=/usr/local/mysql/data --basedir=/usr/local/mysql --lower_case_table_names=1 [mysqldump] quick max_allowed_packet = 16M [mysql] no-auto-rehash [myisamchk] key_buffer_size = 20M sort_buffer_size = 20M read_buffer = 2M write_buffer = 2M [mysqlhotcopy] interactive-timeout 修改/etc/my.cnf权限为777 1 chmod 777 /etc/my.cnf 启动mysql 设置软连接 设置软链接 1 2 3 ln -s /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql ln -s /usr/local/mysql/bin/mysql /usr/bin/mysql ln -s /usr/local/mysql/mysql.sock /var/mysql.sock 启动mysql 1 service mysql start 登录并更改密码 登录mysql 1 mysql -uroot -p 输入密码（密码不会显示） 两种改密方式二选一 1 2 3 alter user \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; identified by \u0026#39;123456\u0026#39;; # 或者 set password for root@localhost = \u0026#39;123456\u0026#39;; 问题：开放远程连接后如果想修改密码发生报错 1 2 3 ERROR 1396 (HY000): Operation ALTER USER failed for \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; ERROR 1133 (42000): Can\u0026#39;t find any matching row in the user table 检查user表中的用户和主机名 1 2 use mysql; select user, host from user; 如果 root 用户的主机名不是 localhost，而是 %，则需要修改修改密码命令。 1 2 3 alter user \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; identified by \u0026#39;123456\u0026#39;; set password for \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; = \u0026#39;123456\u0026#39;; 开放远程连接并测试登录 使用mysql数据库 1 use mysql; 更新权限 1 update user set user.Host=\u0026#39;%\u0026#39; where user.User=\u0026#39;root\u0026#39;; 刷新权限 flush : 刷新 privilege : 特权\n1 flush privileges; 开放3306端口 查询所有开放端口 1 firewall-cmd --list-ports 开放3306端口 1 firewall-cmd --zone=public --add-port=3306/tcp --permanent 重启防火墙 1 firewall-cmd --reload ","date":"2025-10-17T10:12:01+08:00","permalink":"https://YLine-hub.github.io/p/centos7.6mysql8%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/","title":"[CentOS7.6]mysql8安装部署"},{"content":"环境 mac笔记本\nwin电脑\n同一个wifi\nMac和Win实现文件互传 win设置共享文件夹 右键需要共享的文件夹，选择属性 点击共享-\u0026gt;高级共享 詳細（しょうさい）：详细；详尽\n共有（きょうゆう）：共享；共有\n勾选共享此文件复选框，在点击アクセス許可 許可（きょか）：批准；许可\n选择所有人，勾选フル　コントロール，再点击適用 コントロール： control 控制；管理；操纵；调节\n適用（てきよう）：应用\n点击ok以后，再点击共有 选择Everyone，再点击追加 追加（ついか）：添加\nアクセス許可のレベル选择読み取り/書き込み，再点击共有 レベル：level 水平；等级\n打开cmd，输入ipconfig查看本机ip 问题：ipconfig不是外部或内部命令 重新配置ipconfig环境变量 1 2 # 路径 C:\\Windows\\System32 再次查看 mac连接win的共享文件夹 win连接win的共享文件夹 适用win+R，打开快速运行\n然后在框内输入\\\\ + ip，回车即可\n注意：我这前面两个￥￥其实是\\\\，因为我的电脑是用的是日语语言，\\\\这个被显示成了￥￥\n输入连接电脑的账号密码 ","date":"2025-10-16T21:37:53+08:00","permalink":"https://YLine-hub.github.io/p/windowsmac%E5%92%8Cwin%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%BA%92%E4%BC%A0/","title":"[Windows]Mac和Win实现文件互传"},{"content":"部署环境 Node 21.6.2 : [CentOS7.6]node安装配置 MongoDB 7.0.25 : [CentOS7.6]MongoDB7安装配置 nginx 1.22.1 : [CentOS7.6]nginx安装配置 部署项目 下载项目 项目下载地址 1 https://github.com/didi/xiaoju-survey.git 创建code目录，并到code目录下 1 mkdir /opt/code \u0026amp;\u0026amp; cd /opt/code 下载源码 1 git clone https://github.com/didi/xiaoju-survey.git （如果没有git命令）安装git 1 yum install git -y 配置项目 下载的项目直接是一个文件夹\n创建目录/www/wwwroot\n1 mkdir -p /www/wwwroot 移动项目到/www/wwwroot下 1 mv xiaoju-survey/ /www/wwwroot/ 到项目目录下 1 cd /www/wwwroot/xiaoju-survet 配置数据库 到server目录下 1 cd /wwww/wwwroot/xiaoju-survet/serve 查看数据库配置 1 2 3 4 5 vim .env # 开发环境 vim .env.development # 生产环境 vim .env.production 可以按照他的来，也可以自己创建数据库使用\n创建数据库并创建账号 连接mongodb 1 mongosh -u admin -p a123456 创建数据库 1 use xiaojuSurvey; 创建用户（读写权限） 1 db.createUser({user:\u0026#34;xiaojuSurvey\u0026#34;,pwd:\u0026#34;x123456\u0026#34;,roles:[{role:\u0026#34;readWrite\u0026#34;,db:\u0026#34;xiaojuSurvey\u0026#34;}]}); 查看用户 1 show users; 配置数据库 编辑.env.production（生产环境） 1 vim .env.production 配置数据库 1 2 3 XIAOJU_SURVEY_MONGO_DB_NAME=xiaojuSurvey # mongodb://username:passwd@127.0.0.1:27017 XIAOJU_SURVEY_MONGO_URL=mongodb://xiaojuSurvey:x123456@127.0.0.1:27017 编译并启动项目 全局安装pm2 1 npm install pm2 -g 运行server 到server目录下 1 cd /www/wwwroot/xiaoju-survey/server 编译并运行 1 2 3 npm install npm run build pm2 -n xiaoju-survey start npm -- run start:prod 运行web 到/web目录下 1 cd /www/wwwroot/xiaoju-survey/web 编译并运行 1 2 npm install npm run serve 部署前端到nginx上 构建前端代码，产生dist文件 1 2 3 4 # 到xiaoju-survey/web目录下 # 编译项目 npm run build 编辑nginx 1 vim /usr/local/nginx/conf/nginx.conf nginx 配置 编辑xiaoju-survey下的配置文件 1 vim /www/wwwroot/xiaoju-survey/nginx/nginx.conf nginx.conf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 # 启动的 worker 进程数量 worker_processes auto; # 错误日志路径和级别 error_log /var/log/nginx/error.log warn; # TODO: 配置错误日志地址 events { # 最大连接数 worker_connections 1024; } http { # include /etc/nginx/mime.types; # https://github.com/nginx/nginx/blob/master/conf/mime.types types { text/html html htm shtml; text/css css; text/javascript js; image/jpeg jpeg jpg; image/png png; } default_type application/octet-stream; log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; access_log /var/log/nginx/access.log main; # TODO: 配置日志地址 sendfile on; keepalive_timeout 65; server { listen 8080; # IPv6端口 listen [::]:8080; server_name localhost; # 为不同的域名或子域名指定不同的配置 # gzip config gzip on; gzip_min_length 1k; gzip_comp_level 9; gzip_types text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml; gzip_vary on; gzip_disable \u0026#34;MSIE [1-6]\\.\u0026#34;; root /www/wwwroot/siaoju-survey/web/dist; # TODO: 前端打包出来的资源地址 location / { try_files $uri $uri /management.html; # 处理本地静态文件，适用于直接返回页面或在文件不存在时提供备选页面（如 404 页面、静态资源） } # B端页面 location /management/ { try_files $uri $uri/ /management.html; } # B端预览页 location /management/preview/ { try_files $uri $uri/ /render.html; } # C端页面 location /render/ { try_files $uri $uri/ /render.html; } # server接口 location /api { proxy_pass http://127.0.0.1:3000; } # server下载模块的文件存储地址 location /exportfile { proxy_pass http://127.0.0.1:3000; } # server上传模块的文件存储地址 # 文件夹的配置在 server/src/modules/file/config/index.ts SERVER_LOCAL_CONFIG.FILE_KEY_PREFIX location /userUpload { proxy_pass http://127.0.0.1:3000; } error_page 500 502 503 504 /500.html; client_max_body_size 20M; } } 创建nginx错误日志目录 1 mkdir -p /var/log/nginx/ 创建nginx错误日志 1 touch /var/log/nginx/error.log 备份nginx内的nginx.conf 1 mv /usr/local/nginx/conf/nginx.conf /usr/local/nginx/conf/nginx.conf.back 将xiaoju-survey内的nginx.conf移到nginx/confmuluxia 1 mv /www/wwwroot/xiaoju-survey/nginx/nginx.conf /usr/local/nginx/conf 启动或重启nginx 1 systemctl start nginx 开放8080端口 1 2 firewall-cmd --zone=public --add-port=8080/tcp --permanent firewall-cmd --reload 问题一：Error: spawn xdg-open ENOENT 解决方法 1 sudo yum install xdg-utils ","date":"2025-10-16T13:35:40+08:00","permalink":"https://YLine-hub.github.io/p/linux%E9%83%A8%E7%BD%B2%E5%BC%80%E6%BA%90xiaojusurvey%E9%97%AE%E5%8D%B7%E7%B3%BB%E7%BB%9F/","title":"[Linux]部署开源XIAOJUSURVEY问卷系统"},{"content":"安装前置 nvm安装包 nvm历史版本:nvm-download 我这里选择的是最新版本的tar.gz包，复制其下载地址\n1 https://github.com/nvm-sh/nvm/archive/refs/tags/v0.40.3.tar.gz 安装nvm 下载nvm安装包 进入/opt目录 1 cd /opt 下载nvm安装包 1 wget https://github.com/nvm-sh/nvm/archive/refs/tags/v0.40.3.tar.gz 问题：显示拒绝连接 打开ipaddress.com网址，搜索github.com网址的ip 编辑/etc/hosts文件 1 vim /etc/hosts 将以下内容复制到文件底部并保存 1 140.82.112.4 github.com 重新下载测试 下载成功\n解压压缩包，并将文件放在/usr/local目录下 解压压缩包(解压后的名字叫nvm-0.40.3) 1 tar -zxvf v0.40.3.tar.gz 将文件移动到/usr/local目录下并命名为nvm 1 mv nvm-0.40.3/ /usr/local/nvm 配置环境变量 编辑配置文件 1 vim /etc/profile 在文件底部写入配置，并保存文件 1 2 3 export NVM_DIR=\u0026#34;/usr/local/nvm\u0026#34; [ -s \u0026#34;$NVM_DIR/nvm.sh\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/nvm.sh\u0026#34; # This loads nvm [ -s \u0026#34;$NVM_DIR/bash_completion\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/bash_completion\u0026#34; # This loads nvm bash_completion 重新加载配置文件 1 source /etc/profile 验证是否配置成功 1 nvm -v 安装node 查看可用node版本 1 nvm ls-remote 下载最新node版本 1 nvm install node (或者)下载指定版本的node 1 nvm install 22.20.0 查看已安装node版本 1 nvm ls 使用指定版本的node 1 nvm use 22.20.0 设定特定的版本为默认版本 1 nvm alias default 22.20.0 验证是否安装node 1 2 node -v npm -v 问题一：GLIBC版本过低 原因: node18 开始，都需要 2.27以上的版本支持，但是 centos7.6 老系统默认没有那么高的版本，因此接下来我们去安装 glibc_2.28 安装glibc_2.28 glibc下载地址：glibc-download\n找到我们所需的版本，并复制其地址\n1 http://ftp.gnu.org/gnu/glibc/glibc-2.28.tar.gz 进入/opt目录 1 cd /opt 下载安装包 1 wget http://ftp.gnu.org/gnu/glibc/glibc-2.28.tar.gz 问题二：下载速度过慢 使用阿里云镜像站下载 1 wget https://mirrors.aliyun.com/gnu/glibc/glibc-2.28.tar.gz 解压安装包 1 tar -zxvf glibc-2.28.tar.gz 移动文件到/usr/local目录下 1 mv glibc-2.28 /usr/local 进入glibc目录下下 1 cd /usr/local/glibc-2.28 创建build文件夹并进入 1 mkdir build \u0026amp;\u0026amp; cd build 执行./configure配置 1 ../configure --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin 问题三：gcc编译器版本过低 解决方法：安装gcc-8的依赖环境\n安装gcc8 安装所需工具 1 2 3 yum groupinstall -y \u0026#39;Development Tools\u0026#39; yum install -y texinfo bison flex gcc-gnat glibc-devel.i686 libgcc.i686 下载gcc-8 1 2 cd /opt wget http://ftp.tsukuba.wide.ad.jp/software/gcc/releases/gcc-8.2.0/gcc-8.2.0.tar.gz 解压gcc包 1 tar -zxvf gcc-8.2.0.tar.gz 将gcc移动到/usr/local目录下 1 mv gcc-8.2.0 /usr/local/ 进入gcc目录 1 cd /usr/local/gcc-8.2.0 下载GCC所需的依赖：gmp、mpfr、mpc、isl 1 ./contrib/download_prerequisites ./contrib/download_prerequisites太慢 1 2 3 vim contrib/download_prerequisites # ftp://gcc.gnu.org/pub/gcc/infrastructure/ #修改为 http://www.mirrorservice.org/sites/sourceware.org/pub/gcc/infrastructure/ 修改为\n下载依赖时报错 移除mpfr-3.1.4.tar.bz2 1 rm -rf mpfr-3.1.4.tar.bz2 修改回原路径重新下载 1 ./contrib/download_prerequisites 下载完成\n执行 configure 生成Makefile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 mkdir build \u0026amp;\u0026amp; cd build ../configure --prefix=/storage/app/gnu/gcc-8.2.0 \\ --enable-bootstrap \\ --enable-shared \\ --enable-threads=posix \\ --enable-checking=release \\ --with-system-zlib \\ --enable-__cxa_atexit \\ --disable-libunwind-exceptions \\ --enable-gnu-unique-object \\ --enable-linker-build-id \\ --with-linker-hash-style=gnu \\ --enable-languages=c,c++,objc,obj-c++,fortran,ada,go,lto \\ --enable-plugin \\ --enable-initfini-array \\ --disable-libgcj \\ --enable-gnu-indirect-function \\ --with-tune=generic \\ --with-arch_32=x86-64 \\ --build=x86_64-redhat-linux 执行编译 -j 参数根据CPU核数设置。 编译时间根据机器配置决定，GCC编译过程一般都需要很长时间，慢慢等待。 1 make -j48 问题：编译出现报错 往上翻看到\n安装zlib 1 yum install zlib-devel.x86_64 再次编译 1 make -j48 安装 1 make install 配置环境变量 编辑~/.bashrc文件 1 vim ~/.bashrc 文件内部输入以下配置 1 2 3 4 5 6 7 8 9 ### gnu gcc export GCC_HOME=/storage/app/gnu/gcc-8.2.0 export PATH=$GCC_HOME/bin:$PATH export MANPATH=$GCC_HOME/share/man export CPATH=$GCC_HOME/include export LD_LIBRARY_PATH=$GCC_HOME/lib:$GCC_HOME/lib64 export LIBRARY_PATH=$GCC_HOME/lib:$GCC_HOME/lib64 再次开始安装glic-2.28 安装 1 make \u0026amp;\u0026amp; make install 查看系统中可用的glibc版本 1 strings /lib64/libc.so.6 |grep GLIBC_ ","date":"2025-10-15T23:34:40+08:00","permalink":"https://YLine-hub.github.io/p/centos7.6nvm%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/","title":"[CentOS7.6]nvm安装配置"},{"content":"环境准备 操作系统：CentOS7.6 MongoDB安装包：MongoDB-Download 1 https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-7.0.25.tgz mongodb shell: MongoDB-Shell 1 https://downloads.mongodb.com/compass/mongosh-2.5.8-linux-x64.tgz 软件安装和启动 下载解压安装包 进入/opt目录下 1 cd /opt 下载安装包 1 wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-7.0.25.tgz 解压安装包 1 tar -zxvf mongodb-linux-x86_64-rhel70-7.0.25.tgz 将文件夹移动到/usr/local下，并改名为mongodb 1 mv mongodb-linux-x86_64-rhel70-7.0.25 /usr/local/mongodb 配置mongodb 创建mongodb的配置、数据和日志目录 1 mkdir /usr/local/mongodb/{etc,data,logs} 在mongodb/etc目录下新建配置文件mongodb.conf(可选，但建议配置) 1 vim /usr/local/mongodb/etc/mongod.conf mongodb.conf 1 2 3 4 5 6 7 8 9 10 11 12 systemLog: destination: file path: \u0026#34;/usr/local/mongodb/logs/mongod.log\u0026#34; logAppend: true storage: dbPath: \u0026#34;/usr/local/mongodb/data\u0026#34; processManagement: fork: true pidFilePath: \u0026#34;/usr/local/mongodb/mongod.pid\u0026#34; net: bindIp: 0.0.0.0 port: 27017 配置环境变量 编辑/etc/profile文件 1 vim /etc/profile 在文件底部添加配置信息 1 2 export MONGODB_HOME=/usr/local/mongodb export PATH=$PATH:$MONGODB_HOME/bin 重新加载配置文件 1 source /etc/profile 创建服务启动文件，并启动服务 创建mongodb.service文件 1 vim /etc/systemd/system/mongodb.service mongodb.service 1 2 3 4 5 6 7 8 9 10 11 12 [Unit] Description=MongoDB Server After=network.target [Service] Type=forking ExecStart=/usr/local/mongodb/bin/mongod -f /usr/local/mongodb/etc/mongod.conf ExecStop=/usr/local/mongodb/bin/mongod --shutdown -f /usr/local/mongodb/etc/mongod.conf ExecReload=/bin/kill -s HUP $MAINPID [Install] WantedBy=multi-user.target 启动服务 1 2 systemctl daemon-reload systemctl start mongodb 设置开机自启动 1 systemctl enable mongodb 安装MongDB Shell客户端 到/opt目录下 1 cd /opt 下载安装包 1 wget https://downloads.mongodb.com/compass/mongosh-2.4.2-linux-x64.tgz 解压安装包 1 tar -zxvf mongosh-2.4.2-linux-x64.tgz 移动安装包到mongodb目录下 1 mv mongosh-2.4.2-linux-x64 /usr/local/mongodb/mongosh 配置环境变量 编辑/etc/profile文件 1 vim /etc/profile 将以下内容加入到文件底部 1 2 export MONGOSH_HOME=/usr/local/mongodb/mongosh export PATH=$PATH:$MONGOSH_HOME/bin 重新加载配置文件 1 source /etc/profile 连接测试 1 mongosh 创建管理员用户 连接mongodb 1 mongosh 查看数据库 1 show dbs; 切换到 admin 数据库 1 use admin; 查看用户 1 show users; 创建一个管理员用户(密码为123456) 1 db.createUser({user: \u0026#34;admin\u0026#34;, pwd: \u0026#34;123456\u0026#34;, roles: [{ role: \u0026#34;userAdminAnyDatabase\u0026#34;, db: \u0026#34;admin\u0026#34;}]}); 再次查看用户 1 show users; 修改密码 注意先切换到相应的库 1 use admin; 修改密码 1 db.changeUserPassword(\u0026#34;admin\u0026#34;, \u0026#34;a123456\u0026#34;); 开启MongoDB Server登录认证 修改 mongod.conf 文件 1 vim /usr/local/mongodb/etc/mongod.conf 添加登录认证 1 2 3 #在最后面添加以下内容： security: authorization: enabled 重启mongodb服务 1 systemctl restart mongodb 连接测试 1 mongosh -u admin -p a123456 创建库与用户 使用管理员登录数据库 1 mongosh -u root -p a123456 创建库与用户 创建一个数据库mydb 1 use mydb; 创建mydb数据库的用户（读写权限） 1 db.createUser({ user: \u0026#34;myuser\u0026#34;, pwd: \u0026#34;m123456\u0026#34;, roles: [{ role: \u0026#34;readWrite\u0026#34;, db: \u0026#34;mydb\u0026#34;}]}); 查看用户 1 show users; 校验用户及密码 1 db.auth(\u0026#34;myuser\u0026#34;,\u0026#34;m123456\u0026#34;) 获取当前连接用户 1 db.runCommand({connectionStatus: 1}) 创建一个表并插入一条数据 创建表并插入测试数据，不然连接后使用show dbs不显示库名 1 db.test_collection.insertOne({name:\u0026#34;init\u0026#34;}); 查看表 1 show tables; 查看库 1 show dbs ","date":"2025-10-15T22:52:27+08:00","permalink":"https://YLine-hub.github.io/p/centos7.6mongodb7%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/","title":"[CentOS7.6]MongoDB7安装配置"},{"content":"安装前置 找到所需安装包 nodejs-download 选择指定的版本 选择有glibc的版本，因为centos7的glibc版本低 复制链接 1 https://unofficial-builds.nodejs.org/download/release/v21.6.2/node-v21.6.2-linux-x64-glibc-217.tar.gz 安装node 进入/opt目录下 1 cd /opt 下载安装包 1 wget https://unofficial-builds.nodejs.org/download/release/v21.6.2/node-v21.6.2-linux-x64-glibc-217.tar.gz 等待下载 解压安装包并移动到/usr/local目录下 解压安装包 1 tar -zxvf node-v21.6.2-linux-x64-glibc-217.tar.gz 移动安装包到/usr/local目录下，并改名为node 1 mv node-v21.6.2-linux-x64-glibc-217 /usr/local/node 配置环境变量 编辑/etc/profile 1 vim /etc/profile 添加以下内容到文件末尾 1 2 export NODE_HOME=/usr/local/node export PATH=$NODE_HOME/bin:$PATH 退出并保存文件\n重新加载配置文件\n1 source /etc/profile 查看安装 1 node -v ","date":"2025-10-15T22:50:18+08:00","permalink":"https://YLine-hub.github.io/p/centos7.6node%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/","title":"[CentOS7.6]node安装配置"},{"content":"搭建nginx 根据这个教程进行搭建: [CentOS7.6]nginx安装配置 搭建项目 上传文档到服务器 /tmp 目录权限是777，可以直接上传到文件夹 将文件移动到nginx/html目录下并解压 分别移动文件到html目录下 1 2 mv public.rar /usr/local/nginx/html mv war.rar /usr/local/nginx/html 移动到html目录下 1 cd /usr/local/nginx/html 解压文件 1 2 unar public.rar unar war.rar 配置nginx.conf 编辑nginx文件 1 vim /usr/local/nginx/conf/nginx.conf 配置nginx：不同端口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 server { listen 80; server_name localhost; location / { root html/war; index circuitjs.html; } } server { listen 8080; server localhost; location / { root html/public; index index.html; } } 配置nginx：不同域名 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 server { listen 80; server_name a.server.com; location / { root html/war; index circuitjs.html; } } server { listen 80; server b.server.com; location / { root html/public; index index.html; } } ","date":"2025-10-15T22:48:08+08:00","permalink":"https://YLine-hub.github.io/p/linux%E6%90%AD%E5%BB%BAnginx%E5%B9%B6%E9%83%A8%E7%BD%B2%E4%B8%A4%E4%B8%AA%E9%A1%B9%E7%9B%AE/","title":"[Linux]搭建nginx，并部署两个项目"},{"content":"创建ssh用户，并用ssh用户登录 创建ssh组 新建ssh组 1 groupadd ssh_user 创建ssh用户 1 useradd -m -d /home/username -g ssh_user -s /bin/bash username 创建ssh用户用户名为lin 1 useradd -m -d /home/lin -g ssh_user -s /bin/bash lin 添加sudo权限 编辑/etc/sudoers文件 1 vim /etc/sudoers 找到root ALL=(ALL) ALL这行 添加以下四行其中一个 第一行:允许用户youuser执行sudo命令(需要输入密码). 第二行:允许用户组youuser里面的用户执行sudo命令(需要输入密码). 第三行:允许用户youuser执行sudo命令,并且在执行的时候不输入密码. 第四行:允许用户组youuser里面的用户执行sudo命令,并且在执行的时候不输入密码. 1 2 3 4 youuser ALL=(ALL) ALL %youuser ALL=(ALL) ALL youuser ALL=(ALL) NOPASSWD: ALL %youuser ALL=(ALL) NOPASSWD: ALL 允许ssh_user用户组执行sudo命令（需要输入密码） 1 %ssh_user ALL=(ALL) ALL 设置密码 1 passwd lin 使用:wq!强制保存 切换用户重新登录，并测试sudo权限 修改成lin用户 登录 测试sudo权限 1 ls /root 使用sudo再次访问 1 sudo ls /root 上传文件 上传文件到/opt时显示没有权限\n设置文件夹权限\n1 sudo chmod 777 /opt 没有source命令 问题是source是一个bash build-in命令(不是程序 – 如ls或grep)。 切换root账号使用 切换root用户 1 sudo -s 更新配置 1 source /etc/profile 退出root账号 1 exit ","date":"2025-10-15T22:45:27+08:00","permalink":"https://YLine-hub.github.io/p/centos7.6%E5%88%9B%E5%BB%BAssh%E7%94%A8%E6%88%B7%E5%B9%B6%E7%94%A8ssh%E7%94%A8%E6%88%B7%E7%99%BB%E9%99%86/","title":"[CentOS7.6]创建SSH用户，并用SSH用户登陆"},{"content":"打开文件夹 点击File-\u0026gt;Open folder 选择一个文件夹并打开 添加另一个文件夹 这时候用File-\u0026gt;Add Folder to Workspace... 选择其他项目 弹出是否信任该文件夹时点击信任即可\n这时候，就会自动生成工作区，然后所有项目都在工作区内\n","date":"2025-10-15T22:38:32+08:00","permalink":"https://YLine-hub.github.io/p/vscode%E4%BD%BF%E7%94%A8%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%90%8C%E6%97%B6%E6%89%93%E5%BC%80%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE/","title":"VSCode使用工作区同时打开多个项目"},{"content":"前置环境 nodejs:nodejs-download nativefier插件\n网站链接\n打包过程 安装nodejs 运行安装程序 一直点击next，可以改一下安装路径，其他不用修改\n测试是否安装\n打开cmd，输入命令查看版本\n1 npm -v 安装插件 用npm安装插件 1 npm install nativefier -g 等待安装完成 打包 1 nativefier --name \u0026#34;ciruitjs1\u0026#34; \u0026#34;http://www.haoji.cc/\u0026#34; 报错一：connect ECONNREFUSED 127.0.0.1:443 1 2 3 4 5 6 Error during build. Run with --verbose for details. RequestError: connect ECONNREFUSED 127.0.0.1:443 at ClientRequest.\u0026lt;anonymous\u0026gt; (C:\\Users\\yline\\AppData\\Roaming\\npm\\node_modules\\nativefier\\node_modules\\got\\dist\\source\\core\\index.js:970:111) at Object.onceWrapper (node:events:634:26) at ClientRequest.emit (node:events:531:35) at ClientRequest.emit (node:domain:489:12) ... 在ipaddress.com网站中，分别查询github.com和fastly.net的ip地址 我查询到的github.com ip为140.82.112.4，fastly.net为151.101.1.6\n如下面，将这几行加入到C:\\Windows\\System32\\drivers\\etc目录下hosts文件夹中最后面\n1 2 3 140.82.112.4 github.com 151.101.1.6 github.global.ssl.fastly.net 151.101.65.6 github.global.ssl.fastly.net 问题二：修改hosts文件没有权限 给hosts文件添加写入权限\n右键hosts文件，选择属性\n点击安全 点击编辑 选择Users，点击最上面的选项给予全部权限，再点击应用 修改完权限以后，修改hosts文件 重新打包 再次执行打包命令 1 nativefier --name \u0026#34;ciruitjs1\u0026#34; \u0026#34;http://www.haoji.cc/\u0026#34; 等待打包完成 打包完成，位置在打包的目录下 进入目录后，可以看到打包后的程序 双击运行 ","date":"2025-10-14T20:15:28+08:00","permalink":"https://YLine-hub.github.io/p/%E7%AE%80%E5%8D%95%E7%9A%84web%E7%BD%91%E7%AB%99%E6%89%93%E5%8C%85%E6%88%90exe/","title":"简单的web网站打包成exe"},{"content":"安装前置 【注】：必须已经有Java环境才能正常运行\n安装jdk，安装详情可以查看【CentOS7.6】jdk8安装配置\n官网下载tomcat：Tomcat9-Download\n安装Tomcat9 运行tomcat 上传tomcat压缩包到/opt目录下 解压文件 1 tar -zxvf apache-tomcat-9.0.110.tar.gz 将文件夹移动到/usr/local目录下并重命名为tomcat（确保/usr/local下没有tomcat文件，如果有的话要先删除） 1 mv apache-tomcat-9.0.110 /usr/local/tomcat 进入tomcat/bin目录下 1 cd /usr/local/tomcat/bin 运行tomcat 1 2 3 4 5 # 启动tomcat ./startup.sh # 关闭tomcat ./shutdown.sh 浏览器查看：http://192.168.172.100:8080 开启8080端口 查看系统中的所有开放的端口 1 firewall-cmd --list-ports\t或者\n查看8080端口是否开启 1 firewall-cmd --query-port=8080/tcp 开启8080端口 1 firewall-cmd --zone=public --add-port=8080/tcp --permanent 重启防火墙 1 firewall-cmd --reload 浏览器查看：http://192.168.172.100:8080 开启自动解压/webapps目录下的war文件 进入tomcat/conf 1 cd /usr/local/tomcat/conf 编辑server.xml文件 1 vim server.xml 搜索关键词unpackWARs ","date":"2025-10-13T22:52:40+08:00","permalink":"https://YLine-hub.github.io/p/centos7.6tomcat9%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/","title":"[CentOS7.6]Tomcat9安装配置"},{"content":"下载tomcat9解压包 配置jdk1.8环境 方案三 双击startup.bat启动 闪退原因：jdk环境不适用或者没有安装jdk 双击shutdown.bat停止 乱码解决 双击startup.bat后弹出的命令行窗口显示乱码 进入...\\apache-tomcat-9.0.110\\conf目录下\n用记事本打开logging.properties\n1 2 3 # java.util.logging.ConsoleHandler.encoding = utf-8 # 更改为 java.util.logging.ConsoleHandler.encoding = GBK ","date":"2025-10-13T20:34:00+08:00","permalink":"https://YLine-hub.github.io/p/win11tomcat9%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/","title":"[Win11]tomcat9安装配置"},{"content":"环境准备 git：git-download elcipse：eclipse IDE-download GWT plugin：GWT plugin for Eclipse Tomcat9-download\nTomcat 9：Tomcat9-download circuitjs1的git链接：https://github.com/pfalstad/circuitjs1.git 本地部署 将circuitjs1克隆到本地 创建文件夹circuitjs\n进入文件夹\n在文件夹上面的路径栏中输入cmd并回车\n就会自动打开当前目录下的cmd命令行 在命令行中输入以下命令 1 git clone https://github.com/pfalstad/circuitjs1.git 引入gwt插件到eclipse 方法一： 使用按钮安装gwt到eclipse 将gwt页面的install拖到eclipse里面 弹出当前页面后，选择上面两个，然后点击confirm 下载完成后点击接受-\u0026gt;Finish\n等待软件安装\n弹出该窗口后选择上面的site然后点击下面的信任 又有窗口弹出，继续全选后点击信任 安装完成后点击重启 方法二：从Eclipse Marketplace安装插件 点击 Help -\u0026gt; Eclipse Marketplace 搜索gwt并安装 使用eclipse打开circuitjs1 点击导入项目 选择下载的文件的根目录 打开build.gradle可以看到java的版本是1.8 然后报错显示的是没有发现java 1.8.301的路径 下载jdk 1.8.0_301 下载jdk 1.8.0_301：java-download 注意：Oracle需要登陆才能下载\n选择Java SE 8 (8u211 and later) 找到jdk-8u301的安装包，点击下载 配置 jdk 1.8.301 安装jdk后记下jdk的安装路径 1 C:\\Program Files\\Java\\jdk1.8.0_301 添加本地jdk1.8 点击Window-\u0026gt;Perferences... 选择Java-\u0026gt;Installed JREs，点击add 选择Standard VM，点击Next 选择jdk1.8的路径，点击完成 勾选jdk1.8.0_301然后点击Apply and Close 设置项目环境 右击项目根目录，点击Properties 其中有两个未绑定的内容分别是JRE System Library和GWT SDK unbound： 未绑定\n移除未绑定的内容 添加jre到项目环境 选择Workspace default JRE，然后点击Finish workspace default jre后面写了jdk1.8.0_301这个正是我们刚刚配置的jdk\n添加gwt到项目环境 选择默认的即可 都添加以后点击Order and Export中，把jre和gwt都勾选起来，再点击Apply and Close 然后项目的报错都没了 设置Tomcat（不需要，GWT项目不需要Tomcat运行） 确保tomcat服务器处于关闭状态\n点击Windows-\u0026gt;Perferences...\n点击server中的Runtime Environments，然后点击add 发现 Eclipse 没有 Apache 的选项 完成下面的操作后再次进入，发现已经有Tomcat了 根据自己的情况选择Tomcat版本，我这里选择的是Tomcat9 选择自己Tomcat的安装路径，然后点击Finish 点击Apply and Close 解决Eclipse没有Apache的选项 点击Help-\u0026gt;Install New Software 在Work with中输入 http://download.eclipse.org/releases/版本号，然后回车 版本号查询，点击Help-\u0026gt;About Eclipse IDE，我的版本号为 2025-09\n然后勾选Web,XML,Java EE and ODG Enterprise Development 或者 JST Server Adapters Extension或者JST Server Adapters，这两个都可以。 JST Server Adapters Extension 和 JST Server Adapters 在 Web,XML,Java EE and ODG Enterprise Development 里面 然后点击Next等待安装 配置过程会有弹窗弹出，一直点next即可 还会有要求信任的Authority，全部勾选以后点击信任即可 设置Servers（同样不需要，使用Tomcat的项目需要） 红框内如果没有Servers窗口则需要自己添加 点击Window-\u0026gt;Show View-\u0026gt;Other 选择Server下的Servers 然后下方框内出现了Servers窗口 点击No servers are available. Click this link to create a new server… 找到自己Tomcat的版本，然后点击Finish 然后Servers栏会出现如下图内容 在Server Locations处选中Use Tomcat installation…\u0026mdash;-\u0026gt;将wtpwebapps改为webapps\u0026mdash;-\u0026gt;保存此设置（叉掉后点击Save） 右键点击start 浏览器输入： http://localhost:8080 出现该页面就表示配置tomcat成功\n运行项目 右键项目run as-\u0026gt;GWT Development Mode 控制台发生报错 1 java.lang.UnsupportedClassVersionError: org/eclipse/jdt/internal/compiler/classfmt/ClassFormatException has been compiled by a more recent version of the Java Runtime (class file version 55.0), this version of the Java Runtime only recognizes class file versions up to 52.0 报错信息显示：当前项目已经被55.0版本(jdk 11)的Java Runtime编译，当前Java Runtime 的版本是52.0版本(jdk 8)\n解决方案：切换jdk11\n切换jdk 11 后重新运行\n打开浏览器：http://127.0.0.1:9876 但是我们需要启动的主程序不是这个页面 启动主程序 右键项目run as-\u0026gt;GWT Development Mode with jetty 在弹窗中选择circuitjs.html然后点击ok 成功运行，然后双击开发模式窗口中的链接 打开程序 部署到Linux服务器 环境要求 centos7.6 tomcat9 ，安装tomcat可以参考：[CentOS7.6]Tomcat9安装配置 部署流程 编译circuitjs1项目 右键circuitjs1根目录，选择Run as-\u0026gt;GWT Compiler 等待编译完成 上传war目录 打包war目录，右键war文件夹并将其打包 使用mobaxterm上传到/usr/local/tomcat/webapps目录下 使用 unar 解压war.rar（如果没有就用yum安装） 1 unar war.rar 赋予war目录权限 1 chmod -R 775 war 浏览器输入：http://192.168.172.100:8080/war/circuitjs.html ","date":"2025-10-13T16:19:04+08:00","permalink":"https://YLine-hub.github.io/p/%E6%9C%AC%E5%9C%B0%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8Cciruitjs1%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/","title":"本地编译运行ciruitjs1，并部署到Linux服务器上"},{"content":"MySQL基础-SQL SQL通用语法 SQL语句可以单行或多行书写，以分号结尾。 SQL语句可以使用空格/缩进来增强语句的可读性。 MySQL数据库的SQL语句不区分大小写，关键词建议使用大写。 注释： 单行注释： \u0026ndash; 注释内容 或 # 注释内容 （MySQL特有） 多行注释：/* 注释内容 */ SQL分类 分类 全称 说明 DDL Data Definition Language 数据定义语言，用来定义数据库对象（数据库，表，字段） DML Data Manipulation Language 数据操作语言，用来对数据库表中的数据进行增删该 DQL Data Query Language 数据查询语言，用来查询数据库中表的记录 DCL Data Control Language 数据控制语言，用来创建数据库用户、控制数据库的访问权限 DDL-数据库操作 查询 1 2 3 4 # 查询所有数据库 SHOW DATABASES; # 查询当前数据库 SELECT DATABASE(); 查询所有数据库 查询当前的数据库 创建 1 2 # [如果不存在则]创建数据库 CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则]; 创建数据库itcast： 1 create database itcast; 再次创建数据库itcast： 报错：ERROR 1007 (HY000): Can\u0026rsquo;t create database \u0026lsquo;itcast\u0026rsquo;; database exists\n表示：数据库已经存在，无法再创建\n使用if not exists再次创建itcast: 1 create database if not exists itcast; 语句执行成功，但是没有新增数据库\n创建数据库itfost并设置字符集utf8mb4 不推荐使用utf8，因为utf8存储的长度为3个字节；推荐使用utf8mb4，它支持4个字节。\n1 create database itfox default charset utf8mb4; 删除 1 2 # [如果存在则]删除数据库 DROP DATABASE [IF EXISTS] 数据库名； 删除数据库itfox 1 drop database itfox; 再次删除数据库itfox 报错：数据库不存在\n如果不想报错，可以在数据库前加上if exists 1 drop database if exists itfox; 使用 1 USE 数据库名; 使用itcast数据库 1 use itcast; DDL-表操作 查询 查询当前数据库所有表 1 SHOW TABLES; 查询itcast数据库所有表 切换成sys数据库 1 use sys; 查询sys数据库的所有表 查询表结构 1 DESC 表名; 查询itcast中tb_user表结构 1 desc tb_user; 查询指定表的建表语句 1 SHOW CREATE TABLE 表名; 查询itcast数据库中tb_user的建表语句 1 show create table tb_user; 创建 创建表 1 2 3 4 5 6 7 CREATE TABLE 表名( 字段1 字段1类型[COMMENT 字段1注释], 字段2 字段2类型[COMMENT 字段2注释], 字段3 字段3类型[COMMENT 字段3注释], ... 字段n 字段n类型[COMMENT 字段n注释] )[COMMENT 表注释] 注意：[\u0026hellip;]为可选参数，最后一个字段后面没有逗号\n根据该表格在itcast数据库中相应表 id name age gender 1 令狐冲 28 男 2 风清扬 68 男 3 东方不败 32 男 1 2 3 4 5 6 create table tb_user( id int comment \u0026#39;编号\u0026#39;, name varchar(50) comment \u0026#39;姓名\u0026#39;, age int comment \u0026#39;年龄\u0026#39;, gender varchar(1) comment \u0026#39;性别\u0026#39; )comment \u0026#39;用户表\u0026#39;; 验证表是否被创建 1 show tables; DDL-表操作 数据类型 分类 类型 大小 有符号(SIGNED)范围 无符号(UNSIGNED)范围 描述 数值类型 TINYINT 1 bytes (-128,127) (0,255) 小整数值 SMALLINT 2 bytes (-32768,32767) (0,65535) 大整数值 MEDIUMINT 3 bytes (-8388608,8388607) (0,16777215) 大整数值 INT或INTEGER 4 bytes (-2147483648,2147483647) (0,4294967295) 大整数值 BIGINT 8 bytes (-^63,2^63-1) (0,2^64-1) 极大整数值 FLOAT 4 bytes (-3.402823466 E+38,3c402823466351 E+38) 0和(1.175494351E-38,3.402823466 E+38) 单精度浮点数值 DOUBLE 8bytes (-1.7976931348623157 E+308,1.7976931348623157 E+308) 0和(2.2250738585072014 E-308,1.7976931348623157 E+308) 双精度浮点数值 DECIMAL 依赖与M(精度)和D(标度)的值 依赖于M(精度)和D(标度)的值 小数值(精确定点数) 字符串类型 CHAR 0-255 bytes 定长字符串 VARCHAR 0-65535 bytes 变长字符串 TINYBLOB 0-255 bytes 不超过255个字符的二进制数据 TINYEXT 0-255 bytes 短文本字符串 BLOB 0-65535 bytes 二进制形式的长文本数据 TEXT 0-65535 bytes 长文本数据 MEDIUMBLOB 0-1677215 bytes 二进制形式的中等长文本数据 MEDIUMTEXT 0-16777215 bytes 中等长度文本数据 LONGBLOB 0-4294967295 bytes 二进制形式的极大文本数据 LONGTEXT 0-4294967295 bytes 极大文本数据 分类 类型 大小 范围 格式 描述 日期类型 DATE 3 1000-01-01 至 9999-12-31 YYYY-MM-DD 日期值 TIME 3 -838:59:59 至 838:59:59 HH:MM:SS 时间值或持续值 YEAR 1 1901 至 2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00 至 9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:01 至 2038-01-19 03:14:07 YYYY-MM-DD HH:MM:SS 混合日期和时间值，时间戳 案例 根据需求创建表（设计合理的数据类型、长度） 设计一张员工信息表，要求如下：\n编号（纯数字） 员工工号（字符串类型，长度不超过10位） 员工姓名（字符串类型，长度不超过10位） 性别（男/女，存储一个汉字） 年龄（正常人年龄，不可能存储负数） 身份证号（二代身份证号均为18位，身份证中有X这样的字符） 入职时间（取值年月日即可） 员工信息表\n1 2 3 4 5 6 7 8 9 create table emp_info ( id int comment \u0026#39;编号\u0026#39;, emp_no varchar(10) comment \u0026#39;工号\u0026#39;, name varchar(10) comment \u0026#39;姓名\u0026#39;, gender char(1) comment \u0026#39;性别\u0026#39;, age tinyint unsigned comment \u0026#39;年龄\u0026#39;, idcard char(18) comment \u0026#39;身份证\u0026#39;, entrydate date comment \u0026#39;入职时间\u0026#39; ) comment \u0026#39;员工信息表\u0026#39;; ","date":"2025-10-13T00:13:16+08:00","permalink":"https://YLine-hub.github.io/p/mysqlmysql%E5%9F%BA%E7%A1%80-sql%E6%9C%AA%E5%AE%8C%E6%88%90/","title":"[MySQL]MySQL基础-SQL(未完成)"},{"content":"问题：解压nginx压缩包后，解压的文件不属于当前用户 查看当前用户 1 id 这里能看到当前用户是root\n解压nginx压缩包 1 tar -zxvf nginx-1.22.1.tar.gz 可以看到nginx文件夹属于1001用户，mysql组\n检查系统中1001和mysql的信息 1 2 grep 1001 /etc/passwd grep mysql /etc/group 原因 其实根源在于你解压的时候没有明确指定 属主和属组的情况下。 解压时使用的是压缩文件中保存的属主和属组信息。\n通过-tvf参数组合来查看压缩包中的文件信息 1 tar -tvf nginx-1.22.1.tar.gz 可以看到这里展示的用户和用户组是mdounin/mdounin，主机中肯定没有这个用户，而且也不是root\n可以在后面添加一个参数--numeric-owner 1 tar -tvf nginx-1.22.1.tar.gz --numeric-owner 看到这里显示的属主和属组是1001/1001，正是对应当前主机上对应的mysql组。\n解压之后的属主和属组不影响实际使用。\n可以解压后修改属主和属组 1 2 # -R 参数是递归所有子目录与文件 chown -R 属主:属组 文件夹 例如这里可以用\n1 chown -R root:root nginx-1.22.1 ","date":"2025-10-12T21:25:31+08:00","permalink":"https://YLine-hub.github.io/p/linux%E5%B0%8F%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0-%E5%8E%8B%E7%BC%A9%E5%8C%85%E8%A7%A3%E5%8E%8B%E5%90%8E%E5%B1%9E%E4%B8%BB%E5%92%8C%E5%B1%9E%E7%BB%84%E4%B8%8D%E6%98%AF%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%E9%97%AE%E9%A2%98/","title":"[Linux]小知识学习-压缩包解压后属主和属组不是当前用户问题"},{"content":"nginx安装配置 卸载nginx 安装前查看系统内是否有nginx 1 ps -ef | grep nginx 上图可以看出没有nginx服务启动\n关闭nginx服务（若有nginx） 1 kill 进程ID 查看是否有nginx相关文件 1 find / -name nginx 删除nginx有关文件（若有nginx相关文件） 1 rm -rf 文件名 安装nginx 安装nginx所需环境 安装nginx需要下载官网源码编译，编译依赖 gcc 环境 (gcc-c++) nginx的http模块使用pcre来解析正则表达式，所以需要pcre库 (pcre pcre-devel) nginx使用zlib对http包进行gzip，所以需要zlib库 (zlib zlib-devel) nginx不仅支持http协议，还支持https协议（即在ssl协议上传输http），所以需要OpenSSL库 (openssl openssl-devel) 1 yum -y install gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel 在/usr/local目录下创建nginx目录 1 mkdir /usr/local/nginx 下载nginx解压包到/opt目录下 nginx下载地址：nginx download\n选择其中自己需要的版本，我这里选择1.22.1版本 1 2 3 4 # 到 /opt目录下 cd /opt # 下载nginx wget https://nginx.org/download/nginx-1.22.1.tar.gz 解压安装包，并配置编译安装nginx 解压安装包 1 tar -zxvf nginx-1.22.1.tar.gz 进入nginx-1.22.1目录中 1 cd nginx-1.22.1 配置 1 ./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module 编译和安装 1 2 3 4 # 编译 make # 安装 make install 注意：nginx配置的目标目录和配置编译安装的目录不能是同一个。比如这里配置的目标目录是/usr/local/nginx，用来配置编译安装的目录是/opt/nginx-1.22.1\n配置环境变量（方便快速启动nginx） 1 2 echo \u0026#34;export PATH=$PATH:/usr/local/nginx/sbin\u0026#34; \u0026gt;\u0026gt; /etc/profile source /etc/profile 启动关闭nginx服务 1 2 3 4 5 6 # 启动nginx服务 ./nginx # 修改配置后，重新加载配置 ./nginx -s reload # 关闭nginx服务 ./nginx -s stop 查询是否正在运行 用netstat查询是否正在运行 1 netstat -ntlp 没有netstat命令\n查询netstat命令在哪个包内 1 yum search netstat 下载net-tools包 1 yum -y install net-tools 再次查询 1 netstat -ntlp 说明启动成功\n打开80端口 nginx默认使用80端口，如果修改了，就需要开放相应的端口 1 2 3 4 5 6 # 查看80端口是否开启 firewall-cmd --query-port=80/tcp # 开启80端口 firewall-cmd --zone=public --add-port=80/tcp --permanent # 重启防火墙 firewall-cmd --reload 用浏览器访问 访问：http://192.168.172.136 ","date":"2025-10-12T20:46:14+08:00","permalink":"https://YLine-hub.github.io/p/centos7.6nginx%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/","title":"[CentOS7.6]nginx安装配置"},{"content":"环境 环境：\nVMware 虚拟机 CentOS7.6 目标：\nMySQL 5.7 准备资源 MySQL下载地址： MySQL Community Server\n查找所需mysql版本，我需要下载的是mysql5.7 这里我准备下载的是第一个tar.gz包，右键上图中的红框部分，复制下载链接，也可以直接下载下来上传到Linux服务器 复制的链接：\n1 https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.44-linux-glibc2.12-x86_64.tar.gz 安装 创建mysql所属组、用户 即使mysql服务被黑掉，得到了mysql用户权限，也不会影响整个系统的安全 1 2 3 4 # 创建新组mysql groupadd mysql # 创建用户mysql，指定属组为mysql，禁止其登陆 useradd -r -g mysql mysql -s /sbin/nologin 下载mysql安装、解压，并放到/usr/local目录下 进入/opt目录下 1 cd /opt 下载mysql的tar.gz包 1 wget https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.44-linux-glibc2.12-x86_64.tar.gz 解压下载好的压缩包 1 tar -zxvf mysql-5.7.44-linux-glibc2.12-x86_64.tar.gz 解压完成后将其移动到/usr/local目录下并改文件夹名为mysql（规范） 1 mv mysql-5.7.44-linux-glibc2.12-x86_64 /usr/local/mysql 配置mysql 创建所需目录 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 创建存储数据目录 mkdir /usr/local/mysql/data # 创建数据日志目录 mkdir /usr/local/mysql/log # 创建临时文件目录 mkdir /usr/local/mysql/tmp # 创建运行文件目录 mkdir /usr/local/mysql/run # 创建启动错误日志 touch /usr/local/mysql/log/mysqld_safe_error.log # 创建默认的错误日志目的地 touch /usr/local/mysql/log/alert.log # 创建慢查询日志文件 touch /usr/local/mysql/log/slow.log # 创建通用查询日志文件 touch /usr/local/mysql/log/general.log 编辑配置文件 1 vim /etc/my.cnf 使用:1,$d清空文件内容 my.cnf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 # mysqld_safe脚本启动时读取的配置 [mysqld_safe] # 存放MySQL后台程序pid的文件位置 pid-file=/usr/local/mysql/run/mysqld.pid # 启动错误日志 log-error=/usr/local/mysql/log/mysqld_safe_error.log # 本地mysql客户端程序的配置 [mysql] # 本地mysql客户端连接的端口 port=3306 # 本地mysql客户端命令提示信息 prompt=\\\\u@\\\\d \\\\r:\\\\m:\\\\s\u0026gt; # 本地mysql客户端字符集 default-character-set=utf8mb4 # 开启命令补全 no-auto-rehash # 所有mysql客户端程序读取的配置块 [client] # 连接端口 port=3306 # mysql的主机和客户机在同一host上的时候，使用unix domain socket作为通讯协议的载体文件 socket=/usr/local/mysql/run/mysql.sock # mysql服务端程序mysqld、mysqld_safe和mysqld_multi的配置文件 [mysqld] # 进程崩溃时生成core file dump文件，便于程序调试和问题排查 core-file # 该参数指定了安装mysql的安装路径（mysql安装目录），填写全路径可以解决相对路径所造成的问题。 basedir=/usr/local/mysql # 启动bin_log log-bin=mysql-bin server-id=1 binlog_format=ROW # 该参数指定了mysql的数据文件的存放目录，数据库文件即我们常说的mysql data文件。 datadir=/usr/local/mysql/data # 临时目录 tmpdir=/usr/local/mysql/tmp # 用于错误消息的区域设置。默认值时en_US。服务器将参数转换为语言名，并将其与lc_messages_dir的值结合，以生成错误消息文件的位置。 lc_messages=en_US # 错误消息所在目录。服务器使用该值和lc_messages的值来生成错误消息文件的位置。 lc_messages_dir=/usr/local/mysql/share # 默认的错误日志目的地。如果目标是控制台，则值为stderr。否则，目标是一个文件，log_error值时文件名。 log-error=/usr/local/mysql/log/alert.log # 慢查询日志文件名。默认值是host_name-slow.log，但可以通过slow_query_log_file选项更改初始值。 slow_query_log_file=/usr/local/mysql/log/slow.log # 通用查询日志文件的名称。默认值是host_name.log，但初始值可以通过general_log_file选项更改。 general_log_file=/usr/local/mysql/log/general.log # mysql的主机和客户机在同一host上的时候，使用unix domain socket作为通讯协议的载体文件 socket=/usr/local/mysql/run/mysql.sock # 服务端字符集 character-set-server=utf8mb4 # 此变量控制写入错误日志的消息中的时间戳的时区，以及写入文件的一般查询日志和慢查询日志消息中的时间戳的时区。 log_timestamps=SYSTEM # 操作系统中可用于mysqld的文件描述符的数量 open_files_limit=61535 # 同时允许的最大客户连接数 max_connections=1000 # mysql_stmt_send_long_data() C API函数发送的一个包或任何生成/中间字符串的最大大小，或任何参数的最大大小。默认是64MB。 max_allowed_packet=1G # 如果设置为0，表名将按指定的方式存储，并且比较区分大小写。如果设置为1，表名将以小写形式存储在磁盘上，比较不区分大小写。如果设置为2，则表名按给定值存储，但以小写进行比较。此选项也适用于数据库名称和表别名。 lower_case_table_names=1 # 慢查询日志是否开启。取值为0（或OFF）表示关闭日志，取值为1（或ON）表示打开日志。默认值取决于是否给出--slow_query_log选项。日志输出的目标由log_output系统变量控制；如果该值为NONE，则即使启用了日志，也不会写入任何日志项。 slow_query_log=1 # validate_password插件的加载方法 plugin-load-add=validate_password.so # validate-password在服务器启动时使用该选项来控制插件的激活 validate-password=FORCE_PLUS_PERMANENT 初始化数据库 设置环境变量 1 2 3 4 5 6 # 将mysql/bin路径添加到配置文件（根据自己的路径修改） # 记住必须要用 \u0026gt;\u0026gt; 而不是 \u0026gt; # 如果当心文件被覆盖可以打开/etc/profile文件，将下面这句写到文件最后面 echo \u0026#34;export PATH=$PATH:/usr/local/mysql/bin\u0026#34; \u0026gt;\u0026gt; /etc/profile # 生效配置文件 source /etc/profile 将安装目录的所有权授予用户、属组 mysql:mysql 1 chown -R mysql:mysql /usr/local/mysql 初始化数据库 1 mysqld --initialize --user=mysql --basedir=/usr/local/mysql/ --datadir=/usr/local/mysql/data/ 查询mysql初始密码 1 grep -e \u0026#39;temporary\u0026#39; /usr/local/mysql/log/alert.log 可以看到初始密码：kv?kghe.C5:x\n再次将安装目录的所有全授予用户、属组 mysql:mysql 1 chown -R mysql:mysql /usr/local/mysql 将安装目录的 rwx 授予其所属用户mysql 1 chmod -R 755 /usr/local/mysql 复制启动文件到/etc/init.d目录下 1 cp -ar /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld 启动mysql服务 \u0026amp;\u0026amp; 设置开机自启动 启动mysql服务 1 /etc/init.d/mysqld start 其他命令:\n1 2 3 /etc/init.d/mysqld stop # 停止mysql /etc/init.d/mysqld restart # 重启mysql /etc/init.d/mysqld status # 查看mysql状态 设置开机自启动 1 2 3 4 // 添加服务 chkconfig --add mysqld // 显示服务列表 chkconfig --list 开机自启设置成功\n登陆mysql \u0026amp;\u0026amp; 修改mysql密码 1 mysql -uroot -p 输入密码（在这里输入密码是看不到的） 降低密码验证等级 1 2 3 4 # 设置密码验证安全级别 set global validate_password_policy=LOW; # 设置密码验证最小长度 set global validate_password_length=6; 修改登陆密码（修改为123456） 1 set password for root@localhost = password(\u0026#39;123456\u0026#39;); 查看密码验证规则 1 SHOW VARIABLES LIKE \u0026#39;validate_password%\u0026#39;; 开放远程登陆 \u0026amp;\u0026amp; 放行3306端口 开放远程登陆 1 2 3 4 5 6 # 登录进来之后，切换到mysql库 use mysql; # 修改用户权限 update user set user.Host=\u0026#39;%\u0026#39; where user.User=\u0026#39;root\u0026#39;; # 刷新权限 flush privileges; 退出mysql 1 2 3 exit; # 或者 ctrl+d 放行3306端口 1 2 3 4 5 6 # 检查3306端口是否放行 firewall-cmd --query-port=3306/tcp # 打开3306端口 firewall-cmd --zone=public --add-port=3306/tcp --permanent # 重新加载防火墙 firewall-cmd --reload 测试连接 Navicat破解：Navicat Cracker ","date":"2025-10-12T17:33:04+08:00","permalink":"https://YLine-hub.github.io/p/centos7.6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmysql5.7%E4%BC%98%E5%8C%96/","title":"【CentOS7.6】安装配置mysql5.7(优化)"},{"content":"二进制包/源码安装方式的mysql卸载 检查mysql服务并关闭进程 查看mysql进程 1 ps -ef | grep mysql 查看mysql状态 1 /etc/init.d/mysqld status 关闭mysql 1 /etc/init.d/mysqld stop 再次查看mysql的状态和有关mysql的进程 1 2 /etc/init.d/mysqld status ps -ef | grep mysql 关闭mysql用户的进程 其实上图是，我用roo su mysql后进入mysql用户的命令行，之后又su root用mysql打开root账号，所以只需要exit两边即可\n1 2 3 4 $ exit exit $ exit exit 再次查看进程 1 ps -ef | grep mysql 查找mysql的安装目录并彻底删除 查找mysql有关的目录 1 2 whereis mysql find / -name mysql 全部删除 1 2 3 4 rm -rf /usr/lib64/mysql/ rm -rf /usr/local/mysql/ rm -rf /run/sudo/ts/mysql rm -rf /etc/selinux/targeted/active/modules/100/mysql 删除一些配置文件 /etc/my.cnf /etc/init.d/mysqld 1 2 rm -rf /etc/my.cnf rm -rf /etc/init.d/mysqld 删除mysql用户以及用户组 1 2 userdel -r mysql groupdel mysql 查询mysql是否还存在 1 id mysql ","date":"2025-10-12T15:43:16+08:00","permalink":"https://YLine-hub.github.io/p/centos7.6%E5%BD%BB%E5%BA%95%E5%8D%B8%E8%BD%BDmysqltar.gz/","title":"【CentOS7.6】彻底卸载mysql(tar.gz)"},{"content":"MySQL安装配置 环境 环境：\nVMware 虚拟机 CentOS7.6 目标：\nMySQL 5.7 准备资源 MySQL下载地址： MySQL Community Server\n查找所需mysql版本，我需要下载的是mysql5.7 这里我准备下载的是第一个tar.gz包，右键上图中的红框部分，复制下载链接，也可以直接下载下来上传到Linux服务器 复制的链接：\n1 https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.44-linux-glibc2.12-x86_64.tar.gz 安装 安装前检测 检查服务器是否安装过mysql，以及是否有自带的mariadb 1 2 rpm -qa | grep mysql rpm -qa | grep mariadb mariadb 其实就是 mysql，只不过是 mysql 的另一种拉出来的开源分支，也可以正常使用，如果不想卸载也是可以的。\n卸载相应的服务（若没有则跳过该阶段） 卸载mysql 1 2 3 4 5 6 7 8 9 10 11 # 卸载mysql yum -y remove MySQL* # 查找mysql目录并统一删除 find / -name mysql # 删除mysql配置文件 rm -rf /etc/my.cnf # 删除mysql默认密码（若不删除，以后安装mysql后这个sercret中的默认密码不会变，使用其中的默认密码就可能会报类似Access denied for user \u0026#39;root@localhost\u0026#39; (using password:yes)的错误。） rm -rf /root/.mysql_sercret 卸载mariadb 1 rpm -e --nodeps mariadb-libs-5.5.68-1.el7.x86_64 查看my.cnf和.mysql_sercret是否存在，有的话需要删除 1 2 cat /etc/my.cnf cat /root/.mysql_sercret 将mysql5.7的tar.gz包下载到/opt目录下 1 2 cd /opt wget https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.44-linux-glibc2.12-x86_64.tar.gz 等待下载完成 解压下载好的压缩包 1 tar -zxvf mysql-5.7.44-linux-glibc2.12-x86_64.tar.gz 解压完成后将其移动到/usr/local下并改文件名为mysql（规范） 1 mv mysql-5.7.44-linux-glibc2.12-x86_64 /usr/local/mysql 检查是否创建了mysql组和用户，没有的话需要创建 1 2 3 4 # mysql组 cat /ect/group | grep mysql # mysql用户 cat /etc/passwd | grep mysql 创建一个mysql组和用户 1 2 groupadd mysql useradd -r -g mysql mysql # -r 指的是创建一个系统账户 创建完检查 1 2 cat /etc/group | grep mysql cat /etc/passwd | grep mysql 更改mysql目录下所有文件夹所属的用户组、用户以及文件权限 切换到/usr/local目录下 1 cd /usr/local 更改mysql目录及其所有子目录和文件的用户组和用户为mysql 1 chown -R mysql:mysql mysql 给mysql目录下所有文件加执行权限 1 chmod -R 775 mysql 修改完可以使用ll查看一下 设置环境变量 1 2 3 4 5 6 # 将mysql/bin路径添加到配置文件（根据自己的路径修改） # 记住必须要用 \u0026gt;\u0026gt; 而不是 \u0026gt; # 如果当心文件被覆盖可以打开/etc/profile文件，将下面这句写到文件最后面 echo \u0026#34;export PATH=$PATH:/usr/local/mysql/bin\u0026#34; \u0026gt;\u0026gt; /etc/profile # 生效配置文件 source /etc/profile 检查是否生效 1 mysql --version 生成mysql临时密码 1 2 # 执行命令。生成临时数据库密码（还是注意路径看看是不是和你的一样） mysqld --user=mysql --initialize --datadir=/usr/local/mysql/data 生成的临时密码是： u\u0026lt;kW;59g?Ut% 千万要把临时密码记住，到后面修改完密码之后，就可以不用了；\n复制启动文件到/etc/init.d/目录 把启动脚本mysql.server放到目录/etc/init.d/，同时改名为mysqld。 1 cp -ar /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld 1 2 # 编辑文件 vim /etc/init.d/mysqld 检查以下这几个路径是否正确 创建所需目录 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 创建存储数据目录 mkdir /usr/local/mysql/data # 创建数据日志目录 mkdir /usr/local/mysql/log # 创建临时文件目录 mkdir /usr/local/mysql/tmp # 创建运行文件目录 mkdir /usr/local/mysql/run # 创建启动错误日志 touch /usr/local/mysql/log/mysqld_safe_error.log # 创建默认的错误日志目的地 touch /usr/local/mysql/log/alert.log # 创建慢查询日志文件 touch /usr/local/mysql/log/slow.log # 创建通用查询日志文件 touch /usr/local/mysql/log/general.log 添加my.cnf配置文件 切换到/etc/目录下 1 cd /etc/ 创建一个mysql的配置文件my.cnf 1 touch my.cnf MySQL5.7的my.cnf详细说明可以参考官方解释：\nUsing Option Files Using Options to Set Program Variables centos7 mysql5.7开启binlog：centos7 mysql5.7开启binlog\nmy.cnf配置示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 # mysqld_safe脚本启动时读取的配置 [mysqld_safe] # 存放MySQL后台程序pid的文件位置 pid-file=/usr/local/mysql/run/mysqld.pid # 启动错误日志 log-error=/usr/local/mysql/log/mysqld_safe_error.log # 本地mysql客户端程序的配置 [mysql] # 本地mysql客户端连接的端口 port=3306 # 本地mysql客户端命令提示信息 prompt=\\\\u@\\\\d \\\\r:\\\\m:\\\\s\u0026gt; # 本地mysql客户端字符集 default-character-set=utf8mb4 # 开启命令补全 no-auto-rehash # 所有mysql客户端程序读取的配置块 [client] # 连接端口 port=3306 # mysql的主机和客户机在同一host上的时候，使用unix domain socket作为通讯协议的载体文件 socket=/usr/local/mysql/run/mysql.sock # mysql服务端程序mysqld、mysqld_safe和mysqld_multi的配置文件 [mysqld] # 进程崩溃时生成core file dump文件，便于程序调试和问题排查 core-file # 该参数指定了安装mysql的安装路径（mysql安装目录），填写全路径可以解决相对路径所造成的问题。 basedir=/usr/local/mysql # 启动bin_log log-bin=mysql-bin server-id=1 binlog_format=ROW # 该参数指定了mysql的数据文件的存放目录，数据库文件即我们常说的mysql data文件。 datadir=/usr/local/mysql/data # 临时目录 tmpdir=/usr/local/mysql/tmp # 用于错误消息的区域设置。默认值时en_US。服务器将参数转换为语言名，并将其与lc_messages_dir的值结合，以生成错误消息文件的位置。 lc_messages=en_US # 错误消息所在目录。服务器使用该值和lc_messages的值来生成错误消息文件的位置。 lc_messages_dir=/usr/local/mysql/share # 默认的错误日志目的地。如果目标是控制台，则值为stderr。否则，目标是一个文件，log_error值时文件名。 log-error=/usr/local/mysql/log/alert.log # 慢查询日志文件名。默认值是host_name-slow.log，但可以通过slow_query_log_file选项更改初始值。 slow_query_log_file=/usr/local/mysql/log/slow.log # 通用查询日志文件的名称。默认值是host_name.log，但初始值可以通过general_log_file选项更改。 general_log_file=/usr/local/mysql/log/general.log # mysql的主机和客户机在同一host上的时候，使用unix domain socket作为通讯协议的载体文件 socket=/usr/local/mysql/run/mysql.sock # 服务端字符集 character-set-server=utf8mb4 # 此变量控制写入错误日志的消息中的时间戳的时区，以及写入文件的一般查询日志和慢查询日志消息中的时间戳的时区。 log_timestamps=SYSTEM # 操作系统中可用于mysqld的文件描述符的数量 open_files_limit=61535 # 同时允许的最大客户连接数 max_connections=1000 # mysql_stmt_send_long_data() C API函数发送的一个包或任何生成/中间字符串的最大大小，或任何参数的最大大小。默认是64MB。 max_allowed_packet=1G # 如果设置为0，表名将按指定的方式存储，并且比较区分大小写。如果设置为1，表名将以小写形式存储在磁盘上，比较不区分大小写。如果设置为2，则表名按给定值存储，但以小写进行比较。此选项也适用于数据库名称和表别名。 lower_case_table_names=1 # 慢查询日志是否开启。取值为0（或OFF）表示关闭日志，取值为1（或ON）表示打开日志。默认值取决于是否给出--slow_query_log选项。日志输出的目标由log_output系统变量控制；如果该值为NONE，则即使启用了日志，也不会写入任何日志项。 slow_query_log=1 # validate_password插件的加载方法 plugin-load-add=validate_password.so # validate-password在服务器启动时使用该选项来控制插件的激活 validate-password=FORCE_PLUS_PERMANENT 给mysql的配置文件添加执行权限 1 chmod -R 775 /etc/my.cnf 启动mysql服务 \u0026amp;\u0026amp; 设置开机自启 启动前先查询是否启动过 1 2 ps -ef|grep -v grep |grep mysql ps -ef|grep -v grep |grep mysqld 启动mysql服务 1 /etc/init.d/mysqld start 启动失败 1 Starting MySQL.. ERROR! The server quit without updating PID file (/usr/local/mysql/data/localhost.yline.pid). 替换配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 [client] default-character-set = utf8mb4 [mysql] default-character-set = utf8mb4 [mysqld] port = 3306 basedir = /usr/local/mysql datadir = /usr/local/mysql/data socket = /usr/local/mysql/run/mysql.sock symbolic-links = 0 log-error = /usr/local/mysql/log/alert.log pid-file = /usr/local/mysql/run/mysqld.pid # 禁用主机名解析 skip-name-resolve # 默认的数据库引擎 default-storage-engine = InnoDB innodb-file-per-table = 1 innodb_force_recovery = 1 group_concat_max_len = 10240 sql_mode = NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES expire_logs_days = 7 memlock # 字符集配置 character-set-client-handshake = FALSE character-set-server = utf8mb4 collation-server = utf8mb4_unicode_ci init_connect = \u0026#39;SET NAMES utf8mb4\u0026#39; # GTID 配置 server_id = 330759 binlog_format = row gtid_mode = on enforce-gtid-consistency = true log_bin = mysql57-bin log-slave-updates = on skip_slave_start = 1 # 慢查询日志 slow_query_log = 1 long_query_time = 2 log_queries_not_using_indexes = 0 slow_query_log_file = /usr/local/mysql/log/slow.log # 自动修复 relay_log_info_repository = TABLE master_info_repository = TABLE relay_log_recovery = on relay_log_purge = 1 # 数据安全性配置 log_bin_trust_function_creators = on sync_binlog = 1 explicit_defaults_for_timestamp = true # 优化配置 ft_min_word_len = 1 lower_case_table_names = 1 max_allowed_packet = 256M query_cache_size = 64M query_cache_limit = 1M join_buffer_size = 16M thread_cache_size = 64 # InnoDB 优化 innodb_buffer_pool_size = 2G innodb_log_file_size = 256M innodb_log_buffer_size = 4M innodb_flush_log_at_trx_commit = 1 innodb_log_files_in_group = 3 innodb_file_per_table = 1 innodb_write_io_threads = 8 innodb_read_io_threads = 8 innodb_purge_threads = 1 innodb_max_dirty_pages_pct = 90 innodb_lock_wait_timeout = 120 innodb_strict_mode = 1 innodb_large_prefix = on [mysqldump] quick default-character-set = utf8mb4 max_allowed_packet = 256M 还是如下报错： 1 Starting MySQL.. ERROR! The server quit without updating PID file (/usr/local/mysql/data/mysqld.pid). 找到原因：一般是root用户执行导致，如果是root以外的用户执行不会报错\n解决方法：修改/usr/local/mysql/support-files/mysql.server和/etc/init.d/mysqld文件\n编辑/usr/local/mysql/support-files/mysql.server和/etc/init.d/mysqld文件 1 2 3 4 5 # 编辑/usr/local/mysql/support-files/mysql.server vim /usr/local/mysql/support-files/mysql.server # 编辑/etc/init.d/mysqld vim /etc/init.d/mysqld 使用/+关键字找到$bindir/mysqld_safe 在后面添加 --user=root 按esc，然后用:wq保存文件 重新启动 1 /etc/init.d/mysqld start 启动成功\n设置开机自启 1 2 3 4 // 添加服务 chkconfig --add mysqld // 显示服务列表 chkconfig --list 开机自启设置成功\n登陆mysql \u0026amp;\u0026amp; 修改mysql密码 1 mysql -uroot -p 输入密码（在这里输入密码是看不到的） 出现报错 1 ERROR 2002 (HY000): Can\u0026#39;t connect to local MySQL server through socket \u0026#39;/tmp/mysql.sock\u0026#39; (2) 解决方法：在/tmp下做一个mysql.sock的软链接 1 ln -s /usr/local/mysql/run/mysql.sock /tmp/mysql.sock 重新登陆 1 mysql -uroot -p 登陆进来后修改密码（修改为123456） 1 set password for root@localhost = password(\u0026#39;123456\u0026#39;); 修改成功\n按ctrl+d退出重新试一下 再次登陆 1 mysql -uroot -p123456 开放远程登陆 \u0026amp;\u0026amp; 测试本地客户端连接 开放远程登陆 1 2 3 4 5 6 #登录进来之后，切换到mysql库 use mysql; #修改用户权限 update user set user.Host=\u0026#39;%\u0026#39; where user.User=\u0026#39;root\u0026#39;; #刷新权限 flush privileges; 防火墙放行3306端口 1 2 3 4 5 6 # 检查3306端口是否放行 firewall-cmd --query-port=3306/tcp # 打开3306端口 firewall-cmd --zone=public --add-port=3306/tcp --permanent # 重新加载防火墙 firewall-cmd --reload 连接测试 准备工具：Navicat Cracker 或者 navicat-keygen-16 ","date":"2025-10-11T18:34:30+08:00","permalink":"https://YLine-hub.github.io/p/centos7.6mysql%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/","title":"【CentOS7.6】MySQL安装配置"},{"content":"jdk8安装配置 环境：\nCentOS7.6 64位系统 查询系统位数\n64位系统：x686或x86_64 32位系统：i686或i386 1 uname -m 可以看到我的系统是64位的\n方法一（推荐） 手动下载安装包 Java SE 8 - Oracle 通过MobaXterm上传到/opt目录下 MobaXterm选中内容将会自动复制 注意：上传文件的路径建议用英文。如果用中文的话可能会导致文件无法上传。\n解压安装包 1 2 cd /opt tar -zxvf jdk-8u202-linux-x64.tar.gz 将解压的文件夹移动到/usr/local下并改为java 解压完成后，当前目录会有一个jdk1.8.0_202的文件夹。将文件夹移动到/usr/local/java下（一般安装的软件都会放到/usr/local/目录下）。 1 2 # 将文件移动到/usr/local目录下，并将文件名改为java mv jdk1.8.0_202/ /usr/local/java 设置环境变量 编辑profile文件 1 vim /etc/profile 配置环境变量 1 2 3 export JAVA_HOME=/usr/local/java export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=$PATH:$JAVA_HOME/bin 使环境变量生效 1 source /etc/profile 验证是否完成安装 1 java -version 方法二 查询系统是否有jdk 1 2 3 java -version rpm -qa | grep java 批量卸载系统自带 1 2 3 rpm -qa | grep java | xargs rpm -e --nodeps # 或者 rpm -e --nodeps java* 检查yum中是否有java安装包 1 yum list java* 找到自己需要的jdk8 使用yum安装jdk8 1 yum install -y java-1.8.0-openjdk 验证 1 java -version ","date":"2025-10-10T15:27:53+08:00","permalink":"https://YLine-hub.github.io/p/centos7.6jdk8%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/","title":"【CentOS7.6】jdk8安装配置"},{"content":"Shell文件包含 介绍 和其他语言一样，Shell 也可以包含外部脚本。 可以很方便的封装一些公用的代码作为一个独立的文件。 基本语法 1 2 3 4 5 . filename # 注意点号(.)和文件名中间有一空格 或 source filename 示例 创建脚本1：include1.sh 1 2 3 #!/bin/bash url=\u0026#34;www.baidu.com\u0026#34; 创建脚本2：include2.sh 1 2 3 4 5 6 7 8 9 #!/bin/bash # 使用.号来引用include1.sh文件 . ./include1.sh # 或者使用以下包含文件代码 # source ./include1.sh echo \u0026#34;百度地址：$url\u0026#34; 为include2.sh添加执行权限并执行 1 2 chmod +x include2.sh ./include2.sh 注：被包含的文件 test1.sh 不需要可执行权限。\n","date":"2025-10-10T15:06:21+08:00","permalink":"https://YLine-hub.github.io/p/shell%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/","title":"Shell文件包含"},{"content":"Shell 输入/输出重定向 重定向命令列表\n命令 说明 command \u0026gt; file 将输出重定向到file command \u0026lt; file 将输入重定向到file command \u0026raquo; file 将输出以追加的方式重定向到file n \u0026gt; file 将文件描述符为n的文件重定向到file n \u0026raquo; file 将文件描述符为n的文件以追加的方式重定向到file n \u0026gt;\u0026amp; m 将输出文件m和n合并 n \u0026lt;\u0026amp; m 将输入文件m和n合并 \u0026laquo; tag 将开始标记tag和结束标记tag之间的内容作为输入 需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。\nShell输出重定向 基本语法 1 command1 \u0026gt; file1 示例 将命令的完整的输出重定向在用户文件中(users)，没有users文件会自动创建 1 who \u0026gt; users 查看文件内容 1 cat users 输出重定向会覆盖文件内容 1 echo \u0026#34;www.baidu.com\u0026#34; \u0026gt; users 如果不希望文件内容被覆盖，可以使用\u0026raquo;追加到文件末尾 1 echo \u0026#34;www.google.com\u0026#34; \u0026gt;\u0026gt; users Shell输入重定向 基本语法 1 command1 \u0026lt; file1 示例 统计users文件的行数 1 wc -l users 也可也将输入重定向到users文件 1 wc -l \u0026lt; users 注意：上述两个例子结果不同：第一个例子会输出文件名，第二个不会，因为他仅仅知道从标准输入读取内容。\n同时替换输入和输出，执行命令command1，从文件infile读取内容，然后将输出写入到outfile 1 command1 \u0026lt; infile \u0026gt; outfile 统计users文件的行数，并输出到linefile文件内 重定向深入讲解 一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：\n标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。 基本语法 如果希望stderr重定向到file 1 command 2\u0026gt;file 如果希望 stderr 追加到 file 文件末尾 1 command 2\u0026gt;\u0026gt;file 2 表示标准错误文件(stderr)。\n如果希望将 stdout 和 stderr 合并后重定向到 file 1 2 3 4 5 command \u0026gt; file 2\u0026gt;\u0026amp;1 # 或者 command \u0026gt;\u0026gt; file 2\u0026gt;\u0026amp;1 如果希望对 stdin 和 stdout 都重定向 1 command \u0026lt; file1 \u0026gt;file2 Here Document 介绍 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。 基本语法 将两个 delimiter 之间的内容(document) 作为输入传递给 command。 1 2 3 command \u0026lt;\u0026lt; delimiter document delimiter 注意：\n结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。 开始的delimiter前后的空格会被忽略掉。 示例 在命令行中通过wc -l命令计算Here Document的行数 1 2 3 4 5 $ wc -l \u0026lt;\u0026lt; EOF \u0026gt; www.baidu.com \u0026gt; www.google.com \u0026gt; EOF 2 # 输出结果为2行 也可也将Here Document用在脚本中 1 2 3 4 5 6 #!/bin/bash cat \u0026lt;\u0026lt; EOF www.baidu.com www.google.com EOF /dev/null 文件 介绍 如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null 1 command \u0026gt; /dev/null /dev/null /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃。 如果尝试从该文件读取内容，那么什么也读不到。 但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到\u0026quot;禁止输出\u0026quot;的效果。 如果希望屏蔽 stdout 和 stderr\n1 command \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 注意：0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。 这里的 2 和 \u0026gt; 之间不可以有空格，2\u0026gt; 是一体的时候才表示错误输出。 ","date":"2025-10-10T14:18:27+08:00","permalink":"https://YLine-hub.github.io/p/shell%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/","title":"Shell输入输出重定向"},{"content":"Shell 函数 介绍 用户定义函数，然后在shell脚本中可以随便调用。 基本语法 1 2 3 4 5 6 [ function ] funname [()] { action; [return int;] } 说明：\n1、可以带function fun()定义，也可也直接fun()定义，不带任何参数 2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。return 后跟数值n(0-255) 示例 第一个函数 1 2 3 4 5 6 7 8 #!/bin/bash demoFun(){ echo \u0026#34;这是我的第一个 shell 函数！\u0026#34; } echo \u0026#34;-----函数开始执行-----\u0026#34; demoFun echo \u0026#34;-----函数执行完毕-----\u0026#34; 输出：\n1 2 3 -----函数开始执行----- 这是我的第一个 shell 函数! -----函数执行完毕----- 定义带有return语句的函数 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/bash funWithReturn(){ echo \u0026#34;这个函数会对输入的两个数进行相加运算...\u0026#34; echo \u0026#34;输入第一个数字：\u0026#34; read aNum echo \u0026#34;输入第二个数字：\u0026#34; read bNum echo \u0026#34;两个数字分别为 $aNum 和 $bNum !\u0026#34; return $(($aNum+$bNum)) } funWithReturn echo \u0026#34;输入的两个数字之和为 $? !\u0026#34; 函数返回值在调用该函数后通过$?来获得\n注意： return 语句只能返回一个介于0到255之间的整数，而两个数字的和可能超过这个范围，要解决这个问题，您可以修改return语句，直接使用echo输出而不是使用return：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/bash funWithReturn(){ echo \u0026#34;这个函数会对输入的两个数进行相加运算...\u0026#34; echo \u0026#34;输入第一个数字：\u0026#34; read aNum echo \u0026#34;输入第二个数字：\u0026#34; read bNum echo \u0026#34;两个数字分别为 $aNum 和 $bNum !\u0026#34; sum=$(($aNum + $bNum)) echo \u0026#34;两个数字之和为 $sum\u0026#34; } funWithReturn 函数参数 介绍 在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数\u0026hellip; 示例 1 2 3 4 5 6 7 8 9 10 11 12 #!/bin/bash funWithParam(){ echo \u0026#34;第一个参数为 $1 !\u0026#34; echo \u0026#34;第二个参数为 $2 !\u0026#34; echo \u0026#34;第十个参数为 $10 !\u0026#34; echo \u0026#34;第十个参数为 ${10} !\u0026#34; echo \u0026#34;第十一个参数为 ${11} !\u0026#34; echo \u0026#34;参数总数有 $# 个!\u0026#34; echo \u0026#34;作为一个字符串输出所有参数 $* !\u0026#34; } funWithParam 1 2 3 4 5 6 7 8 9 34 73 注意： $10 不能获取第十个参数，获取第十个参数需要${10}。当n\u0026gt;=10时，需要使用${n}来获取参数。\n特殊参数： 参数处理 说明 $# 传递到脚本或函数的参数个数 $* 以一个单字符串显示所有向脚本传递的参数 $$ 脚本运行的当前进程ID号 $! 后台运行的最后一个进程的ID号 $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。 $- 显示Shell使用的当前选项，与set命令功能相同 $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 ","date":"2025-10-10T13:02:15+08:00","permalink":"https://YLine-hub.github.io/p/shell%E5%87%BD%E6%95%B0/","title":"Shell函数"},{"content":"echo 介绍 用于在标准输出（通常是终端）显示一行文本或变量的值。 语法格式 1 echo [options] string 基本用法 简单文本输出 1 echo \u0026#34;Hello, World!\u0026#34; 输出：\n1 Hello, World! 输出变量 1 2 name=\u0026#34;Linux User\u0026#34; echo \u0026#34;Welcome, $name\u0026#34; 输出：\n1 Welcome, Linux User! 不带引号的输出（不建议） 1 echo This is a test 输出：\n1 This is a test printf 介绍 用于格式化输出的 Shell 命令，它源自 C 语言的 printf() 函数。 基本语法 1 printf format-string [arguments...] 参数说明：\nformat-string: 包含普通字符和格式说明符的字符串 arguments\u0026hellip;: 与格式说明符对应的变量或值 常用格式说明符：\n%s: 字符串 %d: 十进制整数 %f: 浮点数 %c: 字符 %x: 十六进制数 %o: 八进制数 %b: 二进制数 %e: 科学计数法表示的浮点数 示例 基本使用 1 2 3 4 5 6 7 8 #!/bin/bash # 简单字符串输出 printf \u0026#34;Hello, World!\\n\u0026#34; # 带变量的输出 name=\u0026#34;Alice\u0026#34; printf \u0026#34;Hello, %s\\n\u0026#34; \u0026#34;$name\u0026#34; 输出：\n1 2 Hello, World! Hello, Alice 常用格式说明符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #!/bin/bash # 整数 # decimal adj、十进制的，小数的；n、十进制，小数 # hex n、十六进制 # octal adj、八进制的 prinf \u0026#34;Decimal: %d\\nHex: %x\\nOctal: %o\\n\u0026#34; 255 255 255 # 浮点数 # scientific adj、科学的；细致严谨的 printf \u0026#34;Float: %f\\nScientific: %e\\n\u0026#34; 3.14159 3.14159 # 字符串 printf \u0026#34;Name: %s\\n\u0026#34; \u0026#34;Bob\u0026#34; # 字符 printf \u0026#34;First letter: %c\\n\u0026#34; \u0026#34;A\u0026#34; 输出：\n1 2 3 4 5 6 7 Decimal: 255 Hex: ff Octal: 377 Float: 3.141590 Scientific: 3.141590e+00 Name: Bob First letter: A 格式化控制 1 2 3 4 5 6 7 8 9 10 #!/bin/bash # 字段宽度和对齐 printf \u0026#34;|%10s|\\n|%-10s|\\n\u0026#34; \u0026#34;right\u0026#34; \u0026#34;left\u0026#34; # 数字前导零 printf \u0026#34;Year: %04d\\n\u0026#34; 23 # 浮点数精度 printf \u0026#34;Pi: %.2f\\n\u0026#34; 3.14159 输出：\n1 2 3 4 | right| |left | Year: 0023 Pi: 3.14 多参数处理 1 2 3 #!/bin/bash printf \u0026#34;%-10s %5d %8.2f\\n\u0026#34; \u0026#34;Apple\u0026#34; 5 2.5 \u0026#34;Orange\u0026#34; 3 1.75 输出：\n1 2 Apple 5 2.50 Orange 3 1.75 扩展应用 创建表格输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/bin/bash # 表头 # quantity n、数量 printf \u0026#34;%-15s %10s %10s %10s\\n\u0026#34; \u0026#34;Item\u0026#34; \u0026#34;Quantity\u0026#34; \u0026#34;Price\u0026#34; \u0026#34;Total\u0026#34; # 分割线 printf \u0026#34;%-15s %10s %10s %10s\\n\u0026#34; \u0026#34;---------------\u0026#34; \u0026#34;----------\u0026#34; \u0026#34;----------\u0026#34; \u0026#34;----------\u0026#34; # 数据行 printf \u0026#34;%-15s %10s %10s %10s\\n\u0026#34; \u0026#34;Notebook\u0026#34; 3 2.50 7.50 printf \u0026#34;%-15s %10s %10s %10s\\n\u0026#34; \u0026#34;Pen\u0026#34; 5 1.20 6.00 printf \u0026#34;%-15s %10s %10s %10s\\n\u0026#34; \u0026#34;Eraser\u0026#34; 2 0.50 1.00 # 总计行 printf \u0026#34;%-15s %10s %10s %10.2f\\n\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;Total:\u0026#34; \u0026#34;14.50\u0026#34; 输出：\n1 2 3 4 5 6 Item Quantity Price Total --------------- ---------- ---------- ---------- Notebook 3 2.50 7.50 Pen 5 1.20 6.00 Eraser 2 0.50 1.00 Total: 14.50 进度条实现 1 2 3 4 5 6 7 #!/bin/bash for i in {1..20};do printf \u0026#34;\\rProgress: [%-20s] %d%%\u0026#34; $(printf \u0026#34;%${i}s\u0026#34; | tr \u0026#39; \u0026#39; \u0026#39;#\u0026#39;) $((i*5)) sleep 0.1 done printf \u0026#34;\\n\u0026#34; 颜色输出 1 2 3 4 5 6 7 #!/bin/bash RED=\u0026#39;\\033[0;31m\u0026#39; GREEN=\u0026#39;\\033[0;32m\u0026#39; NC=\u0026#39;\\033[0m\u0026#39; # No color printf \u0026#34;${RED}Error:${NC} Something went wrong\\n\u0026#34; printf \u0026#34;${GREEN}Success:${NC} Operation completed\\n\u0026#34; 格式输出： 1 2 3 4 5 6 #!/bin/bash printf \u0026#34;%-10s %-8s %-4s\\n\u0026#34; 姓名 性别 体重kg printf \u0026#34;%-10s %-8s %-4.2f\\n\u0026#34; 郭靖 男 66.1234 printf \u0026#34;%-10s %-8s %-4.2f\\n\u0026#34; 杨过 男 48.6543 printf \u0026#34;%-10s %-8s %-4.2f\\n\u0026#34; 郭芙 女 47.9876 输出：\n1 2 3 4 姓名 性别 体重kg 郭靖 男 66.12 杨过 男 48.65 郭芙 女 47.99 test 介绍 条件判断工具，用于评估表达式并返回布尔值（真/假），它通常与 if 语句结合使用。 语法格式 1 2 test expression 或 [ expression ] # 注意方括号内必须有空格 文件测试操作 常用文件测试选项 操作符 描述 示例 -e 文件是否存在 [ -e file.txt ] -f 是普通文件 [ -f /path/to/file ] -d 是目录 [ -d /path/to/dir ] -r 可读 [ -r file.txt ] -w 可写 [ -w file.txt ] -x 可执行 [ -x script.sh ] -s 文件大小\u0026gt;0 [ -s logfile ] -L 是符号链接 [ -L symlink ] 示例 1 2 3 4 5 6 7 8 9 10 11 #!/bin/bash file=\u0026#34;/etc/passwd\u0026#34; if [ -e \u0026#34;$file\u0026#34; ];then echo \u0026#34;$file 存在\u0026#34; if [ -r \u0026#34;$file\u0026#34; ];then echo \u0026#34;并且可读\u0026#34; fi else echo \u0026#34;$file 不存在\u0026#34; fi 输出：\n1 2 /etc/passwd 存在 /etc/passwd 可读 字符串比较 操作符 描述 示例 -z string 字符串为空 [ -z \u0026ldquo;$var\u0026rdquo; ] -n string 字符串非空 [ -n \u0026ldquo;$var\u0026rdquo; ] string1 = string2 字符串相等 [ \u0026ldquo;$var1\u0026rdquo; = \u0026ldquo;$var2\u0026rdquo; ] string1 != string2 字符串不等 [ \u0026ldquo;$var1\u0026rdquo; != \u0026ldquo;$var2\u0026rdquo; ] 示例 1 2 3 4 5 6 7 8 9 10 11 12 #!/bin/bash read -p \u0026#34;输入用户名：\u0026#34; username if [ -z \u0026#34;$username\u0026#34; ];then echo \u0026#34;错误：用户名不能为空\u0026#34; exit 1 elif [ \u0026#34;$username\u0026#34; = \u0026#34;root\u0026#34; ];then echo \u0026#34;警告：不建议使用root账号\u0026#34; else echo \u0026#34;欢迎，$username\u0026#34; fi 输出：\n1 2 输入用户名: yline 欢迎, yline 数值比较 操作符 描述 示例 -eq 等于 [ \u0026ldquo;$a\u0026rdquo; -eq \u0026ldquo;$b\u0026rdquo; ] -ne 不等于 [ \u0026ldquo;$a\u0026rdquo; -ne \u0026ldquo;$b\u0026rdquo; ] -gt 大于 [ \u0026ldquo;$a\u0026rdquo; -gt \u0026ldquo;$b\u0026rdquo; ] -ge 大于或等于 [ \u0026ldquo;$a\u0026rdquo; -ge \u0026ldquo;$b\u0026rdquo; ] -lt 小于 [ \u0026ldquo;$a\u0026rdquo; -lt \u0026ldquo;$b\u0026rdquo; ] -le 小于或等于 [ \u0026ldquo;$a\u0026rdquo; -le \u0026ldquo;$b\u0026rdquo; ] 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/bash read -p \u0026#34;输入年龄：\u0026#34; age if [ \u0026#34;$age\u0026#34; -lt 0 ];then echo \u0026#34;年龄不能为负数\u0026#34; elif [ \u0026#34;$age\u0026#34; -lt 18 ];then echo \u0026#34;未成年人\u0026#34; elif [ \u0026#34;$age\u0026#34; -ge 18 ] \u0026amp;\u0026amp; [ \u0026#34;$age\u0026#34; -lt 60 ];then echo \u0026#34;成年人\u0026#34; else echo \u0026#34;老年人\u0026#34; fi 输出：\n1 2 输入年龄: 12 未成年人 逻辑操作符 操作符 描述 示例 ! 逻辑非 [ ! -f \u0026ldquo;$file\u0026rdquo; ] -a 逻辑与 [ \u0026ldquo;$a\u0026rdquo; -eq 1 -a \u0026ldquo;$b\u0026rdquo; -eq 2 ] -o 逻辑或 [ \u0026ldquo;$a\u0026rdquo; -eq 1 -o \u0026ldquo;$b\u0026rdquo; -eq 2 ] **现代推荐写法：**使用\u0026amp;\u0026amp;和 替代-a和-o,更符合POSIX标准 高级用法：[[]] 和 （（）） 双括号[[]]\n支持模式匹配：[[ \u0026ldquo;$var\u0026rdquo; == *.txt ]] 支持正则表达式：[[ \u0026ldquo;$var\u0026rdquo; =~ ^[0-9]+$ ]] 更安全的字符串处理 算术比较(())\n专为数值比较设计：(( a \u0026gt; b )) 支持更复杂的算数表达式 示例\n1 2 3 4 5 6 7 8 9 #!/bin/bash if [[ \u0026#34;$file\u0026#34; == *.log ]];then echo \u0026#34;这是日志文件\u0026#34; fi if (( $count \u0026gt; 10 ));then echo \u0026#34;数量超过10\u0026#34; fi 实际应用示例 检查服务是否运行 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/bash read -p \u0026#34;请输入要查询的服务：\u0026#34; service if [ -z \u0026#34;$service\u0026#34; ];then echo \u0026#34;服务名不能为空\u0026#34; exit 1 elif systemctyl is-active --quiet \u0026#34;$service\u0026#34;; then echo \u0026#34;$service 正在运行\u0026#34; else echo \u0026#34;$service 未运行\u0026#34; # 可以添加启动服务的命令 fi 备份文件检查 1 2 3 4 5 6 7 8 9 10 11 12 #!/bin/bash backup_file=\u0026#34;/backups/data_$(date + %Y%m%d).tar.gz\u0026#34; if [ ! -f \u0026#34;$backup_file\u0026#34; ];then echo \u0026#34;错误：备份文件 $backup_file 不存在\u0026#34; exit 1 elif [ ! -s \u0026#34;$backup_file\u0026#34; ];then echo \u0026#34;警告：备份文件为空\u0026#34; else echo \u0026#34;备份验证成功\u0026#34; fi ","date":"2025-10-09T17:33:47+08:00","permalink":"https://YLine-hub.github.io/p/shell%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/","title":"Shell实用指令"},{"content":"基础元字符 元字符 作用 * 前一个字符匹配0次或任意多次 . 匹配除换行符外的任意一个字符 + 匹配前面的模式一次或多次 ? 匹配前面的模式0次或一次 ^ 匹配首行。例如，^hello会匹配以hello开头的行 $ 匹配行尾。例如，hello$会匹配以hello结尾的行 [] 匹配中括号中指定的任意一个字符，而且只匹配一个字符。例如，[aeiu]匹配任意一个元音字母，[0-9]匹配任意一位数字，[a-z][0-9]匹配由小写字母和一位数字构成的两位字符 [^] 匹配除中括号中字符外的任意一个字符。例如，[^0-9]匹配一位非数字字符，[^a-z]匹配任意一位非小写字母 \\ 转义符，用于取消特殊符号的含义 \\{n\\} 表示其前面的字符恰好出现n次。例如，[0-9]\\{4\\}匹配4位数字，[1][3-8][0-9]\\{9\\}匹配手机号码 \\{n,\\} 表示其前面的字符出现不少于n次。例如，[0-9]\\{2,\\}匹配两位以上的数字 \\{n,m\\} 表示其前面的字符至少出现n次，最多出现m次。例如，[a-z]\\{6,8\\}匹配6至8位的小写字母 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 示例1：使用.匹配任意字符 echo \u0026#34;cat dog pig\u0026#34; | grep \u0026#34;d.g\u0026#34; # 输出：dog # 示例2：使用*匹配零次或多次 echo \u0026#34;color colour\u0026#34; | grep \u0026#34;colou*r\u0026#34; # 输出：color colour # 示例3：使用^和$匹配行的开始和结束 echo -e \u0026#34;start\\nend\\nstart end\u0026#34; | grep \u0026#34;^start\u0026#34; # 输出：start start end # 示例4：使用字符集[] echo \u0026#34;bag big bog bug\u0026#34; | grep \u0026#34;b[aeiou]g\u0026#34; # 输出：bag big bog bug # 示例5：使用否定字符集[^] echo \u0026#34;bag big bog bug\u0026#34; | grep \u0026#34;b[^i]g\u0026#34; # 输出：bag bog bug Shell中使用正则表达式的工具 grep命令 语法格式 1 grep [options] pattern [file...] options: -E:使用扩展正则表达式 -i:忽略大小写 -v:反向匹配，显示不匹配的行 -n:显示匹配行的行号 -r:递归搜索目录 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 示例1：基本搜索 echo -e \u0026#34;apple\\nbanana\\ncherry\u0026#34; | grep \u0026#34;an\u0026#34; # 输出：banana # 示例2：使用-i忽略大小写 echo -e \u0026#34;Apple\\nbanana\\Cherry\u0026#34; | grep -i \u0026#34;a\u0026#34; # 输出：Apple # banana # 示例3：使用-v反向匹配 echo -e \u0026#34;apple\\nbanana\\ncherry\u0026#34; | grep -v \u0026#34;an\u0026#34; # 输出：apple # cheery # 示例4：使用-n显示行号 echo -e \u0026#34;apple\\nbanana\\ncheery\u0026#34; | grep -n \u0026#34;e\u0026#34; # 输出：1:apple # 3:cheery # 示例5：使用-E启用扩展正则表达式 echo -e \u0026#34;color\\ncolour\u0026#34; | grep -E \u0026#34;colou?r\u0026#34; # 输出：color # colour sed命令 语法格式 1 sed [opions] \u0026#39;command\u0026#39; [file...] 常用命令：\ns/pattern/replacement/：替换 /pattern/d：删除 /pattern/p：打印 options:\n-E：使用正则表达式 -i：直接修改文件内容 -n：抑制自动打印模式空间 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 示例1：基本替换 echo \u0026#34;Hello，World\u0026#34; | sed \u0026#39;s/World/Universe/\u0026#39; # 输出：Hello，Universe # 示例2：全局替换 echo \u0026#34;color color\u0026#34; | sed \u0026#39;s/color/colour/g\u0026#39; # 输出：colour colour # 示例3：删除匹配行 echo -e \u0026#34;apple\\nbanana\\ncherry\u0026#34; | sed \u0026#39;/banana/d\u0026#39; # 输出：apple # cherry # 示例4：只打印匹配行 echo -e \u0026#34;apple\\nbanana\\ncherry\u0026#34; | sed -n \u0026#39;/a/p\u0026#39; # 输出：apple # banana # 示例5：使用-E启用扩展正则表达式 echo \u0026#34;123-456-7890\u0026#34; | sed -E \u0026#39;s/([0-9]{3})-([0-9]{3})-([0-9]{4})/(\\1)\\2-\\3/\u0026#39; # 输出：(123)456-7890 # 其中\\1，\\2，\\3分别是第一个、第二个、第三个匹配的内容 awk命令 语法格式 1 awk [options] \u0026#39;pattern {action}\u0026#39; [file...] 常用内置变量： $0：整行内容 $1，$2，\u0026hellip;：第一个字段，第二个字段，以此类推 NF：字段数量 NR：当前处理的行号 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 示例1：打印特定列 echo -e \u0026#34;John 25\\nJane 30\\nBob 35\u0026#34; | awk \u0026#39;{print $1}\u0026#39; # 输出：John # Jane # Bob # 示例2：使用正则表达式匹配 echo -e \u0026#34;apple 5\\nbanana 3\\ncherry 8\u0026#34; | awk \u0026#39;/a/ {print $0}\u0026#39; # 输出：apple 5 # banana 3 # 示例3：计算总和 echo -e \u0026#34;apple 5\\nbanana 3\\ncherry 8\u0026#34; | awk \u0026#39;{sum += $2} END {print \u0026#34;Total:\u0026#34;, sum}\u0026#39; # 输出：Total: 16 # 示例4：自定义字段分隔符 echo \u0026#34;2023-05-15,John,Doe\u0026#34; | awk -F\u0026#39;,\u0026#39; \u0026#39;{print $2}\u0026#39; # 输出：John # 示例5：条件处理 echo -e \u0026#34;John 25\\nJane 30\\nBob 35\u0026#34; | awk \u0026#39;$2 \u0026gt; 28 {print $1 \u0026#34; is over 28\u0026#34;}\u0026#39; # 输出：Jane is over 28 # Bob is over 28 Shell正则表达式示例 正则表达式(Regular Expression) 简称regex\n=~: 进行正则表达式匹配\n匹配手机号 1 2 3 4 5 6 7 8 9 #!/bin/bash read -p \u0026#34;请输入手机号：\u0026#34; phone_number if [[ phone_number =~ ^1[3456789][0-9]\\{9\\} ]];then echo \u0026#34;您输入的手机号 $phone_number 符合要求\u0026#34; else echo \u0026#34;您输入的手机号 $phone_number 不符合要求\u0026#34; fi 手机号正确，但是返回不符合要求 进行调试\n1 2 3 4 # 调试语法 bash -x regex1.sh # 或者 sh -x regex1.sh 原因：这里能看到这个参数并没有变成我们需要的值 修正：在参数phone_number前加上$使值传入 修改如下：\n1 2 3 4 5 6 7 8 9 #!/bin/bash read -p \u0026#34;请输入手机号：\u0026#34; phone_number if [[ $phone_number =~ ^1[3456789][0-9]\\{9\\} ]];then echo \u0026#34;您输入的手机号 $phone_number 符合要求\u0026#34; else echo \u0026#34;您输入的手机号 $phone_number 不符合要求\u0026#34; fi 可以看到还是不符合要求，其中红框内变成了\\{9} 修正：将\\{9\\}替换为{9} 修改如下：\n1 2 3 4 5 6 7 8 9 #!/bin/bash read -p \u0026#34;请输入手机号：\u0026#34; phone_number if [[ $phone_number =~ ^1[3456789][0-9]{9} ]];then echo \u0026#34;您输入的手机号 $phone_number 符合要求\u0026#34; else echo \u0026#34;您输入的手机号 $phone_number 不符合要求\u0026#34; fi 上述代码利用了=~运算符来进行正则表达式匹配，其中^1[3456789][0-9]{9}表示以1为开头，第二位为3/4/5/6/7/8/9重任意一个，后面跟着9位数字的字符串。\n查询目录下的所有.sh文件 1 2 3 4 5 #!/bin/bash for file in ./*.sh; do echo \u0026#34;$file\u0026#34; done 替换字符串中的数字 1 2 3 4 5 6 7 8 9 10 11 #!/bin/bash string=\u0026#34;\u0026#34;abcd1234\u0026#34; echo \u0026#34;替换前：$string\u0026#34; # 将字符串中的所有数字替换为 # new_string=(echo \u0026#34;$string\u0026#34; | sed \u0026#39;s/[0-9]/#/g\u0026#39;) echo \u0026#34;替换后：$new_string\u0026#34; # 修正：使用 $() 而不是 () 1 2 3 4 5 6 7 8 9 10 11 #!/bin/bash string=\u0026#34;\u0026#34;abcd1234\u0026#34; echo \u0026#34;替换前：$string\u0026#34; # 将字符串中的所有数字替换为 # # 修正：使用 $() 而不是 () new_string=$(echo \u0026#34;$string\u0026#34; | sed \u0026#39;s/[0-9]/#/g\u0026#39;) echo \u0026#34;替换后：$new_string\u0026#34; 匹配URL地址 1 2 3 4 5 6 7 8 #!/bin/bash read -p \u0026#34;请输入 URL 地址：\u0026#34; url if [[ $url =~ ^(http|https)://[a-z0-9]+(\\.[a-z0-9]+){1,3}.* ]]; then echo \u0026#34;您输入的 URL 地址 $url 符合要求\u0026#34; else echo \u0026#34;您输入的 URL 地址 $url 不符合要求\u0026#34; fi ^(http|https)://[a-z0-9]+(\\.[a-z0-9]+){1,3}.* (http|https)表示http或https开头 [a-z0-9]+(\\.[a-z0-9]+){1,3}表示后面跟着1到3段类似于.xxx的字符串 .*表示.后面还可以跟着任意字符 其他技巧 grep 查找文件的指定内容的行 1 grep pattern file 查找文件test.txt中包含单词hello的行： 1 grep hello test.txt awk 对文本进行分割、筛选、统计等操作 1 awk \u0026#39;/pattern/ { action }\u0026#39; file 查找文件test.txt中长度大于10的行 1 awk \u0026#39;length \u0026gt; 10\u0026#39; test.txt sed 匹配和替换操作 1 sed \u0026#39;s/pattern/replacement/\u0026#39; file 将文件test.txt中的所有空格替换为下划线 1 sed \u0026#39;s/ /_/g\u0026#39; test.txt ","date":"2025-10-08T21:04:44+08:00","permalink":"https://YLine-hub.github.io/p/shell%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"Shell正则表达式"},{"content":"流程控制 条件判断 判断条件 （1）关系运算符 运算符 说明 -eq 相等 -ne 不相等 -gt 大于 -lt 小于 -ge 大于等于 -le 小于等于 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #!/bin/bash a=10 b=20 if [ $a -eq $b ] then echo \u0026#34;$a -eq $b : a 等于 b\u0026#34; else echo \u0026#34;$a -eq $b : a 不等于 b\u0026#34; fi if [ $a -ne $b ] then echo \u0026#34;$a -ne $b : a 不等于 b\u0026#34; else echo \u0026#34;$a -ne $b : a 等于 b\u0026#34; fi if [ $a -gt $b ] then echo \u0026#34;$a -gt $b : a 大于 b\u0026#34; else echo \u0026#34;$a -gt $b : a 不大于 b\u0026#34; fi if [ $a -lt $b ] then echo \u0026#34;$a -lt $b : a 小于 b\u0026#34; else echo \u0026#34;$a -lt $b : a 不小于 b\u0026#34; fi if [ $a -ge $b ] then echo \u0026#34;$a -ge $b : a 大于或等于 b\u0026#34; else echo \u0026#34;$a -ge $b : a 小于 b\u0026#34; fi if [ $a -le $b ] then echo \u0026#34;$a -le $b : a 小于或等于 b\u0026#34; else echo \u0026#34;$a -le $b : a 大于 b\u0026#34; fi （2）布尔运算符 运算符 说明 ! 非运算，表达式为true则返回false -o 或运算，有一个表达式为true则返回true -a 与运算，两个表达式都为true才返回true 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/bash a=10 b=20 if [ $a != $b ] then echo \u0026#34;$a != $b : a 不等于 b\u0026#34; else echo \u0026#34;$a == $b : a 等于 b\u0026#34; fi if [ $a -lt 100 -a $b -gt 15 ] then echo \u0026#34;$a 小于 100 且 $b 大于 15 : 返回 true\u0026#34; else echo \u0026#34;$a 小于 100 且 $b 大于 15 : 返回 false\u0026#34; fi if [ $a -lt 100 -o $b -gt 100 ] then echo \u0026#34;$a 小于 100 或 $b 大于 100 : 返回 true\u0026#34; else echo \u0026#34;$a 小于 100 或 $b 大于 100 : 返回 false\u0026#34; fi if [ $a -lt 5 -o $b -gt 100 ] then echo \u0026#34;$a 小于 5 或 $b 大于 100 : 返回 true\u0026#34; else echo \u0026#34;$a 小于 5 或 $b 大于 100 : 返回 false\u0026#34; fi （3）逻辑运算符 1 2 \u0026amp;\u0026amp; 逻辑AND || 逻辑OR 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/bin/bash a=10 b=20 if [[ $a -lt 100 \u0026amp;\u0026amp; $b -gt 100 ]] then echo \u0026#34;$a 小于 100 AND $b 大于 100 : 返回 true\u0026#34; else echo \u0026#34;$a 小于 100 AND $b 大于 100 : 返回 false\u0026#34; fi if [[ $a -lt 100 || $b -gt 100 ]] then echo \u0026#34;$a 小于 100 OR $b 大于 100 : 返回 true\u0026#34; else echo \u0026#34;$a 小于 100 OR $b 大于 100 : 返回 false\u0026#34; fi （4）字符串运算符 运算符 说明 = 检测两个字符是否相等，相等返回true != 检测两个字符是否不相等，不相等返回true -z 检测字符串长度是否为0，为0返回true -n 检测字符串长度是否不为0，不为0返回true $ 检测字符串是否不为空，不为空返回true 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #!/bin/bash a=\u0026#34;abc\u0026#34; b=\u0026#34;efg\u0026#34; if [ $a = $b ] then echo \u0026#34;$a = $b : a 等于 b\u0026#34; else echo \u0026#34;$a = $b : a 不等于 b\u0026#34; fi if [ $a != $b ] then echo \u0026#34;$a != $b : a 不等于 b\u0026#34; else echo \u0026#34;$a != $b : a 等于 b\u0026#34; fi if [ -z $a ] then echo \u0026#34;-z $a : 字符串长度为 0\u0026#34; else echo \u0026#34;-z $a : 字符串长度不为 0\u0026#34; fi if [ -n $a ] then echo \u0026#34;-n $a : 字符串长度不为 0\u0026#34; else echo \u0026#34;-n $a : 字符串长度为 0\u0026#34; fi if [ $a ] then echo \u0026#34;$a : 字符串不为空\u0026#34; else echo \u0026#34;$a : 字符串为空\u0026#34; fi if语句 方式一 1 2 3 4 5 6 7 if [ 判断条件 ]; then 代码逻辑 else 代码逻辑 fi # 注意：[]中的内容左右两边要有空格，[]结尾用带有; 方法二 1 2 3 4 5 6 7 if [ 判断条件 ] then 代码逻辑 else 代码逻辑 fi # 注意：跟上面基本一致，少了个分号\u0026#39;;\u0026#39; 多重判断 1 2 3 4 5 6 7 8 9 10 if [ 判断条件 ] then 代码逻辑 elif [ 判断逻辑 ] then 代码逻辑 else 代码逻辑 fi # 注意：就是用elif来拼接，用上面两种写法都可以 示例 示例：传参判断成绩等级 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 0 =\u0026lt; D \u0026lt;= 50 # 50 \u0026lt; C \u0026lt;= 70 # 70 \u0026lt; B \u0026lt;= 90 # 90 \u0026lt; A \u0026lt;= 100 #!/bin/bash if [ $1 -ge 0 -a $1 -lt 50 ] then echo \u0026#34;成绩为：$1，评分为：D\u0026#34; elif [ $1 -gt 50 -a $1 -le 70 ] then echo \u0026#34;成绩为：$1，评分为：C\u0026#34; elif [ $1 -gt 70 -a $1 -le 90 ] then echo \u0026#34;成绩为：$1，评分为：B\u0026#34; elif [ $1 -gt 90 -a $1 -le 100 ] then echo \u0026#34;成绩为：$1，评分为：A\u0026#34; else echo \u0026#34;成绩不合法\u0026#34; fi 报错： 原因：变量的值为空值，这个空值没有范围\n解决办法，加一个前提条件，输入非数字就直接退出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 0 =\u0026lt; D \u0026lt;= 50 # 50 \u0026lt; C \u0026lt;= 70 # 70 \u0026lt; B \u0026lt;= 90 # 90 \u0026lt; A \u0026lt;= 100 #!/bin/bash if [[ ! $1 =~ ^[0-9]+$ ]] then echo \u0026#34;输入非数字，退出\u0026#34; exit elif [ $1 -ge 0 -a $1 -lt 50 ] then echo \u0026#34;成绩为：$1，评分为：D\u0026#34; elif [ $1 -gt 50 -a $1 -le 70 ] then echo \u0026#34;成绩为：$1，评分为：C\u0026#34; elif [ $1 -gt 70 -a $1 -le 90 ] then echo \u0026#34;成绩为：$1，评分为：B\u0026#34; elif [ $1 -gt 90 -a $1 -le 100 ] then echo \u0026#34;成绩为：$1，评分为：A\u0026#34; else echo \u0026#34;成绩不合法\u0026#34; fi 分支控制 语法格式 1 2 3 4 5 6 7 8 9 10 11 12 case 变量 in \u0026#34;变量值1\u0026#34;) 逻辑代码1 ;; \u0026#34;变量值2\u0026#34;) 逻辑代码2 ;; ... *) 默认逻辑 ;; esac 示例 示例：根据传参判断星期 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/bash echo -e \u0026#34;今天是星期几？\\n\u0026#34; case $1 in 1) echo \u0026#34;月曜日\u0026#34; ;; 2) echo \u0026#34;火曜日\u0026#34; ;; 3) echo \u0026#34;水曜日\u0026#34; ;; 4) echo \u0026#34;木曜日\u0026#34; ;; 5) echo \u0026#34;金曜日\u0026#34; ;; 6) echo \u0026#34;土曜日\u0026#34; ;; 7) echo \u0026#34;日曜日\u0026#34; ;; *) echo \u0026#34;输入错误\u0026#34; ;; esac 循环语句 for循环 方式一 1 2 3 4 5 for 暂时变量 in 变量1 变量2 变量3 ... do 代码逻辑 done # 注意：遍历时将变量1,2,3...分别赋值给暂时变量 方式二 1 2 3 4 5 for ((初始值; 循环控制条件; 变量变化)) do 代码逻辑 done # 注意：跟java语法遍历类似，只是用了两个()进行括起 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #!/bin/bash if [ -z \u0026#34;$1\u0026#34; ] then echo \u0026#34;参数不能为空\u0026#34; exit fi for item in $* do echo \u0026#34;item is $item\u0026#34; done echo \u0026#34;-------------------\u0026#34; for ((i=0; i\u0026lt;$#;i++)) do echo \u0026#34;num is $i\u0026#34; done while循环 语法格式 1 2 3 4 while 条件 do 代码逻辑 done 示例 1 2 3 4 5 #!/bin/bash if [[ ! $1 =~ ^[0-9]+$ ]] then echo \u0026#34;输入非数字，退出\u0026#34; ","date":"2025-10-08T15:39:07+08:00","permalink":"https://YLine-hub.github.io/p/shell%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","title":"Shell流程控制"},{"content":"流程 1️⃣ 先写命令（快速验证核心逻辑） 1 2 # 直接硬编码执行（不要想任何变量） grep \u0026#34;ERROR\u0026#34; /var/log/app.log | awk \u0026#39;{print $3}\u0026#39; \u0026gt; error_codes.txt 2️⃣ 结构化升级（按顺序添加） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 加入变量（路径/参数抽象化） log_dir=\u0026#34;/var/log\u0026#34; output_file=\u0026#34;error_codes_$(date +%F).txt\u0026#34; # 加入循环（处理多个文件） for log_file in \u0026#34;$log_dir\u0026#34;/*.log; do grep \u0026#34;ERROR\u0026#34; \u0026#34;$log_file\u0026#34; done \u0026gt; temp_errors.txt # 加入判断（条件处理） if [[ -s temp_errors.txt ]]; then awk \u0026#39;{print $3}\u0026#39; temp_errors.txt \u0026gt; \u0026#34;$output_file\u0026#34; else echo \u0026#34;未发现错误日志\u0026#34; \u0026gt; \u0026#34;$output_file\u0026#34; fi # 加入函数（复杂操作封装） extract_errors() { grep \u0026#34;ERROR\u0026#34; \u0026#34;$1\u0026#34; | cut -d\u0026#39;:\u0026#39; -f2 } extract_errors \u0026#34;$log_file\u0026#34; \u0026gt;\u0026gt; temp_errors.txt 3️⃣ 防御武装（输入合规+防崩溃） 1 2 3 4 5 6 7 8 9 10 11 12 # 输入合规检查（放在脚本开头） if [[ $# -eq 0 ]]; then echo \u0026#34;用法: $0 [日志目录]\u0026#34; exit 1 elif [[ ! -d \u0026#34;$1\u0026#34; ]]; then echo \u0026#34;错误：目录 $1 不存在\u0026#34; \u0026gt;\u0026amp;2 exit 2 fi # 防崩溃装甲（紧接合规检查后） set -euo pipefail trap \u0026#39;rm -f temp_errors.txt\u0026#39; EXIT 4️⃣ 安全收尾（说明+清理） 1 2 3 4 5 6 7 8 9 10 # 资源清理（通过trap已实现） # 脚本自文档（结尾注释块） : \u0026lt;\u0026lt;\u0026#39;EOF\u0026#39; === 脚本说明 === 功能: 提取应用错误码 输入: 日志目录路径 输出: error_codes_日期.txt 依赖: grep, awk, cut EOF 🛠 万能模板（直接填空使用） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #!/bin/bash # ===== 1.裸写命令区 ===== # [在此处写下你的原始命令] # grep \u0026#34;pattern\u0026#34; /path/file # ===== 2.结构化升级 ===== input_path=${1:-\u0026#34;/default/path\u0026#34;} # 变量 for item in \u0026#34;$input_path\u0026#34;/*; do # 循环 if [[ -f \u0026#34;$item\u0026#34; ]]; then # 判断 process_item \u0026#34;$item\u0026#34; # 函数 fi done process_item() { # [你的处理逻辑] } # ===== 3.防御武装 ===== [ $# -gt 1 ] \u0026amp;\u0026amp; { echo \u0026#34;参数过多\u0026#34;; exit 1; } # 输入合规 set -euo pipefail # 防崩溃 trap \u0026#39;cleanup\u0026#39; EXIT # 清理挂钩 cleanup() { rm -f tmp_*; } # 清理函数 # ===== 4.安全收尾 ===== :\u0026lt;\u0026lt;\u0026#34;NOTE\u0026#34; === 使用须知 === 1. 本脚本用于... 2. 输入要求... 3. 输出文件... NOTE ✅ 每个步骤的检查清单 步骤 必做事项 检查问题 1 核心命令能直接运行成功 去掉变量能否执行？ 2 所有路径参数都变量化 硬编码路径是否已消除？ 重复操作使用循环 同样操作是否出现3次以上？ 复杂逻辑封装为函数 主流程是否超过20行？ 3 检查关键输入是否存在 如果输入不存在会崩溃吗？ 设置set -euo pipefail 命令失败会继续执行吗？ 定义trap清理资源 脚本崩溃会留下垃圾文件吗？ 4 添加基本用法注释 三个月后还能看懂用法吗？ ","date":"2025-10-08T14:46:39+08:00","permalink":"https://YLine-hub.github.io/p/linux%E5%86%99%E8%84%9A%E6%9C%AC%E7%9A%84%E6%B5%81%E7%A8%8B/","title":"Linux写脚本的流程"},{"content":"Shell编程 介绍 Shell 是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序。 Shell入门 使用vim新建文件text.sh 1 vim test.sh 输入脚本解析器和脚本执行内容 1 2 #!/bin/bash echo \u0026#34;Hello World!\u0026#34; 按Esc，并输入:wq进行保存\n运行脚本\n1 ./test.sh -bash: ./test.sh: 权限不够\n添加执行权限 1 chmod u+x test.sh 重新运行脚本 Shell变量 介绍 Shell变量：系统变量 和 用户自定义变量 系统变量：$HOME，$PWD，$SHELL，$USER set指令可查看所有系统变量 自定义变量：变量=值 撤销变量：unset 变量 声明静态变量：readonly 变量（不能unset） 变量定义规则 只包含字母、数字和下划线，不能以数字开头 避免使用 Shell 关键字，如if、then、else、fi、for、while等 使用大写字母表示常量 避免使用特殊符号和空格 变量的使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 赋值 变量=值 # 使用一 $变量 # 使用二（推荐） ${变量} # 赋值一（命令） 变量=`命令` # 赋值二（命令） 变量=$(命令) 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/bin/bash echo \u0026#34;-------------------\u0026#34; A=100 echo \u0026#34;A=${A}\u0026#34; echo \u0026#34;A=$A\u0026#34; echo \u0026#34;-------------------\u0026#34; unset A echo \u0026#34;A=${A}\u0026#34; echo \u0026#34;A=$A\u0026#34; echo \u0026#34;-------------------\u0026#34; NOW=`date` echo \u0026#34;${NOW}\u0026#34; echo \u0026#34;$NOW\u0026#34; echo \u0026#34;-------------------\u0026#34; NOW_TIME=$(date) echo \u0026#34;${NOW_TIME}\u0026#34; echo \u0026#34;$NOW_TIME\u0026#34; 运行脚本 设置环境变量 介绍 linux上所有的环境变量都配置在/etc/profile中 export 变量=值来配置环境变量 配置完毕后，通过source /etc/profile，重新加载配置文件来使用 示例 添加环境变量 1 export LINUX_OWNER=yline 重新加载配置文件（如果没这一步将不会生效） 1 source /etc/profile 输出测试 1 echo \u0026#34;${LINUX_OWNER}\u0026#34; 位置参数变量 介绍 在我们执行shell脚本的时候，可以在后面拼接参数，进行传参，例：./test.sh hello world。\nshell脚本有对应的参数变量来接收这些参数。\n$n （n为数字）\n以空格来切分命令，将上面命令变成[./test.sh, hello, world]，通过$0, $1, $2来获取参数 如果个数达到10位数以上，需要用大括号括住数字${10} $*\n以一个单字符串显示所有向脚本传递的参数。 如\u0026quot;$*\u0026ldquo;用「\u0026quot;」括起来的情况、以\u0026rdquo;$1 $2 … $n\u0026quot;的形式输出所有参数。 获取全部参数，会将传入的参数hello world视为一个整体 $@\n与$*相同，但是使用时加引号，并在引号中返回每个参数。 如\u0026quot;$@\u0026ldquo;用「\u0026quot;」括起来的情况、以\u0026rdquo;$1\u0026quot; \u0026ldquo;$2\u0026rdquo; … \u0026ldquo;$n\u0026rdquo; 的形式输出所有参数。 获取全部参数，与$*不同，会将hello和world区分为个体 $#\n统计传入参数的个数 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/bash echo \u0026#34;---------------\u0026#34; echo \u0026#34;$0,$1,$2\u0026#34; echo \u0026#34;---------------\u0026#34; echo \u0026#34;$*\u0026#34; echo \u0026#34;---------------\u0026#34; echo \u0026#34;$@\u0026#34; echo \u0026#34;---------------\u0026#34; echo \u0026#34;$#\u0026#34; 带参运行test3.sh 预定义变量 介绍 shell本身有定义好的变量提供用户使用。\n$$\n获取当前进行的PID $!\n获取后台运行的最后一个进程的进程号 $?\n最后一次执行的命令的返回状态（0=正常，非0=异常） 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/bash echo \u0026#34;---------------\u0026#34; echo \u0026#34;current_PID = $$\u0026#34; ../test.sh \u0026amp; echo \u0026#34;---------------\u0026#34; echo \u0026#34;last_PID = $!\u0026#34; echo \u0026#34;---------------\u0026#34; echo \u0026#34;status = $?\u0026#34; 运行脚本 1 ./test4.sh 字符串 介绍 shell编程中最常用最有用的数据类型，可以用单引号，也可以用双引号，也可也不用引号。 示例 单引号 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； 单引号字符串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。 1 2 3 4 #!/bin/bash str=\u0026#39;this is a string\u0026#39; echo \u0026#34;$str\u0026#34; 双引号 双引号里可以有变量 双引号里可以出现转义字符 echo -e 关键词 其中 -e 表示启用转义字符 1 2 3 4 5 #!/bin/bash your_name=\u0026#34;yline\u0026#34; str=\u0026#34;Hello,I know you are \\\u0026#34;$your_name\\\u0026#34;!\\n\u0026#34; echo -e $str 拼接字符串 1 2 3 4 5 6 7 8 9 10 11 12 #!/bin/bash your_name=\u0026#34;yline\u0026#34; # 使用双引号拼接 greeting=\u0026#34;hello, \u0026#34;$your_name\u0026#34; !\u0026#34; greeting_1=\u0026#34;hello, ${your_name} !\u0026#34; echo $greeting $greeting_1 # 使用单引号拼接 greeting_2=\u0026#39;hello, \u0026#39;$your_name\u0026#39; !\u0026#39; greeting_3=\u0026#39;hello, ${your_name} !\u0026#39; echo $greeting_2 $greeting_3 获取字符串长度 1 2 3 string=\u0026#34;abcd\u0026#34; echo ${#string} # 输出4 echo ${#string[0]} # 输出4 变量为字符串时，${#string}等价于${#string[0]} 提取子字符串 从字符串第2个字符开始截取4个字符 1 2 3 4 #!/bin/bash string=\u0026#34;Hello World!\u0026#34; echo ${string:1:4} 第一个字符串索引为0 查找字符串 查找字符o或r的位置（哪个先出现就计算哪个） 1 2 3 4 #!/bin/bash string=\u0026#34;Hello World!\u0026#34; echo `expr index \u0026#34;$string\u0026#34; or` # 输出为5 数组 介绍 Bash Shell只支持一维数组，初始化不需要定义数组大小 数组元素小标由0开始 语法格式 1 array_name=(value1 value2 ... valuen) 定义数组 格式 1 array_name=(value0 value1 value2 value3) 或者\n1 2 3 4 5 6 array_name=( value0 value1 value2 value3 ) 单独定义数组的各个分量\n1 2 3 array_name[0]=value0 array_name[1]=value1 array_name[n]=valuen 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/bin/bash array1=(A B \u0026#34;C\u0026#34; D) array2[0]=A array2[1]=B array2[2]=\u0026#34;C\u0026#34; array3[3]=D echo \u0026#34;----------------------------\u0026#34; echo \u0026#34;array1[0]=${array1[0]}\u0026#34; echo \u0026#34;array1[1]=${array1[1]}\u0026#34; echo \u0026#34;array1[2]=${array1[2]}\u0026#34; echo \u0026#34;array1[3]=${array1[3]}\u0026#34; echo \u0026#34;----------------------------\u0026#34; echo \u0026#34;array2[0]=${array2[0]}\u0026#34; echo \u0026#34;array2[1]=${array2[1]}\u0026#34; echo \u0026#34;array2[2]=${array2[2]}\u0026#34; echo \u0026#34;array2[3]=${array2[3]}\u0026#34; echo \u0026#34;----------------------------\u0026#34; 读取数组 格式 1 ${array_name[index]} 示例 1 2 3 4 5 6 7 #!/bin/bash my_array=(A B \u0026#34;C\u0026#34; D) echo \u0026#34;第一个元素为: ${my_array[0]}\u0026#34; echo \u0026#34;第二个元素为: ${my_array[1]}\u0026#34; echo \u0026#34;第三个元素为: ${my_array[2]}\u0026#34; echo \u0026#34;第四个元素为: ${my_array[3]}\u0026#34; 关联数组 Bash 支持关联数组，可以使用任意的字符串、或者整数作为下标来访问数组元素。\n格式 -A 选项就是用于声明一个关联数组 关联数组的键是唯一的。 1 declare -A array_name 示例 1 2 3 4 5 6 7 8 9 10 #!/bin/bash declare -A site site[\u0026#34;baidu\u0026#34;]=\u0026#34;www.baidu.com\u0026#34; site[\u0026#34;google\u0026#34;]=\u0026#34;www.google.com\u0026#34; site[\u0026#34;taobao\u0026#34;]=\u0026#34;www.taobao.com\u0026#34; echo ${site[\u0026#34;baidu\u0026#34;]} echo ${site[\u0026#34;google\u0026#34;]} echo ${site[\u0026#34;taobao\u0026#34;]} 获取数组中的所有元素 使用@或*可以获取数组中的所有元素\n1 2 3 4 5 6 7 8 9 #!/bin/bash my_array[0]=A my_array[1]=B my_array[2]=C my_array[3]=D echo \u0026#34;数组的元素为：${my_array[*]}\u0026#34; echo \u0026#34;数组的元素为：${my_array[@]}\u0026#34; 1 2 3 4 5 6 7 8 9 #!/bin/bash declare -A site site[\u0026#34;baidu\u0026#34;]=\u0026#34;www.baidu.com\u0026#34; site[\u0026#34;google\u0026#34;]=\u0026#34;www.google.com\u0026#34; site[\u0026#34;taobao\u0026#34;]=\u0026#34;www.taobao.com\u0026#34; echo \u0026#34;数组的元素为：${site[*]}\u0026#34; echo \u0026#34;数组的元素为：${site[@]}\u0026#34; 在数组前加一个感叹号！可以获取数组的所有键 1 2 3 4 5 6 7 8 9 #!/bin/bash declare -A site site[\u0026#34;baidu\u0026#34;]=\u0026#34;www.baidu.com\u0026#34; site[\u0026#34;google\u0026#34;]=\u0026#34;www.google.com\u0026#34; site[\u0026#34;taobao\u0026#34;]=\u0026#34;www.taobao.com\u0026#34; echo \u0026#34;数组的键为：${!site[*]}\u0026#34; echo \u0026#34;数组的键为：${!site[@]}\u0026#34; 获取数组的长度 获取数组的长度方法与获取字符串长度的方法相同 1 2 3 4 5 6 7 8 9 #!/bin/bash my_array[0]=A my_array[1]=B my_array[2]=\u0026#34;C\u0026#34; my_array[3]=D echo \u0026#34;数组元素个数为：${#my_array[*]}\u0026#34; echo \u0026#34;数组元素个数为：${#my_array[@]}\u0026#34; 运算符 算数运算符 使用方式 1 2 3 4 5 (1)$((运算表达式)) (2)$[运算表达式] (3)expr 运算表达式 示例 1 2 3 4 5 6 7 8 9 10 11 #!/bin/bash echo \u0026#34;----------------------\u0026#34; echo \u0026#34;(2+3)*4 = $(((2+3)*4))\u0026#34; echo \u0026#34;----------------------\u0026#34; echo \u0026#34;(2+3)*4 = $[(2+3)*4]\u0026#34; echo \u0026#34;----------------------\u0026#34; TEMP=`expr 2 + 3` echo \u0026#34;(2+3)*4 = `expr $TEMP \\* 4`\u0026#34; ","date":"2025-10-05T17:05:56+08:00","permalink":"https://YLine-hub.github.io/p/shell%E7%BC%96%E7%A8%8B/","title":"Shell编程"},{"content":"端口管理 lsof 介绍 lsof（list open files）\n一个列出当前系统打开文件的工具。\n基本语法 1 lsof -i:端口号 示例 查看服务器80端口占用情况 1 2 3 4 5 6 7 8 9 COMMAND：进程名称 PID：进程标识符 USER：进程所有者 FD：文件描述符，应用程序通过描述符识别该文件。如cwd、txt等 TYPE：文件类型，如DIR、REG等 DEVICE：指定磁盘的名称 SIZE：文件大小 NODE：索引节点（文件在磁盘上的标识） NAME：代开文件的确切名称 查看所有端口使用情况 更多lsof命令：\n1 2 3 4 5 6 7 8 9 lsof -i:8080：查看8080端口占用 lsof abc.txt：显示开启文件abc.txt的进程 lsof -c abc：显示abc进程现在打开的文件 lsof -c -p 1234：列出进程号为1234的进程所打开的文件 lsof -g gid：显示归属gid的进程情况 lsof +d /usr/local/：显示目录下被进程开启的文件 lsof +D /usr/local/：同上，但是会搜索目录下的目录，时间较长 lsof -d 4：显示使用fd为4的进程 lsof -i -U：显示所有打开的端口和UNIX domain文件 netstat 介绍 用于显示 tcp，udp 的端口和进程等相关情况。 基本语法 1 2 # 查看端口占用语法格式 netstat -tunlp | grep 端口号 options: -t (tcp) 仅显示tcp相关选项 -u (udp)仅显示udp相关选项 -n 拒绝显示别名，能显示数字的全部转化为数字 -l 仅列出在Listen(监听)的服务状态 -p 显示建立相关链接的程序名 示例 查看80端口情况 更多命令：\n1 2 3 netstat -ntlp //查看当前所有tcp端口 netstat -ntulp | grep 80 //查看所有80端口使用情况 netstat -ntulp | grep 3306 //查看所有3306端口使用情况 ","date":"2025-10-05T03:06:03+08:00","permalink":"https://YLine-hub.github.io/p/linux%E7%AB%AF%E5%8F%A3%E7%AE%A1%E7%90%86/","title":"Linux端口管理"},{"content":"服务管理 介绍 服务的本质就是进程，但是是运行在后台的，通常会监听某个端口，等待其他进程的请求，因此我们又称为守护进程。\n查看服务 centos7以下：文件夹下 /etc/init.d/ 下的文件名就是已启动的服务名。 centos7以上：指令 systemctl list-units --type=service查看已启动服务 1 systemctl list-units --type=service 管理指令 CentOS7以前\n1 2 3 4 5 service (服务名) start : 启动服务 service (服务名) stop : 关闭服务 service (服务名) restart : 重启服务 service (服务名) reload : 重载服务 service (服务名) status : 服务状态 CentOS7以后，service替换成systemctl，但仍然能够使用service\n1 2 3 4 5 systemctl start (服务名): 启动服务 systemctl stop (服务名): 关闭服务 systemctl restart (服务名): 重启服务 systemctl reload (服务名): 重载服务 systemctl status (服务名): 服务状态 查看防火墙状态 1 systemctl status firewalld 关闭防火墙，并再次查看防火墙状态 1 2 systemctl stop firewalld systemctl status firewalld 重启防火墙 1 2 systemctl start firewalld systemctl status firewalld 自启动设置 CentOS7以前\n1 2 3 chkconfig : 查看服务在各运行级别的自启动情况 chkconfig (服务名) : 查看指定服务在各运行级别的启动情况 chkconfig --level (级别) (服务名) on/off : 指定某个服务在指定运行级别是否自启动 CentOS7以后\n1 2 systemctl list-unit-files : 查看服务自启动情况 systemctl enable/disable (服务名) : 服务自启动/关闭自启动 查看sshd自启动情况 1 systemctl list-unit-files | grep sshd 关闭sshd自启动 1 2 systemctl disable sshd systemctl list-unit-files | grep sshd 重启sshd自启动 1 2 systemctl enable sshd systemctl list-unit-files | grep sshd 端口测试 介绍 window自带的一个指令 telnet 来测试某服务的端口是否处于监听状态（启动状态） 格式：telnet ip地址 端口号 开启方法 测试 测试sshd端口22 1 telnet 192.168.172.100 22 没有报错并显示以下界面，即端口22处于监听状态 测试192.168.172.100服务器80端口 1 telnet 192.168.172.100 80 Connecting To 192.168.172.100\u0026hellip;Could not open connection to the host, on port 80: Connect failed\n表示该80端口未处于监听状态\n打开192.168.172.100服务器80端口 1 2 3 4 5 6 # 查看80端口开放状态 firewall-cmd --query-port=80/tcp # 永久打开80端口 firewall-cmd --add-port=80/tcp --permanent # 重启防火墙 firewall-cmd --reload 发现还是无法连接\n测试192.168.172.132服务器80端口 该服务器部署了gitlab服务，80端口处于监听状态，运行了http服务\n查看132服务器80端口使用情况 1 lsof -i:80 ","date":"2025-10-05T02:02:34+08:00","permalink":"https://YLine-hub.github.io/p/linux%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/","title":"Linux服务管理"},{"content":"进程管理 介绍 Linux中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个ID号。\n每一个进程，都会有对应一个父进程，父进程可以有多个子进程。\n每个进程都有两种存在方式： 前台和后台\n前台进程：用户可以在屏幕进行操作。 后台进程：进程在运行，但无法在屏幕上看到。 进程显示 显示系统执行的进程 1 2 3 4 5 ps ps -a : 显示所有进程信息 ps -u : 以用户格式显示进程信息 ps -x : 显示后台进程运行的参数 ps -f : 显示父进程ID 查找指定进程：\n1 ps -ef | grep 关键字 PID：进程识别号 TTY：终端机号 TIME：此进程所消耗CPU时间 CMD：正在执行的命令/进程名 USER：用户名 %CPU：CPU %MEN：内存占用率 VSZ：使用虚拟内存大小 RSS：使用物理内存大小 STAT：进程状态 START：进程开始时间 COMMAND：进程执行的命令行 能看到指令运行的参数 PPID：父进程 显示进程树 1 2 3 pstree pstree -p 显示进程的PID pstree -u 显示进程所属用户 -bash: pstree: 未找到命令\n查询pstree所在包 1 yum search pstree 安装psmisc 1 yum -y install psmisc 测试 树型结构显示进程 进程终止 指令 1 2 kill (进程号：PID) kill -9 (进程号：PID) : 强制终止进程 1 2 killall (进程名，支持通配符*) killall -9 (进程名) ： 强制终止匹配的所有进程 同时登陆yline和root用户 查询进程yline 1 ps -ef | grep yline 杀死进程yline 1 kill 8913 进程监控 指令 1 2 3 4 top : 动态显示进程信息 top -d (秒数) : 设置指定秒数更新进程信息 top -i : 不显示任何闲置或僵死的进程 top -p (进程PID) : 监控指定进程信息 1 top 只显示当前正在运行的进程 1 top -i 只显示PID为682的进程 1 top -p 682 交互指令 进入进程监控界面之后可以输入一下指令，达到想要的效果。 1 2 3 4 5 6 P : 以CPU使用率进行排序（默认） M : 以内存的使用率进行排序 N : 以PID进行排序 u : 监控指定用户的进程 k : 杀死指定进程 q : 退出监控 ","date":"2025-10-04T22:13:48+08:00","permalink":"https://YLine-hub.github.io/p/linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","title":"Linux进程管理"},{"content":"Linux问题记录 问题一：开机提示emergency mode（紧急模式） 问题现象：\n进入紧急模式原因：\n/etc/fstab文件配置存在错误导致挂载文件系统时失败。 文件系统存在错误。 系统更新后的脚本错误。 (1)：在下列位置输入root密码使用root账号登陆 (2)：打开/etc/fstab 1 vi /etc/fstab (3)：注释掉原先添加的部分 (4)：reboot重启 1 reboot (5)：找到原因，配置fstab文件错误 该处应该是defaults (6)：重新配置并保存重启 1 /dev/sdb1 /home/newdisk ext4 defaults 0 0 (7)：查看是否配置成功 1 lsblk -f 可以看到自动配置硬盘成功 ","date":"2025-10-04T16:28:52+08:00","permalink":"https://YLine-hub.github.io/p/linux%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","title":"Linux问题记录"},{"content":"Linux网络配置 虚拟网络 介绍 （1）windows与虚拟网络联通\nwindow下有一个网卡为 “VMware Network Adapter VMnet8” ，是用于与虚拟机进行通讯。 window可以用ipconfig查看ip地址，linux可以用ifconfig查看ip地址。 可以看到这两个网络是同一网段。\n（2）windows与internet连接\n通过windows下的真实网卡，经历路由器网关，跟互联网进行交互。 查看默认网关 1 ip route show 网络配置 网络配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 查看网卡配置文件 $ cat /etc/sysconfig/network-scripts/ifcfg-ens33 TYPE=\u0026#34;Ethernet\u0026#34; # 网卡类型，Ethernet表示以太网 PROXY_METHOD=\u0026#34;none\u0026#34; # 代理方式：关闭状态 BROWSER_ONLY=\u0026#34;no\u0026#34; # 只是浏览器（yes|no） BOOTPROTO=\u0026#34;dhcp\u0026#34; # 设置网卡获得ip地址的方式（static|dhcp|none） DEFROUTE=\u0026#34;yes\u0026#34; # 设置为默认路由（yes|no） IPV4_FAILURE_FATAL=\u0026#34;no\u0026#34; # 是否开启IPV4致命错误检测（yes|no） IPV6INIT=\u0026#34;yes\u0026#34; # IPV6是否自动初始化 IPV6_AUTOCONF=\u0026#34;yes\u0026#34; # IPV6是否自动配置 IPV6_DEFROUTE=\u0026#34;yes\u0026#34; # IPV6是否可以为默认路由 IPV6_FAILURE_FATAL=\u0026#34;no\u0026#34; # 是否开启IPV6致命错误检测 IPV6_ADDR_GEN_MODE=\u0026#34;stable-privacy\u0026#34; # IPV6地址生成模型 NAME=\u0026#34;ens33\u0026#34; # 网卡物理设备名称 UUID=\u0026#34;8b1f9fd5-9d4b-46f7-ba3f-0ff3f862e0c2\u0026#34; # UUID识别码 DEVICE=\u0026#34;ens33\u0026#34; # 网卡设备名称 ONBOOT=\u0026#34;yes\u0026#34; # 开机自启 配置静态ip 打开文件ifcfg-ens33 1 vi /etc/sysconfig/network-scripts/ifcfg-ens33 配置参数 1 2 3 4 5 BOOTPROTO=\u0026#34;static\u0026#34; IPADDR=192.168.172.100 # 网关和DNS1相同即可 GATWAY=192.168.172.2 DNS1=192.168.172.2 重启网络 1 systemctl restart network ","date":"2025-10-03T21:16:25+08:00","permalink":"https://YLine-hub.github.io/p/linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/","title":"Linux网络配置"},{"content":"Linux磁盘管理 磁盘分区 分区原因 数据的安全性隔离：独立分开每个分区，使各区数据不会相互影响。\n系统的效率考虑：加快数据寻址的效率。\n分区方式 mbr分区 最多支持四个主分区 系统只能安装主分区 拓展分区要占一个主分区 MBR最大只支持2TB，但拥有最好的兼容性 适用场景：旧设备通常使用BIOS启动，仅支持MBR。 磁盘容量小于2TB。 需要兼容旧操作系统（如32位Windows）。\ngpt分区 支持无线多个主分区（但操作系统可能限制） 最大支持18EB的大容量（1EB = 1024PB，1PB = 1024TB） 适用场景：现代设备通常支持UEFI，推荐使用GPT。 磁盘容量大于2TB。 更高的可靠性和扩展性需求。\nLinux分区 介绍 Linux采用一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录关联起来。\n分区命名 （1）Linux的硬盘分为IDE（旧），SCSI（新）硬盘两种\n（2）IDE分区命名： 盘号标识符为：hdx~\nhd为设备类型，即指IDE硬盘 x为盘号【a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘】 ~为区号，即此分区为当前盘号的第几个分区【1~4主分区，5后为逻辑分区】 例如： hda1 （3）SCSI分区命名： 基本和IDE一致，只是设备类型不同，为sdx~\n例如：sda1 分区查看 lsblk(list block) 1 lsblk -f NAME: 块设备名称，例如 sda, sda1。 FSTYPE: 文件系统类型，例如 ext4, ntfs, swap 等。 FSVER: 文件系统版本（如果适用）。 LABEL: 文件系统标签（如果有设置）。 UUID: 文件系统的唯一标识符。 MOUNTPOINT: 当前挂载点（如果设备已挂载）。 磁盘挂载 挂载案例 给虚拟机创建一个新的硬盘，并挂载到/home/newdisk下 挂载步骤 给虚拟机添加新的硬盘 ハードディスク：harddisk 硬盘\n点击编辑虚拟机的设定 点击添加 选择硬盘然后点击下一步 默认SCSI硬盘即可 填写自己需要的硬盘数量并点击下一步 点击完成后，虚拟机设定内就会新增一个硬盘 点击ok并启动虚拟机 输入lsblk -f查看是否又新的硬盘 这块sdb就是新添加的硬盘\n分区 命令行输入：fdisk 设备位置，进入分区引导程序 输入m，查看指令目录\nn ： 添加一个新的分区\nw ： 写入到磁盘并退出\n输入指令n，添加新分区\n分区类型 ： p=主分区，e=扩展分区\n分区号码 ： 默认1\n起始扇区 ： 默认2048\n最后扇区 ： 默认硬盘最后的字节\n输入指令w，写入到磁盘并退出 查看磁盘分区，其中sdb1只有分区名，没有其他信息，需要进行格式化 1 lsblk -f 格式化 将分区格式化为ext4文件系统 1 mkfs -t ext4 /dev/sdb1 查看分区，sdb1已经属于ext4文件系统，且拥有唯一标识 挂载 创建新的目录，并将新的硬盘挂载在目录下 设置自动挂载 由于重启后需要重新挂载，设置自动挂载后，重启就不需要再重新挂载 1 2 # 打开/etc/fstab vi /etc/fstab 仿照上面的格式，写入挂载信息，并保存 1 2 # 挂载设备 挂载目录 文件系统 defaults 0 0 /dev/sdb1 /home/newdisk ext4 defaults 0 0 磁盘命令 df 介绍（检查硬盘占用情况） 检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。 基本语法 1 df [options] 目录或文件名 options：\n-h：以人类可读的方式显示输出结果（例如，使用 KB、MB、GB 等单位）。\n-T：显示文件系统的类型。\n-t \u0026lt;文件系统类型\u0026gt;：只显示指定类型的文件系统。\n-i：显示 inode 使用情况。\n-H：该参数是 -h 的变体，但是使用 1000 字节作为基本单位而不是 1024 字节。这意味着它会以 SI（国际单位制）单位（例如 MB、GB）而不是二进制单位（例如 MiB、GiB）来显示磁盘使用情况。\n-k：这个选项会以 KB 作为单位显示磁盘空间使用情况。\n-a：该参数将显示所有的文件系统，包括虚拟文件系统，例如 proc、sysfs 等。如果没有使用该选项，默认情况下，df 命令不会显示虚拟文件系统。\n示例 将系统内所有文件系统列出来 1 df 将容量结果以易读的容量格式显示出来 1 df -h 将系统内所有特殊文件格式及名称都列出来 1 df -aT 将/etc地下的可用的磁盘容量以易读的容量格式显示 1 df -h /etc du 介绍（检查指定目录磁盘占用情况） 对文件和目录磁盘使用的空间的查看。 基本语法 1 du [options] 文件或目录 options:\n-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。 -h ：以人们较易读的容量格式 (G/M) 显示； -s ：仅显示指定目录或文件的总大小，而不显示其子目录的大小。 -S ：包括子目录下的总计，与 -s 有点差别。 -k ：以 KBytes 列出容量显示； -m ：以 MBytes 列出容量显示； -c ：并统计总用量； 示例 列出当前目录下所有文件夹容量（包括子目录和隐藏文件夹） 1 du 将文件的容量也列出来 检查根目录底下每个目录所占容量 fdisk 介绍 磁盘分区表操作工具 基本语法 1 fdisk [options] 装置名称 options: -l : 输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。 示例 列出所有分区信息 1 fdisk -l 实用指令 查询指定目录下文件个数 1 ls -l 目录 | grep \u0026#34;^-\u0026#34; | wc -l 列出指定目录中的所有文件 1 ls -l /usr/lib/python2.7/site-packages/ 列出指定目录中“-”开头的文件 1 ls -l /usr/lib/python2.7/site-packages/ | grep \u0026#34;^-\u0026#34; 统计指定目录下“-”开头文件的个数 1 2 # wc(word count)统计个数 ls -l /usr/lib/python2.7/site-packages/ | grep \u0026#34;^-\u0026#34; | wc -l 查看指定目录文件个数（包含子目录） 跟上面基本一样，只是添加-R来进行递归 1 ls -lR 目录 | grep \u0026#34;^-\u0026#34; | wc -l 树形结构显示文件 1 tree 目录 安装tree命令 1 yum -y install tree 树形结构显示目录 ","date":"2025-10-01T13:50:43+08:00","permalink":"https://YLine-hub.github.io/p/linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/","title":"Linux磁盘管理"},{"content":"Linux用户账号管理 用户登陆与注销 登陆时尽量少用root账号登陆，因为它是系统管理员，权限最大，为避免操作失误。可以利用普通用户登陆，登陆后再用“su 用户名”命令来切换程系统管理员身份。\n切换用户：su 用户名\n注销用户：logout\nuseradd添加用户 基本语法 1 useradd options username options:\n-c comment 指定一段注释性描述。 -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 -g 用户组 指定用户所属的用户组。 -G 用户组，用户组 指定用户所属的附加组。 -s Shell文件 指定用户的登录Shell。 -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号 -m 用户目录如果不存在则自动创建。 username: 自定新账号的登录名\n示例 创建用户sam，其中-d和-m用来产生用户目录 1 useradd -d /home/sam -m sam 创建用户gem，该用户登陆Shell是/bin/sh，属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。 1 useradd -s /bin/sh -g group -G adm,root gem 以下是三个用户\n增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。 userdel删除用户 基本语法 1 userdel options username options\n-r 用于把用户的主目录一起删除。 示例 删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。 1 userdel -r sam usermod修改用户 基本语法 1 usermod options username options 包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。\n示例 将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。 1 usermod -s /bin/ksh -d /home/z -g developer sam passwd用户口令管理 用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。 基本语法 1 passwd options username options:\n-l 锁定口令，即禁用账号。 -u 口令解锁。 -d 使账号无口令。 -f 强迫用户下次登录时修改口令。 示例 如果是默认用户，修改当前用户的口令 1 2 3 4 $ passwd Old password:****** New password:******* Re-enter new password:******* 如果是超级用户，可以用下列形式修改指定任何用户的口令 1 2 3 $ passwd sam New password:******* Re-enter new password:******* 为用户指定空口令 1 $ passwd -d sam 删除sam用户口令，锁定sam，下一次sam就不再被允许登陆。 1 $ passwd -l sam 其他 用户与组的相关文件/etc/passwd 1 2 3 4 5 6 7 8 # /etc/passwd文件 # 用户 (user）的配置文件，记录用户的各种信息 cat /etc/passwd # 每行的含义: 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell yline:x:1000:1000:yline:/home/yline:/bin/bash /etc/shadow文件 1 2 3 4 5 6 # 口令的配置文件 cat /etc/shadow # 每行的含义: 登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 root:$6$qWXOPskK$JtjIOb0PE4k.86YmO4GbNolp.4ZmD8iMZDpNogyCzMNbbLsMdV17EcrpYVB/OW7CysD2KP.2rfV/nHucGkcLY1:20358:0:99999:7::: /etc/group文件 1 2 3 4 5 # 组(group)的配置文件，记录Linux包含的组的信息 cat /etc/group # 每行含义: 组名:口令:组标识号:组内用户列表 Linux用户组管理 groupadd增加用户组 1 groupadd options group 常用选项\n-g GID 指定新用户组的组标识号（GID）。 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。 示例 增加用户组group1，新组标识号是在当前最大组标识号上加1 1 groupadd group1 增加用户组group2，同时指定新组标识号为101 1 groupadd -g 101 group2 groupdel删除用户组 基本语法 1 groupdel group 示例 删除用户组group1 1 groupdel group1 groupmod修改用户组 基本语法 1 groupmod options group 常用选项：\n-g GID 为用户组指定新的组标识号。 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。 -n新用户组 将用户组的名字改为新名字 示例 将用户组group2的组标识号修改为102 1 groupmod -g 102 group2 将group2的标识号改为10000，组名修改为group3 1 groupmod -g 10000 -n group3 group2 newgrp切换用户组 如果用户同时属于多个组，那么用户可以在用户组之间切换\n切换到root组\n1 newgrp root 批量添加用户 编辑文本用户文件 每一列按照/etc/passwd密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号。\nuser.txt范例\n1 2 3 4 5 6 user001:x:1003:1000:users:/home/user001:/bin/bash user002:x:1004:1000:users:/home/user002:/bin/bash user003:x:1005:1000:users:/home/user003:/bin/bash user004:x:1006:1000:users:/home/user004:/bin/bash user005:x:1007:1000:users:/home/user005:/bin/bash user006:x:1008:1000:users:/home/user006:/bin/bash 以root身份导入用户 以root身份执行/user/sbin/newusers，从刚创建的user.txt中导入数据，创建用户 1 newusers \u0026lt; user.txt 然后执行vipw 或 vi /etc/passwd检查/etc/passwd文件中是否已经出现这些用户的数据，并且用户的宿主目录是否已经创建。 编辑每个用户的密码对照文件 1 2 # 格式 用户名：密码 passwd.txt范例 1 2 3 4 5 6 user001:123456 user002:123456 user003:123456 user004:123456 user005:123456 user006:123456 以root身份执行/usr/sbin/chpasswd 创建用户密码，chpasswd 会将经过/usr/bin/passwd命令编码过的密码写入/etc/passwd的密码栏 1 cat passwd.txt | chpasswd 注意： 一开始使用chpasswd \u0026lt; passwd.txt命令更新密码，一直显示密码错误。目前不知道原因。\n权限管理 文件的基本属性 文件类型 说明 - 普通文件 d 目录 l 软连接 c 字符设备【键盘、鼠标等】 b 块文件，硬盘 权限类型 说明 r read，读，查看文件 w write，写，修改文件，也可以删除文件 x execute，执行，执行文件 - 没有权限 权限的rwx可以用数字来表示\nr = 4 w = 2 x = 1 文件的权限修改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 修改文件 / 目录权限 # 方式一 chmod u=[rwx], g=[rwx], o=[rwx] 文件/目录名 #例：chmod u=rwx, g=rx, o=r hello.txt # u --- user 所有者 # g --- group 所在组 # o --- other 其他组 # a --- all 全部 # 方式二 chmod [ugoa][+-][rwx] 文件/目录名 #例：chmod u+r hello.txt # + --- 添加权限 # - --- 移除权限 # 方式三 chmod [数字权限][数字权限][数字权限] 文件/目录名 #例：chmod 764 hello.txt # r=4 w=2 x=1 # 7=rwx 6=rw 5=rx 3=wx # 第一个为所有者，第二为所在组，第三为其他组 用方法一分别给所有者所有权限，所在组读执行权限，其他组读权限 1 chmod u=rwx,g=rx,o=r hello.txt 用方法二给所在组添加写权限 1 chmod g+w hello.txt 用方法三添加所有权限 1 chmod 777 hello.txt ","date":"2025-09-30T10:32:33+08:00","permalink":"https://YLine-hub.github.io/p/linux%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/","title":"Linux用户组管理与权限管理"},{"content":"用法：按f12打开浏览器开发者工具，切换到控制台，然后复制粘贴以下脚本，回车。\n1 2 3 4 5 6 7 8 var article_content=document.getElementById(\u0026#34;article_content\u0026#34;); article_content.removeAttribute(\u0026#34;style\u0026#34;); var follow_text=document.getElementsByClassName(\u0026#39;follow-text\u0026#39;)[0]; follow_text.parentElement.parentElement.removeChild(follow_text.parentElement); var hide_article_box=document.getElementsByClassName(\u0026#39; hide-article-box\u0026#39;)[0]; hide_article_box.parentElement.removeChild(hide_article_box); ","date":"2025-09-30T10:14:04+08:00","permalink":"https://YLine-hub.github.io/p/csdn%E8%B7%B3%E8%BF%87%E5%85%B3%E6%B3%A8%E5%8D%9A%E4%B8%BB%E5%8D%B3%E5%8F%AF%E9%98%85%E8%AF%BB%E5%85%A8%E6%96%87/","title":"csdn跳过[关注博主即可阅读全文]"},{"content":"Linux文本编辑器 介绍 所有的Linux系统都会默认配置vi文本编辑器 vim具有程序编辑能力，可以看做vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计，而且还有代码补完，编译以及错误跳转等功能 三种模式 命令模式 启动 vi/vim，便进入了命令模式。\n此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符。\n常见命令 /+关键字 \u0026ndash; 查找关键字 切换输入操作 i \u0026ndash; 切换到输入模式，在光标当前位置开始输入文本。 a \u0026ndash; 进入插入模式，在光标下一个位置开始输入文本。 o \u0026ndash; 在当前行的下方插入一个新行，并进入插入模式。 O \u0026ndash; 在当前行的上方插入一个新行，并进入插入模式。 光标移动操作 G \u0026ndash; 光标移动到文件最后一行的位置。 gg \u0026ndash; 光标移动到文件第一行的位置。 shift + 4 \u0026ndash; 光标移动到当前行行尾。 shift + 6 \u0026ndash; 光标移动到当前行行首。 复制粘贴操作 dd \u0026ndash; 剪切当前行。 yy \u0026ndash; 复制当前行。 p（小写） \u0026ndash; 粘贴剪贴板内容到光标下方。 P（大写）\u0026ndash; 粘贴剪贴板内容到光标上方。 删除操作 x \u0026ndash; 删除当前光标所在处的字符。 撤销回退操作 u \u0026ndash; 撤销上一次操作。 Ctrl + r \u0026ndash; 重做上一次撤销的操作。 切换底线命令模式 : \u0026ndash; 切换到底线命令模式，以在最底一行输入命令。 输入模式 在命令模式下按下 i 就进入了输入模式，使用 Esc 键可以返回到普通模式。 底线命令模式 在命令模式下按下 :（英文冒号）就进入了底线命令模式。\n按 ESC 键可随时退出底线命令模式。\n基本命令 :w：保存文件。 :q：退出 Vim 编辑器。 :wq：保存文件并退出 Vim 编辑器。 :q!：强制退出Vim编辑器，不保存修改。 :set nu或set number：显示行号 ","date":"2025-09-29T20:57:21+08:00","permalink":"https://YLine-hub.github.io/p/linux%E7%9A%84vi%E4%B8%8Evim%E4%BD%BF%E7%94%A8/","title":"Linux的vi与vim使用"},{"content":"星期 月曜日 火曜日 水曜日 木曜日 金曜日 土曜日 日曜日 windows 常用工具 電卓（でんたく）：计算器 コントロール　パネル：control panel 控制面板 プログラム：program 节目；程序 システム：system 系统 セキュリティ：security 安全；保安；防护 ハードウェア：hardware 硬件 サウンド：sound 声音；音响 生词 機能（きのう）：机能；功能；作用 または：或者 有効（ゆうこう）：有效；生效 無効（むこう）：无效；失效 ユーザー：user 用户 アカウント：account 账号 カスタマイズ：customize 定制；个性化设置 地域（ちいき）：地区；区域 アクセシビリティ:accessibility 可访问性；可用性 制御（せいぎょ）：控制；调节；管理 許可（きょか）：许可 ","date":"2025-09-28T17:19:03+08:00","permalink":"https://YLine-hub.github.io/p/%E6%97%A5%E8%AF%AD%E7%94%9F%E8%AF%8D/","title":"日语生词"},{"content":"","date":"2025-09-28T16:28:56+08:00","permalink":"https://YLine-hub.github.io/p/java%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/","title":"Java开发工程师学习路线"},{"content":"运维工程师学习路线 初级运维工程师 中级运维工程师 高级运维工程师 ","date":"2025-09-28T16:28:33+08:00","permalink":"https://YLine-hub.github.io/p/%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/","title":"运维工程师学习路线"},{"content":"Linux常用指令 帮助指令 介绍 用来了解不熟悉的指令 man 基本语法 1 2 # 获取帮助信息 man [选项] [节号] 命令/主题 常见选项 -f：显示与指定关键字相关的手册页面。 -k：搜索手册页中与关键字匹配的条目。 -a：显示所有匹配的手册页面。 -w：仅显示手册页的位置，而不显示其内容。 常见节号 1：用户命令 2：系统调用 3：C库函数 4：设备和特殊文件 5：文件格式和约定 6：游戏和演示 7：杂项 8：系统管理命令 示例 1 2 # 查看ls命令的手册页面 man ls 1 2 # 查看C语言标准库函数printf的手册页面 man 3 printf 1 2 # 搜索包含特定关键字ls的手册页面条目 man -k ls 常用参数 1 2 3 4 5 6 箭头上：向上移动 箭头下：向下移动 大写N：向上查找 小写n：向下查找 /或? : 查找内容 q : 退出 help 基本语法 1 2 3 4 5 6 # 方法一 help [选项] 命令 # 方法二 命令 --help 基本选项 -d 显示内建命令的简要描述。 -m 按照 man 手册的格式输出帮助信息。 -s 仅输出内建命令的命令格式。 示例 1 2 # 查看cd命令的帮助信息 help cd 1 2 # 使用简短格式显示帮助 help -s cd 1 2 # 按man手册格式显示帮助 help -m cd 1 2 # 查看ls命令手册 ls --help 目录指令 pwd 介绍（显示目录） 显示当前目录的完整路径 基本语法 1 pwd [选项] 基本选项 -L（\u0026ndash;logical）：显示逻辑路径（默认）。\n-P（\u0026ndash;physical）：显示物理路径。\n\u0026ndash;help\t:显示帮助信息\n\u0026ndash;version\t:显示版本信息\n示例 1 2 3 4 5 6 7 8 9 $ mkdir -p /var/www/html $ ln -s /var/www/html/ myweb $ cd myweb/ $ pwd /home/yline/myweb # 逻辑路径（当前目录） $ pwd -L /home/yline/myweb # 逻辑路径 $ pwd -P /var/www/html # 物理路径 ls 介绍（查看目录） 用于显示指定工作目录下的内容 基本语法 1 ls [选项] [路径/文件] 常见选项 -a：显示所有文件（包括隐藏文件） -A：显示除.和..外的所有文件（包括隐藏文件） -l：以详细信息列出文件 -lh：以详细信息列出文件，并以可读的格式显示文件大小（如KB、MB） -t：按修改时间排序（最新优先） -r：反向排序（配合-t、-S等使用） -S：按文件大小排序（大文件优先） -R：递归列出子目录内容 示例 1 2 # 详细出当前目录所有文件（包含隐藏文件） ls -la 1 2 # 按照大小反向排序，并详细列出文件 ls -lShr 1 2 # 递归列出/opt/vmware-tools-distrib/ 及其所有子目录的内容，并显示可读的文件大小（kb） ls -lhR /opt/vmware-tools-distrib/ 1 2 # 仅显示/opt/这个目录的详细信息 ls -ld /opt 1 2 # 按修改时间排序(最新最后) ls -ltr 1 2 # 列出当前目录下所有名称是s开头的文件（最新最后） ls -ltr s* 选项 -l 详解 第一列的字符表示文件或目录的类型和权限。\n- 表示普通文件 d 表示目录 l 表示符号链接 c 表示字符设备文件 b 表示块设备文件 s 表示套接字文件 p 表示管道文件 其余 9 个字符表示文件或目录的访问权限，分别对应三个字符一组的 rwx 权限。\nr 表示读取权限 w 表示写入权限 x 表示执行权限 - 表示没有对应权限 1 2 # 前三个字符表示所有者的权限，中间三个字符表示所属组的权限，后三个字符表示其他用户的权限。 -rw-r--r-- 1 user group 4096 Feb 21 12:00 file.txt 其他常用操作 1 2 # 显示当前目录下最近修改的 5 个文件。 ls -lt | head -5 1 2 # 统计当前目录下的文件数量(不包括隐藏文件)。 ls | wc -l 注意事项 可以通过输出文件颜色，判断文件类型：\n蓝色：目录 绿色：可执行文件 红色：压缩文件 青色：链接文件 黄色：设备文件 cd 介绍（切换目录） 用于改变当前工作目录，切换到指定路径的命令。 基本语法 1 cd dirName dirName：要切换的目标目录，可以是相对路径或绝对路径。 示例 切换绝对路径 1 cd /path/to/directory 切换相对路径：指定相对于当前目录的路径来切换到目标路径 1 cd relative/path/to/directory 切换到/usr/bin/ 目录 1 cd /usr/bin 切换到上级目录 1 cd .. 切换到上上级目录 1 cd ../.. 切换到主目录（home）：使用~表示当前用户的主目录 1 cd ~ 切换到上次访问的目录 1 cd - 切换到环境变量指定的目录 1 cd $VAR_NAME mkdir 介绍（创建目录） 用于创建目录 基本语法 1 mkdir [-p] dirName 示例 在当前目录下创建一个myweb目录 1 mkdir myweb 在var下的www目录下创建一个myweb目录。（若www目录不存在，则自动创建一个） 注：不加-p参数的话，若www目录原本不存在，则会报错\n1 mkdir -p /var/www/myweb rmdir 介绍（删除目录） 用于删除空的目录 基本语法 1 mkdir [-p] dirName 示例 删除当前目录下的myweb空目录 1 rmdir myweb 若myweb不为空目录的话则报错：rmdir: failed to remove ‘myweb/’: Directory not empty\n删除www目录下名为myweb的子目录。若myweb删除后，www目录成为空目录，则www也删除 1 rmdir -p www/myweb 文件指令 touch 介绍（创建文件） 修改文件或目录的时间属性。若文件不存在，则会建立一个新文件 基本语法 1 touch 文件名 示例 创建空白文件index.html 1 touch index.html 将index.html文件的时间属性修改为当前系统时间（index.html存在，且时间不为最新时间） 1 touch index.html 创建多个空白文件 1 touch file1.txt file2.txt cp 介绍（复制文件） 用于复制文件或目录 基本语法 options : 选项 source : 源文件 dest ： 目标文件 1 cp [options] source dest 基本选项 -r 或 -R：递归复制目录及其内容（用于复制目录）。\n-i：交互模式，覆盖前提示用户确认。\n-f：强制复制，覆盖目标文件而不提示。\n-v：显示详细的复制过程（verbose）。\n-p：保留文件的原始属性（如权限、时间戳等）。\n-a：归档模式，等同于 -dpR，保留所有文件属性和递归复制目录。\n-u：仅当源文件比目标文件新时才复制（更新模式）。\n-l：创建硬链接而不是复制文件。\n-s：创建符号链接（软链接）而不是复制文件。\n示例 复制文件到目标目录 1 cp file.txt /path/to/destination 复制文件并重命名 1 cp file.txt /path/to/destination/newfile.txt 递归复制目录 1 2 # 将目录/source_dir及其目录下所有内容，递归复制到/destination目录 cp -r /path/to/source_dir /path/to/destination 交互模式复制 1 cp -i file.txt /path/to/destination 如果目标位置已存在同名文件，会提示用户确认是否覆盖，输入y就表示同意覆盖\n默认有-i选项，不加也行\n保留模式复制 1 cp -p file.txt /path/to/destinatino 复制文件并保留其原始属性（如权限、时间戳等 ）\n创建硬链接或符号链接 1 2 cp -l file.txt /path/to/destination/ # 创建硬链接 cp -s file.txt /path/to/destination/ # 创建符号链接 同时复制多个目标 1 cp *.txt /path/to/destination/ 结合find命令复制特定文件 1 2 # 查找并复制所有 .log 文件到目标目录。 find /path/to/source -name \u0026#34;*.log\u0026#34; -exec cp {} /path/to/destination/ \\; mv 介绍（移动文件【重命名】） 用来为文件或目录改名，或者移动到其他位置 基本语法 1 mv [options] source dest 基本选项 -b: 当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。 -i: 如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作。 -f: 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。 -n: 不要覆盖任何已存在的文件或目录。 -u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。 基本语法 命令格式 运行结果 mv source_file dest_file 将source_file改名为dest_file mv source_file dest_dir 将source_file移动到dest_dir目录下 mv source_dir dest_dir dest_dir存在，将source_dir移动到dest_dir下；dest_dir不存在，则将source_dir改名为dest_dir 示例 将文件aaa改名为bbb 1 mv aaa bbb 将info目录放入logs目录中。（若logs不存在，则将info改名为logs） 1 mv info/ logs 将/var/www/myweb下的所有文件和目录移动到当前目录下 1 mv /var/www/myweb . cat 介绍（查看、追加文件） 用于查看和连接文件 基本语法 1 cat [options] file 基本选项 -n：显示行号，会在输出的每一行前加上行号。 -b：显示行号，但只对非空行进行编号。 -s：压缩连续的空行，只显示一个空行。 -E：在每一行的末尾显示 $ 符号。 -T：将 Tab 字符显示为 ^I。 -v：显示一些非打印字符。 示例 查看文件内容 1 cat file1.txt 输入并覆盖文件内容 1 2 3 4 5 6 $ cat file1.txt abc $ cat \u0026gt; file1.txt 123 $ cat file1.txt 123 追加内容到文件末尾 1 2 3 4 5 6 7 $ cat file1.txt 123 $ cat \u0026gt;\u0026gt; file1.txt 456 $ cat file1.txt 123 456 连接文件，将file1和file2的内容合并到file3中 1 2 3 4 5 6 7 8 9 10 $ cat file1.txt 123 456 $ cat file2.txt iop $ cat file1.txt file2.txt \u0026gt; file3.txt $ cat file3.txt 123 456 iop 显示多个文件的内容 1 cat file1.txt file2.txt 使用管道，将cat的输出作为另一个命令的输入 1 cat filename | command 查看文件的最后3行（使用管道） 1 cat file1.txt | tail -n 3 查看文件并显示行号 1 cat -n file1.txt 查看文件并显示行号（空行不显示） 1 cat -b file1.txt 显示文件，并和连续空行 1 cat -s file1.txt 可以看到上一个的9、10两个空行被并合\n将file3文件的内容加上行号覆盖到file2文件中 1 cat -n file3.txt \u0026gt; file2.txt 显示文件内容，并用$表示行结束 1 cat -e file1.txt 把 file1 和 file2 的内容加上行号（空白行不加）之后将内容加到 file3 最后 1 cat -b file1.txt file2.txt \u0026gt;\u0026gt; file3.txt 清空file2的内容 1 cat /dev/null \u0026gt; file2.txt 使用cat制作镜像 cat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入： 1 cat /dev/fd0 \u0026gt; OUTFILE 相反的，如果想把 image file 写到软盘，输入： 1 cat IMG_FILE \u0026gt; /dev/fd0 head 介绍（查看文件开头） 用于查看文件的开头部分 基本语法 1 head [options] 文件 基本选项 -q : 隐藏文件名 -v : 显示文件名 -c \u0026lt;数目\u0026gt; : 显示的字节数。 -n \u0026lt;行数\u0026gt; : 显示的行数。 示例 显示file1的开头10行。（默认带参-n 10） 1 2 3 head file1.txt # 等价于 head -n 10 file1.txt 显示file1的开头5行 1 head -n 5 file1.txt 显示file1前20个字节 1 head -c 20 file1.txt tail 介绍（查看文件结尾） 查看文件的尾部内容 基本语法 1 tail [options] 文件 基本选项 -f : 循环读取 -q : 不显示处理信息 -v : 显示详细的处理信息 -c \u0026lt;数目\u0026gt; : 显示的字节数 -n \u0026lt;行数\u0026gt; : 显示文件的尾部 n 行内容 --pid=PID : 与-f合用,表示在进程ID,PID死掉之后结束 -q : 从不输出给出文件名的首部 -s : 与-f合用,表示在每次反复的间隔休眠S秒 示例 显示file1的最后10行 1 tail file1.txt 显示file1最后10行，并随file1的更新继续向下显示（常用于跟踪日志文件） 1 tail -f file1.txt 显示file1的内容，从第20行至末尾 1 tail -n +20 file1.txt 显示文件的最后10个字符 1 tail -c 10 file1.txt echo 介绍（显示文本） 在终端显示文本信息 输出变量的值 生成格式化的字符串 向文件追加内容 基本语法 1 echo [option] 字符串 常用选项 -n : 不输出换行符 -e : 启用转义字符解释 -E : 禁用转义字符解释（默认） 示例 输出字符串 1 echo \u0026#34;Hello,World!\u0026#34; 输出变量 1 2 name=\u0026#34;Linux User\u0026#34; echo \u0026#34;Welcome,$name!\u0026#34; 不带引号输出字符串（注意特殊字符） 1 echo Hello,World! -n:禁止换行 1 2 echo -n \u0026#34;Loading...\u0026#34; echo \u0026#34; success!\u0026#34; 结果:\n1 \u0026#34;Loading... success!\u0026#34; -e:启用转义字符 1 echo -e \u0026#34;First line\\nSecond line\u0026#34; 结合转义字符输出彩色文本 1 2 echo -e \u0026#34;\\033[31mRed Text\\033[0m\u0026#34; echo -e \u0026#34;\\033[42;30mGreen Background\\033[0m\u0026#34; 常用转义字符 \\n：换行 \\t：制表符 \\\\：反斜杠 \\a：警报（蜂鸣） 颜色代码 \\033[31m：红色 \\033[32m：绿色 \\033[0m：重置颜色 高级用法 使用重定向将输出保存到文件 \u0026gt; : 覆盖文件 \u0026gt;\u0026gt; : 在末尾追加内容 1 echo \u0026#34;Log entry\u0026#34; \u0026gt;\u0026gt; log.txt 命令替换：输出其他命令的执行结果 1 echo \u0026#34;Current date: $(date)\u0026#34; 格式化输出：结合printf风格的格式化 1 echo -e \u0026#34;Name\\tAge\\n----\\t---\\nAlice\\t25\\nBob\\t30\u0026#34; 简单应用示例 (1)创建简单菜单 1 2 3 4 5 6 7 8 #!/bin/bash echo \u0026#34;============ Menu ============\u0026#34; echo \u0026#34;1. Check system info\u0026#34; echo \u0026#34;2. List directory contents\u0026#34; echo \u0026#34;3. Show current user\u0026#34; echo \u0026#34;4. Exit\u0026#34; echo \u0026#34;==============================\u0026#34; echo -n \u0026#34;Please enter your choice [1-4]: \u0026#34; (2)进度条模拟 1 2 3 4 5 6 7 #!/bin/bash echo -n \u0026#34;Progress: [\u0026#34; for i in {1..20}; do echo -n \u0026#34;#\u0026#34; sleep 0.1 done echo \u0026#34;] Done!\u0026#34; (3)配置文件生成 1 2 3 4 5 6 #!/bin/bash config_file=\u0026#34;app.conf\u0026#34; echo \u0026#34;# Application Configuration\u0026#34; \u0026gt; $config_file echo \u0026#34;LOG_LEVEL=DEBUG\u0026#34; \u0026gt;\u0026gt; $config_file echo \u0026#34;MAX_CONNECTIONS=100\u0026#34; \u0026gt;\u0026gt; $config_file echo \u0026#34;Configuration file $config_file created\u0026#34; sh文件的运行（执行shell脚本） 方法一 1 sh f1.sh 方法二 1 bash f1.sh 方法三 1 ./f1.sh 若出现 -bash: ./f1.sh: Permission denied 则需要授权\n1 2 3 4 5 # 添加可执行权限 chmod +x f1.sh # 添加所有权限 chmod 777 f1.sh 方法四 1 . f1.sh more 介绍 它不会一次性显示整个文件，而是分屏逐页显示，方便查看长文本文件。\n内置快捷键\nh：获得帮助信息 Enter：向下翻滚一行 空格：向下滚动一屏 Ctrl+f：向后滚动一页 Ctrl+b：向前滚动一页 q：退出命令 基本语法 1 more filename 示例 分页显示文件 1 more filename 从文件第n行开始显示 1 more +n filename 显示文件的前n行 1 more -n filename ln 介绍（创建链接） 为某个文件在另个位置建立同步链接\n软连接\n1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式 2.软链接可以 跨文件系统 ，硬链接不可以 3.软链接可以对一个不存在的文件名进行链接 4.软链接可以对目录进行链接 硬链接\n1.硬链接，以文件副本的形式存在。但不占用实际空间。 2.不允许给目录创建硬链接 3.硬链接只有在同一个文件系统中才能创建 基本语法 1 ln [options] source dest 基本选项 -s : 软链接(符号链接) 示例 给文件创建软连接，若f1.sh丢失，fufu将失效 1 ln -s f1.sh fufu 给文件创建硬链接 1 ln f1.sh fufu2 fufu2与f1.sh文件属性都相同\n历史指令 history 介绍 记录用户在终端执行的所有命令历史。\n作用：\n追溯操作：查看之前执行过的命令 快速重用：无需重新输入长命令 问题排查：检查系统操作记录 效率提升：通过历史命令快速完成重复工作 基本语法 1 history [options] [parameter] 基本选项 -c : 清除所有历史记录\thistory -c -d : 删除指定位置的历史记录\thistory -d 1005 -a : 立即将内存中的历史写入历史文件\thistory -a -n : 从历史文件中读取未读的历史记录\thistory -n -r : 读取历史文件内容到当前会话\thistory -r -w : 将当前历史记录写入历史文件\thistory -w 示例 常看完整历史记录 1 history 查看最近10条记录 1 history 10 清除所有记录 1 history -c 删除第1010条历史记录 1 history -d 1010 使用技巧 （1）快速执行历史命令 1 2 3 !1024 # 执行历史记录中编号为1024的命令 !! # 重新执行上一条命令 !vim # 执行最近一条以vim开头的命令 （2）搜索历史命令 使用Ctrl+R可以反向搜索历史命令，输入部分关键词即可找到匹配命令\n（3）历史命令替换 1 ^old^new # 将上一条命令中的old替换为new后执行 1 2 $ cat file1.txt $ ^file1^file2 # 相当于执行 cat file2.txt （4）显示命令时间戳 在 ~/.bashrc 中添加以下配置可以显示命令执行时间：\n1 export HISTTIMEFORMAT=\u0026#34;%F %T \u0026#34; 然后执行\n1 source ~/.bashrc 之后 history 命令会显示每条命令的执行时间。\n实际应用场景 找回忘记的命令 1 history | grep \u0026#34;apt install\u0026#34; 统计最常用的命令 1 history | awk \u0026#39;{CMD[$2]++;count++;} END {for (a in CMD)print CMD[a] \u0026#34; \u0026#34; CMD[a]/count*100 \u0026#34;% \u0026#34; a;}\u0026#39; | grep -v \u0026#34;./\u0026#34; | column -c3 -s \u0026#34; \u0026#34; -t | sort -nr | nl | head -n10 备份历史记录 1 2 history -a # 确保最新命令已写入文件 cp ~/.bash_history ~/command_history_backup_$(date +%F).txt 找出最近5条使用yum的命令 1 history | grep yum | tail -5 环境变量配置 通过环境变量可以自定义 history 命令的行为： 变量 说明 推荐值 HISTSIZE 内存中保存的历史命令数量 5000 HISTFILESIZE 历史文件中保存的命令数量 10000 HISTCONTROL 控制历史记录方式 ignoredups:erasedups HISTIGNORE 指定不记录的命令 \u0026ldquo;ls:cd:pwd:exit\u0026rdquo; 示例（添加到 ~/.bashrc 中） 1 2 3 4 5 export HISTSIZE=5000 export HISTFILESIZE=10000 export HISTCONTROL=ignoredups:erasedups export HISTIGNORE=\u0026#34;ls:cd:pwd:exit\u0026#34; export HISTTIMEFORMAT=\u0026#34;%F %T \u0026#34; 注意事项 隐私安全：历史记录可能包含敏感信息（如密码），注意保护 多终端问题：不同终端会话默认不会实时共享历史记录 历史记录丢失：异常退出可能导致命令未保存 大文件处理：过大的历史文件可能影响性能 时间指令 date 介绍（显示时间） 用来显示或设定系统的日期与时间 示例 显示当前时间 1 2 3 4 5 6 7 8 9 10 11 12 # 显示日期 date #显示当前时间 date +%Y #显示当前年份 date +%m #显示当前月份 date +%d #显示当前日份 date \u0026#34;+%Y-%m-%d %H:%M:%S\u0026#34; #显示年月日时分秒 date -s 时间字符串 #修改系统时间，例：2021-4-15 12:00:00 1 cal #显示日历时间 搜索指令 find 介绍 用于在指定目录下查找文件和目录。 基本语法 1 find [path] [condition] [action] 示例 查找当前目录及其子目录下名为file.txt的文件 1 find . -name file.txt 将当前目录及其子目录下所有文件后缀.c的文件列出来 1 find . -name \u0026#34;*.c\u0026#34; 将当前目录及其子目录中所有文件列出来 1 find . -type f 查找/home目录及其子目录下大于1MB的文件 1 find /home -size +1M 查找/var/www 目录及其子目录下7天前被修改过的文件 1 find /var/www -mtime +7 查找/var/www 目录及其子目录下7天内被访问的文件 1 find /var/www -atime -7 找并执行操作（例如删除）： 这个例子中，-exec 选项允许你执行一个命令，{} 将会被匹配到的文件名替代，\\; 表示命令结束。\n1 find /path/to/search -name \u0026#34;pattern\u0026#34; -exec rm {} \\; locate 介绍 用于查找符合条件的文档。 示例 查找所有带passwd的文件 1 locate passwd 查找/var/www/myweb 下所有file开头的文件 1 locate /var/www/myweb/file 忽略大小写查找/var/www/myweb 下所有f开头的文件 1 locate -i /var/www/myweb/f grep 介绍 用于查找文件里符合条件的字符串或正则表达式 基本语法 1 2 3 4 5 # 语法一 grep [options] pattern [files] # 语法二 comman | grep [options] pattern [files] 示例 1 2 3 4 5 6 7 8 # 显示匹配行及行号 grep -n 查找内容 源文件 # 忽略大小写 grep -i 查找内容 源文件 # cat 查找后的内容用grep查找某个内容 cat 源文件 | grep 查找内容 压缩和解压 tar 介绍 用于打包和解压文件 基本语法 -f archive.tar：指定归档文件的名称。 [files\u0026hellip;]：要打包的文件和目录。 1 tar [options] -f archive.tar [files...] 基本选项 -c：创建一个新的归档文件。 -x：解压归档文件。 -t：列出归档文件的内容。 -r：向现有归档文件中追加文件。 -u：仅追加比归档文件中已有文件更新的文件。 -d：找到归档文件中与文件系统不同步的差异。 -A：将一个 .tar 文件追加到另一个 .tar 文件中。 示例 创建归档文件 : 将文件file1、file2和dir打包到一个名为arc.tar的归档文件中\n-c: 创建新的归档文件 -v: 显示详细输出，列出被添加到归档中的文件 -f: 指定归档文件的名称 1 tar -cvf arc.tar file1 file2 dir 解压归档文件：解压名为 archive.tar 的归档文件，还原其中包含的文件和目录。\n-x: 解压归档文件 -v: 显示详细输出，列出被解压的文件 -f: 指定要解压的归档文件的名称 1 tar -xvf archive.tar 压缩归档文件：将名为 directory 的目录打包成一个归档文件，然后使用 gzip 进行压缩，生成名为 archive.tar.gz 的文件。\n-c: 创建新的归档文件 -z: 使用 gzip 压缩归档文件 -v: 显示详细输出，列出被添加到归档中的文件 -f: 指定归档文件的名称 1 tar -czvf archive.tar.gz directory 列出归档文件中的内容：列出名为 archive.tar 的归档文件中包含的所有文件和目录。\n-t: 列出归档文件中的内容 -v: 显示详细输出，列出归档文件中的所有文件和目录 -f: 指定要列出内容的归档文件的名称 1 tar -tvf archive.tar 追加文件到已存在的归档中：将名为 newfile 的文件添加到已存在的名为 archive.tar 的归档文件中。\n-r: 向已存在的归档中追加文件 -v: 显示详细输出，列出被添加到归档中的文件 -f: 指定已存在的归档文件的名称 1 tar -rvf archive.tar newfile 创建一个经过 gzip 压缩的归档文件：打包 directory 目录下的所有文件和子目录，并使用 gzip 压缩，生成名为 archive.tar.gz 的归档文件。\n-z: 表示要使用 gzip 进行压缩。 -c: 表示创建新的归档文件。 -v: 表示详细输出，列出被添加到归档中的文件。 -f: archive.tar.gz: 指定归档文件的名称为 archive.tar.gz。 1 tar -zcvf archive.tar.gz directory 解压一个已经被 gzip 压缩的归档文件：解压 example.tar.gz 文件，并在当前目录下恢复其中包含的文件和目录。\n-z: 表示要使用 gzip 解压归档文件。 -x: 表示解压操作。 -v: 表示详细输出，列出被解压的文件。 -f: example.tar.gz: 指定要解压的归档文件的名称为 example.tar.gz。 1 tar -zxvf example.tar.gz 其他命令 详情请看：Linux命令大全\n","date":"2025-09-27T23:10:09+08:00","permalink":"https://YLine-hub.github.io/p/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","title":"Linux常用指令"},{"content":"CentOS7.6找回密码 通过单用户模式修改root密码，因为单用户模式不需要账号登陆\n在开机界面时按下e，进入编辑模式 在截图位置，添加rw single init=/bin/bash，然后按ctrl+x引导系统，进入单用户模式 然后输入passwd来重置root密码 1 passwd 在此处分别输入两次新密码，这里不会有东西显示。\n其中乱码部分是因为设置的系统为中文，这里无法显示。\n若是英文的话，修改成功以后这里会显示successfully 输入touch /.autorelabel更新selinux信息 1 touch /.autorelabel 运行exec /sbin/init来重启系统 1 exec /sbin/init 重新用新密码登陆即可 ","date":"2025-09-27T17:37:30+08:00","permalink":"https://YLine-hub.github.io/p/centos7.6%E6%89%BE%E5%9B%9E%E5%AF%86%E7%A0%81/","title":"CentOS7.6找回密码"},{"content":"日语翻译 各种小写输入方法 ぇ、ェ： l（小写L） + e\nぃ、ィ： l（小写L） + i\nぉ、ォ： l（小写L） + o\nXshell 输入gnome-session -version时出现弹窗 生词 転送（てんそう）：转送 要求（ようきゅう）：要求 処理（しょり）：处理 ソフトウェア：software 软件 インストール：install 安装 プログラム：program 程序；计划；节目 実行（じっこう）：实行 直接（ちょくせつ） 体験版（たいけんばん） ダウンロード：download 下载 セッション：session / ˈseʃ(ə)n / 会话；会议；会期 プロパティ：property / ˈprɑːpərti / 属性；特性；财产 接続（せつぞく）：连接 トンネリング：tunneling / ˈtʌnlɪŋ / n、隧道效应；开挖隧道 ページ：page 页；页面 オフ：off 关闭；休息 オプション：option / ˈɑːpʃ(ə)n / 选择 メッセージ：message　信息；消息；短信 フォワーディング： forwarding 转发 フォワード： forward / ˈfɔːrwərd / 转发 翻译的句子 X11転送要求を処理するには、Xmanagerソフトウェアが必要です。 Xmanagerをインストールすると、Xtermやgonome-terminalなどのX11プログラムをXshellから実行し、Windowsで直接使用することができます。 Xmanager体験版を今すぐダウンロードしますか？ （セッションプロパティ　-\u0026gt; 接続　-\u0026gt; SSH -\u0026gt;　トンネリングページでX11転送オプションをオフにすることで、このメッセージをオフにすることができます）\n翻译 对于处理X11的转发请求，Xmanager软件是必须的。 安装Xmanager就能直接在windows中使用，通过Xshell运行Xterm、gonome-terminal等X11程序。 现在马上下载Xmanager体验版吗？ （在 会话属性-\u0026gt;连接-\u0026gt;SSH-\u0026gt;开启隧道页面 中 用关闭X11转发选项，能够关闭这个消息）\n关闭该消息 右键プロパティ 点击トンネリング 关闭X11转发 再次输入没有信息弹出 Xshell的重新连接 重新连接服务器 1 reconnect VMware 点击下面叉叉关闭虚拟机时 生词 パワーオン：power on 仮想（かそう）：虚拟；假想 マシン：machine 机器；机械 引き続き（ひきつづき）：继续；连续 バックグラウンド：background 背景；幕后 サスペンド：suspend 暂停；中止；悬挂 语法 Vた後で：之后；然后；之后接着 ～たり～たり：又\u0026hellip;又\u0026hellip;；或\u0026hellip;或\u0026hellip;；有时\u0026hellip;有时\u0026hellip; 翻译的句子 「Centos　test」は現在パフーオン状態です。 仮想マシンを引き続きバックグラウンドで実行したり、サスペンドした後で使用したり、今すぐパフーオフしたりできます。 サスペンド パフーオフ バックグラウンドで実行 キャンセル\n翻译 centos test现在时开机状态。 能够继续在幕后运行虚拟机，或者现在暂停之后再使用，或者现在马上关机。 暂停 关机 挂起运行 取消\n安全中心添加排除项 生词 プライバシー：privacy 隐私；私密 セキュリティ：security 安全；防护 ウイルス：virus 病毒 脅威（きょうい）：威胁 防止（ぼうし）：防止；预防 除外（じょがい）：排除；不包括；例外 追加（ついか）：增加；追加；补充 削除（さくじょ）：删除；消除；取消 項目（こうもく）：项目 デバイス：device 设备 脆弱（ぜいじゃく）：脆弱；易碎；不牢固 含む（ふくむ）：包含 スキャン：扫描；浏览；审查 操作 打开设置 按win键，在搜索栏中输入：設定（せってい） 打开设置，点击：プライバシーとセキュリティ 点击：Windows セキュリティ 点击：Windows セキュリティを開く，打开windows安全中心 在Windows　セキュリティ中，点击：ウイルスと脅威の防止 点击ウイルスと脅威の防止の設定下的設定の管理 找到除外，点击下面的除外の追加または削除 点击除外の追加来添加排除项 翻译的句子 除外 Microsoft Defender ウイルス対策は、除外されたアイテムをスキャンしません。除外された項目には、デバイスを脆弱にする脅威が含まれている可能性があります。 除外の追加または削除\n翻译 排除项 Microsoft Defender 应对病毒是不会扫描排除的项目。对排除的项目来说，可能包含使设备脆弱的威胁。 增加或删除排除项\n","date":"2025-09-27T14:31:19+08:00","permalink":"https://YLine-hub.github.io/p/%E7%94%B5%E8%84%91%E6%97%A5%E8%AF%AD%E5%8C%96%E4%BD%BF%E7%94%A8-%E6%97%A5%E8%AF%AD%E7%BF%BB%E8%AF%91/","title":"电脑日语化使用 日语翻译"},{"content":"Linux入门 Linux简介 介绍 linux是一个开源、免费的操作系统，其稳定性、安全性、处理多并发已经得到业界的认可，目前很多中型，大型甚至是集群项目都在使用linux，很多软件公司考虑到开发成本都首选linux，在中国软件公司得到广泛的使用。 Linux发行版 Ubuntu Fedora Debian Arch Linux Suse CentOS RedHat 国产： Deepin Ubuntu Kylin StartOS Nova Linux网络连接方式 桥接模式（Bridge Mode） 将虚拟机直接连接到宿主机所在的物理网络中，虚拟机拥有与宿主机相同的网络环境。\n特点\n虚拟机与宿主机处于同一网段。 虚拟机拥有独立的真实IP地址。 虚拟机可以直接与外部网络通信。 优点：\n处于同一网段，虚拟系统可以和处于同网段的外部系统通讯。\n支持高级网络功能，如VLAN、QoS和安全策略。\n缺点：\n容易造成IP冲突，因为同一个网段最多255个IP地址。\n缺乏隔离，可能导致不必要的广播流量和潜在的安全风险。\n示例\n假设宿主机的IP地址为192.168.1.10，虚拟机的IP地址为192.168.1.22，两者处于同一网段。\n1 2 # 桥接模式下虚拟机的网络配置 ifconfig eth0 192.168.1.22 netmask 255.255.255.0 NAT模式（Network Address Translation） NAT模式通过宿主机的IP地址与外部网络通信，虚拟机的IP地址由宿主机的虚拟网络提供。\n特点\n虚拟机与宿主机不在同一网段。 虚拟机通过宿主机的网关访问外部网络。 外部网络无法直接访问虚拟机。 优点：\n简化网络管理，避免IP冲突。\n提供了一定的安全性，因为内部网络与外部网络隔离。\n缺点：\n内部设备无法直接被外部访问。\n可能会增加网络延迟，因为需要进行地址转换。\n示例\n假设宿主机的IP地址为192.168.1.10，虚拟机的IP地址为192.168.2.3。\n1 2 # NAT模式下虚拟机的网络配置 ifconfig eth0 192.168.2.3 netmask 255.255.255.0 主机模式（Host-Only Mode） 主机模式下仅允许虚拟机与宿主机之间的通信，无法直接访问外部网络。\n特点\n虚拟机与宿主机处于同一网段。 虚拟机无法直接访问外部网络。 适用于隔离环境的开发和测试场景。 优点：\n提供了一个与物理网络隔离的虚拟网络环境，适合用于开发和测试。\n提高了安全性，因为虚拟机无法直接访问外部网络。\n缺点：\n无法直接访问外部网络，需要通过宿主机进行代理或路由。 示例\n假设宿主机的IP地址为192.168.56.1，虚拟机的IP地址为192.168.56.101。\n1 2 # 仅主机模式下虚拟机的网络配置 ifconfig eth0 192.168.56.101 netmask 255.255.255.0 Linux目录结构 树状目录结构 Linux文件系统采用层级式树状目录结构，在此结构中的最上层是根目录”/“，然后再次目录下创建其他目录。 Linux的基本理念：一切皆文件 目录介绍 /dev：（Device）存放Linux的外部设备，将硬件以文件的形式存放在该目录下。\n/lib：（Library）存放着系统最基本的动态连接共享库，类似于 Windows 里的 DLL 文件。\n/selinux：Redhat/CentOS特有的目录，Selinux是一个安全机制，类似windows的防火墙，但是这套机制比较复杂，这里存放selinux的相关文件。\n/tmp：（temporary）存放临时文件。\n/lost+found：一般是空的，当系统非法关机后，这里就存放了一些文件。\n/run：临时文件系统，存储系统启动以来的信息。重启时，这个目录下的文件应该被删掉或清除。/var/run 目录，应该让它指向 run。\n重要且尽量别动 /etc：（Etcetera）存放系统管理的配置文件和子目录。\n/bin：（Binaries） 存放常用命令。\n/sbin：（Superuser Binaries）存放超级管理员使用指令。\n/usr/bin：系统用户使用的命令。\n/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。\n重点目录 /boot：存放启动Linux时的一些核心文件，包括连接文件以及镜像文件。\n/home：用户主目录，在 Linux 中，每个用户都有一个自己的目录，目录名为用户账号名。\n/media：自动识别U盘、光驱等设备，识别后会挂载到这个目录下。\n/mnt：让用户临时挂载别的文件系统的，可以将光驱挂载在/mnt/ 上。\n/opt：（optional）给主机安装软件的目录。\n/root：超级权限者的用户主目录。\n/usr：（unix system resources）用户的很多应用程序和文件都放在这个目录下，类似于windows的program files目录。\n/usr/src：内核源代码默认的放置目录。 /var：（variable）存放经常修改的数据。如日志文件。\n以下目录尽量别动 /sys：Linux2.6内核后出现了新文件系统 sysfs 。\nsysfs 集成了3种文件系统的信息：针对进程信息的 proc 、针对设备的 devfs 、针对伪终端的 devpts 。\n/srv：存放一些服务启动之后需要提取的数据。\n/proc：（Processes）存储当前内核运行状态的特殊文件，是一个虚拟的目录，是系统内存的映射，可以通过访问这个目录来获取系统信息。\n该目录的内容在内存里，也可以直接修改其中某些文件，如可以通过下面的命令来屏蔽主机的ping命令： 1 echo 1 \u0026gt; /proc/sys/net/ipv4/icmp_echo_ignore_all Linux的运行级别 常用单词 rescue / ˈreskjuː / v、n、营救； multi / ˈmʌlti / pref、多 graphical / ˈɡræfɪkl / adj、绘画的；计算机图形的 isolate / ˈaɪsəleɪt / v、孤立，分离；单独考虑 adj、孤独的，孤立的 systemctl （ctl是 control 的缩写） 运行级别分类 运行级别 说明 适用环境 0 关机poweroff.target 系统关闭时使用 1 单用户模式rescue.target 系统维护或故障修复时使用（找回丢失密码） 2 多用户无网络模式 适用于网络功能不重要的场景 3 多用户有网络模式（常用）multi-user.target 适用于服务器环境 4 未定义（通常由系统自定义） 由系统或用户自定义功能 5 图形界面模式（常用）graphical.target 适用于桌面环境 6 重启reboot.target 系统重启时使用 运行级别配置文件：/etc/inittab (旧版本) 运行级别配置文件：/lib/systemd/system目录下的xxx.target文件(CentOS7以上) 常见Linux运行级别差异 系统版本 运行级别0 运行级别1 运行级别2 运行级别3 运行级别4 运行级别5 运行级别6 CentOS 7 关机 单用户模式 多用户模式 多用户模式 多用户模式 图形界面模式 重启 Ubuntu 关机 单用户模式 多用户模式 多用户模式 未定义 图形界面模式 重启 Slackware 关机 单用户模式 多用户模式 图形界面模式 未定义 未定义 重启 运行级别相关指令 查看当前运行级别 1 2 3 4 5 # 查看当前运行级别 runlevel # 查看默认运行级别（CentOS7以上） systemctl get-default 切换运行级别 1 2 3 4 5 6 7 # 适用于老旧系统 init 3 # 切换到运行级别3，字符界面 init 5 # 切换到运行级别5，图形界面 # 适用于现代系统 （CentOS7以上） systemctl isolate multi-user.target # 切换到运行级别3 systemctl isolate graphical.target # 切换到运行级别5 切换图形界面 切换图形界面 1 systemctl isolate graphical.target 发现并没有切换过去\n查看是否安装 1 rpm -qa | grep gnome-desktop 安装图形化界面 1 yum groupinstall \u0026#34;GNOME Desktop\u0026#34; \u0026#34;Graphical Administration Tools\u0026#34; 再次切换到图形化界面 1 systemctl isolate graphical.target 虚拟机已经成功切换到图形界面\n如果要设置默认启动图形化界面 1 systemctl set-default graphical.target ","date":"2025-09-26T17:30:21+08:00","permalink":"https://YLine-hub.github.io/p/linux%E5%85%A5%E9%97%A8/","title":"Linux入门"},{"content":"Centos打开80端口 查看端口是否开启 1 firewall-cmd --query-port=80/tcp 开启80端口，permanent永久，重启以后端口还会开启，若不加的话，重启以后端口要重新打开 单词：permanent / ˈpɜːrmənənt / adj.永久的 \u0026ndash;zone=public 指的是，指定添加服务的区域名称为public\n1 firewall-cmd --zone=public --add-port=80/tcp --permanent 关闭80端口命令 1 firewall-cmd --zone=public --remove-port=80/tcp --permanent 重启防火墙，要重启防火墙后开启端口才会生效 1 firewall-cmd --reload ","date":"2025-09-26T17:22:53+08:00","permalink":"https://YLine-hub.github.io/p/centos%E6%89%93%E5%BC%8080%E7%AB%AF%E5%8F%A3/","title":"Centos打开80端口"},{"content":"VMware的Centos安装VMwareTools VMwareTools镜像准备 （1）VMware Tools 安装VMware Tools VMware安装VMTools的DVD 点击设置 添加一个DVD 使用VMware Tools镜像 启动centos 将VMTools挂载在虚拟机上 观察磁盘分区 1 lsblk 发现VMTools在磁盘sr0上\n创建一个目录作为挂载点 1 mkdir /media/dvd 将dvd挂载到创建的目录下 1 mount /dev/sr0 /media/dvd 查看dvd中的内容 1 ll /media/dvd 成功挂载到dvd目录下\n安装 将VMwareTools-10.3.26-22085142.tar.gz，复制到/opt目录下并命名为vm.tar.gz 1 cp /media/dvd/VMwareTools-10.3.26-22085142.tar.gz /opt/vm.tar.gz 在/opt目录下查看文件，并解压vm.tar.gz 1 2 3 cd /opt ll tar -zxvf vm.tar.gz 进入vmware-tools-distrib目录，并输入./vmware-install.pl尝试安装 1 2 3 cd vmware-tools-distrib/ ll ./vmware-install.pl 出现报错：-bash: ./vmware-install.pl: /usr/bin/perl: bad interpreter: No such file or directory，表明未安装编译环境\n安装编译环境 1 yum -y install perl gcc make kernel-headers kernel-devel 安装完成后再次尝试安装，安装时一直回车即可 1 ./vmware-install.pl 出现问题：The path \u0026quot;\u0026quot; is not a valid path to the 3.10.0-693.el7.x86_64 kernel headers\nctrl+c退出安装，使用yum更新再次重新安装 1 2 yum -y update ./vmware-install.pl 安装完成后，可以通过以下命令检查 VMware Tools 是否正常运行： 1 vmware-toolbox-cmd -v ","date":"2025-09-26T16:24:54+08:00","permalink":"https://YLine-hub.github.io/p/vmware%E7%9A%84centos%E5%AE%89%E8%A3%85vmwaretools/","title":"VMware的Centos安装VMwareTools"},{"content":"使用yum进行安装软件时出现报错：curl#6 - \u0026ldquo;Could not resolve host: mirrorlist.centos.org; Unknown error\u0026rdquo; 备份默认源文件 1 2 sudo mkdir -p /etc/yum.repos.d/backup sudo mv /etc/yum.repos.d/CentOS-*.repo /etc/yum.repos.d/backup/ 下载阿里云源文件 1 2 3 4 5 # 基础源文件 sudo curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo # 下载EPEL扩展源（可选） sudo curl -o /etc/yum.repos.d/epel.repo https://mirrors.aliyun.com/repo/epel-7.repo 清理并重建yum缓存 1 2 yum clean all yum makecache fast 检验是否更新，查看仓库列表 1 sudo yum repolist 再次安装已经能正常安装 ","date":"2025-09-26T16:12:03+08:00","permalink":"https://YLine-hub.github.io/p/linux%E6%9B%B4%E6%8D%A2yum%E6%BA%90%E4%B8%BA%E9%98%BF%E9%87%8C%E4%BA%91%E6%BA%90/","title":"Linux更换yum源为阿里云源"},{"content":"创建第一个Centos虚拟机 软件准备 （1）VMware Download VMware Workstaion Pro（Win/Linux）\nVMware Fusion (Mac) （2）Centos 7.6 ISO （清华源） （3）xshell 创建虚拟机 创建虚拟机 自定义（高级） 之后选择iso 选择Linux3.x\nCentos 7系列对应Linux3.x\nCentos 8系列对应Linux4.x\n设置虚拟机名和安装路径 选择2核2G 选择15G最大容量 初次开机前先对虚拟机进行设置 不需要声音就将其移除即可 CD/DVD选择自己下载的Centos7.6 iso镜像 点击ok后启动 安装Centos 选择安装Centos 选择自己需要的语言并进入 设置时间 设置分区 点击自己配置，后点击Done 配置后点击Done，然后点击接受改变 配置网络 注意记住ip，若没记住进入虚拟机后输入hostname -i 也可也查询ip 配置完成，点击安装 在等待安装时，分别设置root用户密码和第一个用户账户 创建好账号以后就可以等待安装了 安装完成后点击重启 xshell 远程连接centos 进入Centos后查询ip 1 hostname -i 在xshell中点击新建 输入服务器名称和ip后点击连接 点击保存 输入用户名和密码 连接成功 ","date":"2025-09-26T15:04:30+08:00","permalink":"https://YLine-hub.github.io/p/%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAcentos%E8%99%9A%E6%8B%9F%E6%9C%BA/","title":"创建第一个Centos虚拟机"},{"content":"github自动部署 创建新的仓库-项目主仓库 创建项目主仓库，存放项目源码，并将其设置为私有仓库 将不需要上传的文件忽略 在根目录下创建文件.gitignore\n1 2 3 4 public resources .hugo_build.lock hugo.exe 上传程序代码 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin https://github.com/YLine-hub/hugo-dev.git git push -u origin main 移除错误上传文件 突然发现多上传了hugo.exe，这时候就需要将它移除\n移除hugo.exe 1 git rm --cached hugo.exe 重新提交代码并推送 1 2 git commit -m \u0026#34;移除hugo.exe\u0026#34; git push -u origin main 自动部署 官方文档：hugo:Host on GitHub Pages\n(1)前往Settings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens，创建一个token，用于上面传到仓库\n(2)设置无限时间，作用范围选择repo和workflow (3)之后点击生成，获取token (4)使用注入变量注入token\n到项目仓库下，点击Settings 点击Secrets and variables，里面的Actions 创建一个新的环境变量TOKEN (5)在hugo主文件创建一个.githubb/workflows/xxxx.yaml文件，将以下内容复制进入，具体详情：查看【Github Action文档】\nhugo_deploy.yaml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 name: deploy # 代码提交到main分支时触发github action on: # 监听，当推送到分支main时将会自动触发 push: branches: - main jobs: deploy: runs-on: ubuntu-latest # 运行在ubuntu的最新版本上 steps: # 运行了四个脚本 - name: Chekout uses: actions/checkout@v4 # 比如该脚本来自 https://github.com/actions/checkout with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; # 安装的版本为最新 extended: true # 并且带有extended - name: Build Web # 生成静态页面 run: hugo -D # 生成脚本 - name: Deploy Web # 部署到静态页面仓库 uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.你的token变量名 }} EXTERNAL_REPOSITORY: 你的github名/你的仓库名 PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy # 提交信息 配置以下信息 1 2 3 4 5 6 7 8 9 10 jobs: ...... - name: Deploy Web # 部署到静态页面仓库 uses: peaceirls/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.TOKEN }} EXTERNAL_REPOSITORY: YLine-hub/YLine-hub.github.io PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy # 提交信息 提交代码 1 2 3 git add . git commit -m \u0026#34;update\u0026#34; git push 查看仓库是否运行了代码 运行失败，发现仓库名打错了，重新输入并上传 再次进入action，代码正在运行 运行成功以后，对本地和线上页面进行比较，发现还没更新 查看仓库以后，发现原来设置的仓库错了 恢复仓库 (1)查看历史版本 1 git relog/log (2)强制回滚历史版本 1 git reset 82c1130af45eeee3930b3d2e403458282f9f0296 (3)提交 1 git push origin main --force --force 为强制提交\n仓库回到历史版本\n(4)修改完代码以后重新提交，修改成功 ","date":"2025-09-25T19:34:37+08:00","permalink":"https://YLine-hub.github.io/p/github%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo/","title":"github自动部署hugo"},{"content":"stack自主配置 注：官方文档：stack-config\n核心配置文件hugo.yaml 语言配置 1 2 3 4 # Theme i18n support # Available values: ar, bn, ca, de, el, en, es, fr, hu, id, it, ja, ko, nl, pt-br, th, uk, zh-cn, zh-hk, zh-tw // 设置默认中文 DefaultContentLanguage: zh-cn 刷新后，界面默认变成中文\n建议：若默认语言为中文时，设置为true 1 2 3 # Set hasCJKLanguage to true if DefaultContentLanguage is in [zh-cn ja ko] # This will make .Summary and .WordCount behave correctly for CJK languages. hasCJKLanguage: true 配置国际化语言 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 languages: en: languageName: English title: Example Site weight: 1 params: sidebar: subtitle: Example description zh-cn: languageName: 中文 title: 演示站点 weight: 2 params: sidebar: subtitle: 演示说明 ar: languageName: عربي languagedirection: rtl title: موقع تجريبي weight: 3 params: sidebar: subtitle: وصف تجريبي 目前我只留下中文，同时国际化选项被去除 1 2 3 4 5 6 7 8 languages: zh-cn: languageName: 中文 title: 演示站点 weight: 2 params: sidebar: subtitle: 演示说明 该处title和subtitle分别能够修改这两处 1 2 3 4 5 6 7 8 languages: zh-cn: languageName: 中文 title: りんぼの個人ブログ weight: 2 params: sidebar: subtitle: 每天都要努力学习 设置图标\n推荐站点：free icons 下载以后，将图标名称改为favicon.ico，并将其放在static文件夹下 配置图标路径 1 2 3 params: ...... favicon: ./favicon.ico # e.g.: favicon placed in `static/favicon.ico` of your site folder, then set this field to `/favicon.ico` (`/` is necessary) 配置完后使用ctrl+f5进行强制刷新，就能看到图标出现了 日期格式化配置 当前日期格式:\n1 2 3 dateFormat: published: Jan 02, 2006 lastUpdated: Jan 02, 2006 15:04 MST 若要改成yyyy-MM-dd格式，只需要如下设置\n1 2 3 dateFormat: published: 2006-01-02 lastUpdated: Jan 02, 2006 15:04 MST 配置emoji 1 2 3 sidebar: emoji: 🏖️ ...... 设置头像 由于150x150的尺寸，不过由于自动缩放，所以只需要找等比例头像即可，将原先的头像名称复制给他并，放在dev/assets/img文件夹下 这时，头像也变成自己需要的头像\n关闭阅读时间和license 1 2 3 4 5 6 7 article: math: false toc: true readingTime: false # 关闭阅读时间啊 license: enabled: false # 关闭license default: Licensed under CC BY-NC-SA 4.0 关闭评论 单词：disqus(读作discuss) 留言功能， discuss 讨论，utterance 言论；表达\n1 2 3 comments: enabled: false # 关闭评论 provider: disqus 关闭标签云 1 2 3 4 5 6 7 8 9 10 11 12 13 14 widgets: homepage: - type: search # 搜索 - type: archives params: limit: 5 - type: categories # 分类 params: limit: 10 # - type: tag-cloud # params: # limit: 10 page: - type: toc 关闭github与twitter，等后期需要再加上 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ### Custom menu ### See https://stack.jimmycai.com/config/menu ### To remove about, archive and search page menu item, remove `menu` field from their FrontMatter # 注释掉，目前没啥用 # menu: # main: [] # social: # - identifier: github # name: GitHub # url: https://github.com/CaiJimmy/hugo-theme-stack # params: # icon: brand-github # - identifier: twitter # name: Twitter # url: https://twitter.com # params: # icon: brand-twitter 若需要这块功能的图标可以在：https://tabler.io/icons 找\n创建第一篇文章 所有文章放在/dev/content/post下\n创建第一篇文章 1 hugo new content post/myFirstBlog/index.md 创建后自动在文件夹中生成\n","date":"2025-09-25T16:19:14+08:00","permalink":"https://YLine-hub.github.io/p/stack-config/","title":"Stack Config"},{"content":"hugo+github搭建博客 下载hugo 进入hugo官网：hugo 点击github 找到历史版本 下载windows版本 (hugo_extended_0.151.0_windows-amd64.zip) 安装hugo 将下载的压缩包解压 在当前目录下打开cmd 创建项目 1 hugo new site dev 将hugo.exe复制到文件夹内 使用cmd进入文件夹中 1 cd dev 启动服务 1 hugo server -d 打开链接 http://localhost:1313/\n安装主题 在官网点击Themes 选择自己喜欢的主题并下载 将文件放在根目录下的themes文件夹中并解压 exampleSite为样例文件夹 将里面的content和hugo.yaml复制到根目录下 删去post下的rich-content文件夹，原因：其中引用的youtube中的视频，会导致超时 打开配置文件 hugo.yaml 删去配置文件hugo.toml\n根据主题名字修改文件夹名 重启服务 上传github 在github创建仓库 在hugo.yaml修改基础路径 重新生成一下文件 1 hugo -D 在根目录下生成的public，就是我们需要的生成的静态目录 命令行进入public文件夹下 根据github提供的命令上传文件 1 2 3 4 5 6 git init // 初始化git git add . // 将全部添加到本地仓库 git commit -m \u0026#34;first commit\u0026#34; // 提交 git branch -M main // 设置main git remote add origin https://github.com/YLine-hub/YLine-hub.github.io.git // 设置仓库地址 git push -u origin main // 推送到仓库 推送时出现报错，连接服务器失败 原因：经过查阅资料后，发现这是由于在使用 Git 时启用了网络代理，导致 Git 改变了默认端口，从而无法连接到 GitHub。因此，我们需要手动配置 Git 的代理端口来解决该问题。\n查看代理端口 \u0026ndash; 在wifi下，选择proxy \u0026ndash; 选择使用一个代理服务器后的set up \u0026ndash; 找到代理端口 打开命令行\n打开命令行（如 CMD 或 Git Bash），输入以下命令为 Git 配置 HTTP 和 HTTPS 的代理：\n1 2 git config --global http.proxy http://127.0.0.1:7890 git config --global https.proxy http://127.0.0.1:7890 再次提交代码 再次出现报错\n打开魔法，之后再次提交 使用账号登陆 双重验证 连接 同时代码上传成功 打开github，发现代码正常 开启静态页面 点击setting下的pages 选择主分支下的root，并点击保存 出现地址，就说明已经成功了 使用该链接就能进入网站中 ","date":"2025-09-25T15:58:33+08:00","permalink":"https://YLine-hub.github.io/p/hugo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","title":"hugo+github搭建博客"}]